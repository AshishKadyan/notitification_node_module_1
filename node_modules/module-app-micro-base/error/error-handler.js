/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

/*************************************
* Application Error Handler
**************************************/
'use strict';

/************************************
* External npm Modules
************************************/
const Raven = require('raven');

/************************************
 * Internal npm Modules
 ************************************/
const appConstants = require('./../libs/app-constants');
const appUtils = require('./../libs/app-utils');
const config = require('./../../../server/config');
/************************************
* Module exports / Public functions
************************************/
exports.handleError = handleError;

/************************************
* Public function definitions
************************************/

/**
 * set up raven for error logging
 */
let SENTRY_DSN = config.app.sentryDSN;
if (SENTRY_DSN) {
    //set default settings
    let sentry_config = {};
    // set Sentry Environment
    sentry_config['environment'] = config.app.appEnv.toUpperCase();
    //set parusers to capture all req.user data
    sentry_config['parseUser'] = true;
    //enable auto-breadcurmbs
    sentry_config['autoBreadcrumbs'] = true;

    /*
    * Setup additional Sentry configuration here
    * see here: https://docs.sentry.io/clients/javascript/config/
    */
    if (config.app.appEnv != 'local') Raven.config(SENTRY_DSN, sentry_config).install();
}

//Log runtime/uncaught exceptions
process.on('uncaughtException', function (err) {
    handleError(null, null, err.stack, { tag: appConstants.APP.ERROR_TYPES.UNCAUGHT });
});

process.on('exit', function (code) {
    handleError(null, null, `About to exit with code: ${code}`, { tag: appConstants.APP.ERROR_TYPES.EXIT });
});

process.on('unhandledRejection', (reason, promise) => {
    handleError(null, null, `Unhandled Rejection at: ${promise} with reason:${reason}`, { tag: appConstants.APP.ERROR_TYPES.REJECTION });
});



/***************
 * Generic error Handler. It logs error to server and sentry and sends the error response to frontend. 
 * Always use this function for handling errors and avoid handling errors individually.
 * 
 * options  
 *  tags : Error Type.This can have values : DLS_CORE_ERROR
 *  hideErrorPopupOnFE : If true, send 200 http code and prevents error popups on frontend. This is typically done when frontend services plan to handle specific errors themselves (instead of leveraging generic error hanlder)
 */
function handleError(req, res, err, options) {
    //This is done to handle token not found error logs across all controllers
    if (err && err.errorCode == appConstants.APP.ERROR_TYPES.TOKEN_NOT_FOUND) {
        options.tag = appConstants.APP.ERROR_TYPES.TOKEN_NOT_FOUND;
    }

    // As this is already getting logged in Kibana, removing the Sentry logging

    //Record Error in Ravenjs
    // if(SENTRY_DSN && config.app.appEnv != 'local'){
    //     if(Error.prototype.isPrototypeOf(err)){
    //         Raven.captureException(err, {req: req, tags:{ error_type: options.tag } });
    //     } else {
    //         Raven.captureException(new Error(JSON.stringify(err)), {req: req, tags:{ error_type: options.tag } });
    //     }
    // }

    if (Object.keys(err).length == 0) {
        err = err.toString();
    }
    if (err && err.type == 'API_ERROR' && err.httpcode) {
        err.httpcode = transformAPIErrorCode(err.httpcode);
    }
    //Log the error to server
    let errorMessage = "Error Type= " + options.tag + ", Error= " + appUtils.stringify(err);
    if (options.errorInfo) {
        errorMessage += ", Additional Error Information= " + JSON.stringify(options.errorInfo);
    }
    // https://basecamp.com/2083367/projects/14588452/messages/91850133 : error replacing statusCode with httpcode for consistency in logs
    errorMessage = errorMessage.replace(/statusCode/g, 'httpcode');
    syslog.error({ req, ctx: { req } }, errorMessage);
    if (res) {
        if (options.isFurtherComputationsNeeded) { //If any further computations needed do not send the response
            return;
        } else if (options.hideErrorPopupOnFE) {
            res.send({
                success: err.success,
                statusCode: err.statusCode,
                errorCode: err.errorCode
            });
        } else {
            const statusCode = getStatusCodeFromError(err, options)
            if (err.customError) {
                res.status(statusCode).send({
                    statusCode: err.statusCode,
                    errorCode: err.errorCode
                });
            } else {
                res.status(statusCode).send(appConstants.APP.ERROR_TYPES.INTERNAL_SERVER_ERROR);
            }
        }
    }


};

function transformAPIErrorCode(errorCode) {
    switch (errorCode) {
        case 403: return 563; break;
        case 404: return 564; break;
        case 504: return 565; break;
        default: return 560;
    }
}
function getStatusCodeFromError(error, options) {
    // in case of unauthorized req and 401 is in statusCode 
    // api errors codes are in httpcode which are already transformed via transformAPIErrorCode
    if (error && (error.type == 'API_ERROR' ||
        (error.statusCode == 401 && options &&
            (options.tag == appConstants.APP.ERROR_TYPES.AUTHORIZATION_ERROR)))) {
        const errorCode = error && (error.statusCode || error.httpcode);
        switch (errorCode) {
            case 563: // i.e 403
            case 564: // i.e 404
            case 565: // i.e 504
            case 560: // i.e default API error code
            case 401: return errorCode; break;
            default: return 500;
        }
    } else {
        return 500;
    }
}