

/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/


/**********************************************************************
 * Provides functions for accessing PTAs api
 ***********************************************************************/
'use strict';

/************************************
* Internal npm Modules
************************************/
//app config
const config = require('./../../../server/config');
// Error Handler
const errorHandler = require('./../error/error-handler');
//Get App Constants
const appConstants = require('../libs/app-constants');

/************************************
* External npm Modules
************************************/
const soap = require('soap');
const md5 = require('md5');
const parseString = require('xml2js').parseString;

/************************************
* Global Variables
************************************/
let soapClient;



/************************************
* Module exports / Public functions
************************************/
exports.createPTASClient = createPTASClient;
exports.authentication = authentication;
exports.ptasUserCreate = ptasUserCreate;
exports.activateProduct = activateProduct;

/************************************
* Public function definitions
************************************/
function createPTASClient(isFurtherComputationsNeeded = false) {
    // TODO-DOCKER: Read the password from AWS environment variables. This needs updates in setup-cf
    let ptasBasicAuthPassword = "#@dmin123@#";
    if (config.app.appEnv == "prod1") {
        ptasBasicAuthPassword = "$apr1$6se1QriW$FWxJ/zmGXFGFo432RmfQV.";
    }
    const auth = "Basic " + new Buffer(config.app.ptas.basicAuthUsername + ":" + ptasBasicAuthPassword).toString("base64");
    return new Promise((resolve, reject) => {
        soap.createClient(config.app.ptas.wsdlUrl, { wsdl_headers: { Authorization: auth } }, (error, client) => {
            if (error) {
                let errorInfo = `wsdlUrl=${config.app.ptas.wsdlUrl}`;
                errorHandler.handleError(null, null, error, { tag : appConstants.APP.ERROR_TYPES.PTAS.CREATE_CLIENT, errorInfo: errorInfo, isFurtherComputationsNeeded })
                return reject(error);
            } 
            if(client){
                soapClient = client;
                soapClient.setSecurity(new soap.BasicAuthSecurity(config.app.ptas.basicAuthUsername, ptasBasicAuthPassword));
                resolve(client);
            }
        });
    });
}

function authentication(req) {
    const timestamp = new Date().getTime();
    const authenticationArgs = {
        authenticator: req.body.gigyaData.uuid,
        timestamp: timestamp,
        ws_username: config.app.ptas.username,
        ws_password: config.app.ptas.password,
        hash_value: md5(req.body.gigyaData.uuid + '/' + timestamp + '/' + config.app.ptas.privateSharedKey)
    };    
    return new Promise((resolve, reject) => {
        soapClient.authentication(authenticationArgs, async(error, result) => {              
	    delete authenticationArgs.ws_username;
        delete authenticationArgs.ws_password;
        delete authenticationArgs.hash_value;  
            if (error) {                     
                reject({error: error, reqParams : authenticationArgs, tag : appConstants.APP.ERROR_TYPES.PTAS.AUTHENTICATION_API});
            } else {
                const authenticationResponseJson = await xmlToJsonConvertor(result.authentication_flag['$value']);
                if(authenticationResponseJson.authentication.item[0].Error) {
                    reject({error : authenticationResponseJson.authentication.item[0].Error[0], reqParams : authenticationArgs, tag : appConstants.APP.ERROR_TYPES.PTAS.AUTHENTICATION_API })
                } else {
                    resolve(authenticationResponseJson); 
                }
            }
        });
    })
}

function ptasUserCreate(req, authenticationResult) {
    const userCreateArgs = {
        ws_auth_token: authenticationResult.authentication.item[0].ws_auth_token[0],
        ws_auth_req_id: authenticationResult.authentication.item[0].ws_auth_req_id[0],
        user_id: req.body.gigyaData.uuid,
        first_name: req.body.gigyaData.profile.firstName,
        last_name: req.body.gigyaData.profile.lastName,
        email: req.body.gigyaData.profile.email
    };
    return new Promise((resolve, reject) => {
        soapClient.partner_user_create(userCreateArgs, async(error, result) => {
            if (error) {                     
                reject({error: error, reqParams : userCreateArgs, tag : appConstants.APP.ERROR_TYPES.PTAS.USER_CREATE_API});
            } else {
                const userCreateResponseJson = await xmlToJsonConvertor(result.return_val['$value']);
                if(userCreateResponseJson.partner_user_create.item[0].Error) {
                    reject({error : userCreateResponseJson.partner_user_create.item[0].Error[0], reqParams : userCreateArgs, tag : appConstants.APP.ERROR_TYPES.PTAS.USER_CREATE_API })
                } else {
                    resolve(userCreateResponseJson); 
                }
            }
        });
    });
}

function activateProduct(req, authenticationResult) {
    let prodType= 'T';
    if(req.session.role === 'student' || (req._identity && req._identity.role === "student" ) ) {
        prodType = 'S';
    }
    const activateProductArgs = {
        ws_auth_token: authenticationResult.authentication.item[0].ws_auth_token[0],
        ws_auth_req_id: authenticationResult.authentication.item[0].ws_auth_req_id[0],
        user_id: req.body.gigyaData.uuid,
        act_code: req.body.activationCode,
        prod_type: prodType
    };
    return new Promise((resolve, reject) => {
        soapClient.activate_product(activateProductArgs, async(error, result) => {
            delete activateProductArgs.act_code;
            if (error) {
                reject({error: error, reqParams : activateProductArgs, tag : appConstants.APP.ERROR_TYPES.PTAS.ACTIVATE_PRODUCT_API});
            } else {
                const ptasResponse = await xmlToJsonConvertor(result.return_val['$value']);
                const activateProductResponseJson = ptasResponse.activate_product.item[0];
                if (activateProductResponseJson.Error &&
                    ['804', '808', '810', '811', '812', '813'].indexOf(activateProductResponseJson.Error[0].ReasonCode[0]) == -1
                ) {
                    reject({ error: activateProductResponseJson.Error[0], reqParams: activateProductArgs, tag: appConstants.APP.ERROR_TYPES.PTAS.ACTIVATE_PRODUCT_API })
                } else {
                    resolve(ptasResponse);
                }
            }
        });
    });
}

/************************************
* Private function definitions
************************************/
function xmlToJsonConvertor(xml) {
    return new Promise((resolve, reject) => {
        parseString(xml, (err, resultJson) => {
            if (err) {
                reject(err);
            }
            if (resultJson){
            resolve(resultJson);
            }
        });
    });
}

