/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

/**********************************************************************
* Provides functions to interact with gigya server. 
***********************************************************************/
'use strict';

const axios = require("axios");
const crypto = require("crypto")
const querystring = require('querystring');
const jwt = require('jsonwebtoken');
const jwkToPem = require('jwk-to-pem');
//app config
const config = require('./../../../server/config');
const { accountUrls, dsUrls, comments, idxUrls } = config.app.gigya;
//app utils
const appUtils = require('../libs/app-utils');
// Error Handler
const errorHandler = require('./../error/error-handler');
//Get App Constants
const appConstants = require('../libs/app-constants');
const ERROR_TYPES = appConstants.APP.ERROR_TYPES;
const { validate, gigyaControllerValidator } = require("./validators");

/************************************
* Module exports / Public functions
************************************/
exports.getUserInfoFromEmail = getUserInfoFromEmail;
exports.getMultiUserInfoFromEmails = getMultiUserInfoFromEmails;
exports.addUnverifiedInstitution = addUnverifiedInstitution;
exports.verifyAndAddC1referenceInstitution = verifyAndAddC1referenceInstitution;
exports.addEmptyC1ReferencetoInstitution = addEmptyC1ReferencetoInstitution;
exports.exactSearchInstitution = exactSearchInstitution;
exports.searchInstitutions = searchInstitutions;
exports.deleteInstitution = deleteInstitution;
exports.searchUsers = searchUsers;
exports.notifyLogin = gigyaNotifyLogin;
exports.validateJWTToken = validateJWTToken;
exports.markUserVerified = markUserVerified;
exports.getChildrenUsingParentFromGigya = getChildrenUsingParentFromGigya;
exports.getPasswordResetTokenFromGigya = getPasswordResetTokenFromGigya;
exports.updateUserProfile = updateUserProfile;
exports.checkUsernameAvailability = checkUsernameAvailability;
exports.getUserDataFromLoginID = getUserDataFromLoginID;
exports.getUserInfoFromUID = getUserInfoFromUID;
exports.getMultiUsersInfoFromUIDs = getMultiUsersInfoFromUIDs;
exports.getInstitutionDetailsFromSystemID = getInstitutionDetailsFromSystemID;
exports.addInstituteDataForUser = addInstituteDataForUser;
exports.updateInstituteDataForAdmin = updateInstituteDataForAdmin;
exports.scheduleDataflowExecution = scheduleDataflowExecution;
exports.setRequirePasswordChange = setRequirePasswordChange;
exports.registerUser = registerUser;
exports.deleteInstituteDataForUser = deleteInstituteDataForUser;
exports.getInstitutionDetailsFromOID = getInstitutionDetailsFromOID;
exports.getAllUserInfoFromEmail = getAllUserInfoFromEmail;
exports.getUserInfoFromUsername = getUserInfoFromUsername;
exports.changeGigyaRole = changeGigyaRole;


/************************************
* Public function definitions
************************************/

/**
 * fetches user info from gigya by email
 * property email should exist in query or request body
 */
async function getUserInfoFromEmail(req, res, next, isFurtherComputationRequired = false) {
    try {
        let email
        if(req.body.email){
            email = req.body.email
        }else if(req.query.email){
            email = req.query.email.replace(/ /g, '+')
        }

        if(!email){
            let errorDetails = { status: "error", message: `required property email is missing` };
            return responseHandler(req, res, isFurtherComputationRequired , errorDetails , {error : true});
        }

        let params = { query: `SELECT UID,profile,data,identities,isRegistered,isVerified FROM accounts WHERE profile.email="${email}"` };
        let { data } = await axiosGigyaRequestMaker(accountUrls.baseUrl + accountUrls.search, params);
        try {
            if (data.errorCode != 0) {
                //gigya responed with an error
                errorHandler.handleError(req, res, Error("Gigya responded with Error - " + JSON.stringify(data)), { tag: ERROR_TYPES.GIGYA_ACCOUNT_ERROR, response: data, requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.search });
            }
            else if (data.results.length == 0) {
                //  email does not exists in any of the cambridge sites
                return responseHandler(req, res, isFurtherComputationRequired, {exists: false}, { error: false })
            } else {
                const resData = {
                    exists: true,
                    info: {
                        UID: data.results[0].UID,
                        role: getUserRoleFromGigyaData(data.results[0].data),
                        socialProviders: getProviders(data.results[0].identities),
                        isRegistered: data.results[0].isRegistered,
                        isVerified: data.results[0].isVerified,
                        profile: data.results[0].profile
                    }
                }
                return responseHandler(req, res, isFurtherComputationRequired, resData, { error: false })
            }
        } catch (error) {
            return responseHandler(req, res, isFurtherComputationRequired, error, {
                error: true,
                tag: ERROR_TYPES.GIGYA_ACCOUNT_ERROR,
                errorInfo: { message: "GIGYA_ACCOUNT_ERROR, Error while attempting to parse Gigya response... ", requestResponse: data, requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.search }
            });
        }
    } catch (error) {
        return responseHandler(req, res, isFurtherComputationRequired, error, {
            error: true,
            tag: ERROR_TYPES.INTERNAL_SERVER_ERROR,
            errorInfo: { message: "GIGYA_ACCOUNT_ERROR, Error while attempting to call GIGYA API, endpoint... ", requestURL: accountUrls.baseUrl + accountUrls.search }
        });
    }
}

/**
 * fetches multi user info from gigya using the email list
 * expects a 'post' request
 */
async function getMultiUserInfoFromEmails(req, res, next, isFurtherComputationRequired = false) {
    try {
        let emails = '"' + req.body.emails.join('","') + '"';
        let params = { query: `SELECT UID,profile,data FROM accounts WHERE profile.email IN (${emails})` };
        let { data } = await axiosGigyaRequestMaker(accountUrls.baseUrl + accountUrls.search, params);
        try {
            let responseData;

            if (data.errorCode != 0) {
                //gigya responed with an error
                errorHandler.handleError(req, res, Error("Gigya responded with Error - " + JSON.stringify(data)), { tag: ERROR_TYPES.GIGYA_ACCOUNT_ERROR, response: data, requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.search });
            }
            else {
                let users = [];
                let emails = req.body.emails.map(e => e.toLowerCase());
                //for all users returned populate the data
                for (let user of data.results) {
                    users.push({
                        exists: true,
                        info: {
                            UID: user.UID,
                            role: getUserRoleFromGigyaData(user.data),
                            email: user.profile.email
                        }
                    });
                    //remove the found email for emails array
                    emails.splice(emails.indexOf(user.profile.email.toLowerCase()), 1);
                }

                //for non-returned email data 
                for (let email of emails) {
                    users.push({
                        exists: false,
                        info: {
                            email: email
                        }
                    });
                }

                responseData = users;
            }

            if (isFurtherComputationRequired) {
                return responseData;
            } else {
                res.send(responseData);
            }
        } catch (error) {
            if (isFurtherComputationRequired) {
                return Promise.reject(error);
            }
            errorHandler.handleError(req, res, error, { tag: ERROR_TYPES.GIGYA_ACCOUNT_ERROR, errorInfo: { message: "GIGYA_ACCOUNT_ERROR, Error while attempting to parse Gigya response... ", requestResponse: data, requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.search } });
        }
    } catch (error) {
        if (isFurtherComputationRequired) {
            return Promise.reject(error);
        }
        errorHandler.handleError(req, res, error, { tag: ERROR_TYPES.INTERNAL_SERVER_ERROR, errorInfo: "GIGYA_ACCOUNT_ERROR, Error while attempting to call GIGYA API, endpoint... " });
    }
}

/**
 * fetches multi user info from gigya using the userIds list
 * expects a 'post' request
 */
async function getMultiUsersInfoFromUIDs(req, res, next, isFurtherComputationRequired = false) {
    try {
        let userIds = '"' + req.body.userIds.join('","') + '"';
        let params = { query: `SELECT UID,profile,data FROM accounts WHERE UID IN (${userIds})` };
        let { data } = await axiosGigyaRequestMaker(accountUrls.baseUrl + accountUrls.search, params);
        try {
            let responseData = {};

            //gigya responded with an error
            if (data.errorCode != 0) {
                if (isFurtherComputationRequired) {
                    return Promise.reject(Error("Gigya responded with Error - " + JSON.stringify(data)));
                }
                errorHandler.handleError(req, res, Error("Gigya responded with Error - " + JSON.stringify(data)), { tag: ERROR_TYPES.GIGYA_ACCOUNT_ERROR, response: data, requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.search });
            }
            else {
                for (let user of data.results) {
                    responseData[user.UID] = {
                        userId: user.UID,
                        role: user.data && user.data.nemo && user.data.nemo.role ? user.data.nemo.role : '',
                        name: user.profile && user.profile.firstName + ' ' + user.profile.lastName,
                        email: user.profile && user.profile.email ? user.profile.email : '',
                        username: user.profile && user.profile.username ? user.profile.username : ''
                    };
                }
            }

            if (isFurtherComputationRequired) {
                return responseData;
            } else {
                res.send(responseData);
            }
        } catch (error) {
            if (isFurtherComputationRequired) {
                return Promise.reject(error);
            }
            errorHandler.handleError(req, res, error, { tag: ERROR_TYPES.GIGYA_ACCOUNT_ERROR, errorInfo: { message: "GIGYA_ACCOUNT_ERROR, Error while attempting to parse Gigya response... ", requestResponse: data, requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.search } });
        }
    } catch (error) {
        if (isFurtherComputationRequired) {
            return Promise.reject(error);
        }
        errorHandler.handleError(req, res, error, { tag: ERROR_TYPES.INTERNAL_SERVER_ERROR, errorInfo: "GIGYA_ACCOUNT_ERROR, Error while attempting to call GIGYA API, endpoint... " });
    }
}

/**
 * creates new institute in Gigya Data Store with 'isVerified' false && object in systemID array with idSystem 'C1'
 * 
 * request body must have the following fields: 'name', 'addressCountry', 'addressCountryCode', 'addressCity', 'formattedAddress', 'telephone'
 * 
 * @param {*} req : express request object
 * @param {*} res : express response object
 * @param {*} next : express callaback function
 * @param {*} isFurtherComputationRequired : custom param for further computation
 */
async function addUnverifiedInstitution(req, res, next, isFurtherComputationRequired = false) {

    let params;

    try {
        //properties required to exist on the body
        let reqBody = propsFinder(['name', 'addressCountry', 'addressCountryCode', 'addressCity', 'formattedAddress', 'telephone'], req.body);
        let systemID = req.body['dlsID'] ? req.body['dlsID'] : "";
        // if missing property fail request
        if (reqBody.isMissingProperty) {
            let errorDetails = { status: "error", message: `required property ${reqBody.missingProp} is missing` };
            return responseHandler(req, res, isFurtherComputationRequired , errorDetails , {error : true});

        }else{
            //add non-required if they exist
            reqBody = { ...reqBody, 
                        ...( req.body['addressRegion']     && {'addressRegion':     req.body['addressRegion'] } ),
                        ...( req.body['addressRegionCode'] && {'addressRegionCode': req.body['addressRegionCode'] } ),
                ...(req.body['url'] && { 'url': req.body['url'] }),
                "isVerified": false,
                "systemID": [{ idSystem: "C1", idValue: systemID }]
            };

            params = {
                type: 'sr_institution',
                oid: 'auto',
                data: JSON.stringify(reqBody)
            }

            let gigyaResData;
            try {
                let { data } = await axiosGigyaRequestMaker(dsUrls.baseUrl + dsUrls.store, params);
                gigyaResData = data;
            } catch (error) {
                let errorInfo = { info: "GIGYA_DS_ERROR, Error while attempting to call GIGYA API endpoint... ", requestParams: params, requestURL: dsUrls.baseUrl + dsUrls.store };
                return responseHandler(req, res, isFurtherComputationRequired, error, {
                    error: true,
                    tag: ERROR_TYPES.GIGYA_DS_ERROR,
                    errorInfo: errorInfo
                });
            }

            if (gigyaResData.errorCode != 0) {
                //gigya responded with error
                let errorInfo = { response: gigyaResData, requestParams: params, requestURL: dsUrls.baseUrl + dsUrls.store };
                let customError = Error("Gigya responded with error... " + JSON.stringify(errorInfo))
                return responseHandler(req, res, isFurtherComputationRequired, customError, {
                    error: true,
                    tag: ERROR_TYPES.GIGYA_DS_ERROR
                });
            } else {

                //success response from function
                let returnData = {
                    status: 'success',
                    oid: gigyaResData.oid
                };

                return responseHandler(req, res, isFurtherComputationRequired, returnData, { error: false });
            }

        }
    } catch (error) {
        return responseHandler(req, res, isFurtherComputationRequired, error, {
            error: true,
            tag: ERROR_TYPES.INTERNAL_SERVER_ERROR,
            errorInfo: { requestParams: params, requestURL: dsUrls.baseUrl + dsUrls.store }
        });
    }
}

/**
 * searches institutes in Gigya Data Store for 'addressCountryCode' , '' and ['addressRegionCode' or 'postCode']
 * 
 * request body must have the following fields: addressCountryCode'
 * @param {*} req : express request object
 * @param {*} res : express response object
 * @param {*} next : express callaback function
 * @param {*} isFurtherComputationRequired : custom param for further computation
 */
async function exactSearchInstitution(req, res, next, isFurtherComputationRequired = false) {

    let params;

    try {
        //properties required to exist on the body
        let reqBody = propsFinder(['addressCountryCode', 'name'], req.body);

        // if missing property fail request
        if (reqBody.isMissingProperty) {
            let errorDetails = { status: "error", message: `required property ${reqBody.missingProp} is missing` };
            return responseHandler(req, res, isFurtherComputationRequired, errorDetails, { error: true });

        } else {
            // add non-required if they exist
            const data = { ...reqBody, 
                    ...( req.body['addressRegionCode'] && {'addressRegionCode': req.body['addressRegionCode'] } ),
                    ...( req.body['postCode'] && {'formattedAddress': req.body['postCode'] } )
                };

            let whereClause = '';
            Object.keys(data).forEach((key, index)=>{
                if (key == 'formattedAddress')
                {
                    whereClause += `${key} contains '${data[key]}'`;
                }
                else {
                    whereClause += `${key}='${data[key]}'`;
                }
                if (Object.keys(data).length - 1 != index) whereClause += " AND ";

            });


            params = {
                query: `Select * from sr_institution where ${whereClause} limit 10000`
            }

            let gigyaResData;
            try {
                let { data } = await axiosGigyaRequestMaker(dsUrls.baseUrl + dsUrls.search, params);
                gigyaResData = data;
            } catch (error) {
                let errorInfo = { info: "GIGYA_DS_ERROR, Error while attempting to call GIGYA API endpoint... ", requestParams: params, requestURL: dsUrls.baseUrl + dsUrls.search };
                return responseHandler(req, res, isFurtherComputationRequired, error, {
                    error: true,
                    tag: ERROR_TYPES.GIGYA_DS_ERROR,
                    errorInfo: errorInfo
                });
            }

            if (gigyaResData.errorCode != 0) {
                //gigya responded with error
                let errorInfo = { response: gigyaResData, requestParams: params, requestURL: dsUrls.baseUrl + dsUrls.search };
                let customError = Error("Gigya responded with error... " + JSON.stringify(errorInfo))
                return responseHandler(req, res, isFurtherComputationRequired, customError, {
                    error: true,
                    tag: ERROR_TYPES.GIGYA_DS_ERROR
                });
            } else {

                let results = gigyaResData.results.length == 0 ? [] : gigyaResData.results;
                //success response
                let returnData = {
                    status: 'success',
                    results: results
                };

                return responseHandler(req, res, isFurtherComputationRequired, returnData, { error: false });
            }

        }
    } catch (error) {
        return responseHandler(req, res, isFurtherComputationRequired, error, {
            error: true,
            tag: ERROR_TYPES.INTERNAL_SERVER_ERROR,
            errorInfo: { requestParams: params, requestURL: dsUrls.baseUrl + dsUrls.store }
        });
    }
}

/**
 * searches institutes in Gigya Data Store for 'addressCountryCode' and ['addressRegionCode' or 'addressRegion']
 * 
 * request body must have the following fields: addressCountryCode'
 * @param {*} req : express request object
 * @param {*} res : express response object
 * @param {*} next : express callaback function
 * @param {*} isFurtherComputationRequired : custom param for further computation
 */
async function searchInstitutions(req, res, next, isFurtherComputationRequired = false) {

    let params;

    try {
        //properties required to exist on the body
        let reqBody = propsFinder(['addressCountryCode'], req.body);

        // if missing property fail request
        if (reqBody.isMissingProperty) {
            let errorDetails = { status: "error", message: `required property ${reqBody.missingProp} is missing` };
            return responseHandler(req, res, isFurtherComputationRequired, errorDetails, { error: true });

        } else {
            // add non-required if they exist
            const data = { ...reqBody, 
                    ...( req.body['addressRegionCode'] && {'addressRegionCode': req.body['addressRegionCode'] } )
                };

            let whereClause = '';
            Object.keys(data).forEach((key, index) => {
                whereClause += `${key}='${data[key]}'`;
                if (Object.keys(data).length - 1 != index) whereClause += " AND ";

            });


            params = {
                query: `Select * from sr_institution where ${whereClause} limit 10000`
            }

            let gigyaResData;
            try {
                let { data } = await axiosGigyaRequestMaker(dsUrls.baseUrl + dsUrls.search, params);
                gigyaResData = data;
            } catch (error) {
                let errorInfo = { info: "GIGYA_DS_ERROR, Error while attempting to call GIGYA API endpoint... ", requestParams: params, requestURL: dsUrls.baseUrl + dsUrls.search };
                return responseHandler(req, res, isFurtherComputationRequired, error, {
                    error: true,
                    tag: ERROR_TYPES.GIGYA_DS_ERROR,
                    errorInfo: errorInfo
                });
            }

            if (gigyaResData.errorCode != 0) {
                //gigya responded with error
                let errorInfo = { response: gigyaResData, requestParams: params, requestURL: dsUrls.baseUrl + dsUrls.search };
                let customError = Error("Gigya responded with error... " + JSON.stringify(errorInfo))
                return responseHandler(req, res, isFurtherComputationRequired, customError, {
                    error: true,
                    tag: ERROR_TYPES.GIGYA_DS_ERROR
                });
            } else {

                let results = gigyaResData.results.length == 0 ? [] : gigyaResData.results;
                //success response
                let returnData = {
                    status: 'success',
                    results: results
                };

                return responseHandler(req, res, isFurtherComputationRequired, returnData, { error: false });
            }

        }
    } catch (error) {
        return responseHandler(req, res, isFurtherComputationRequired, error, {
            error: true,
            tag: ERROR_TYPES.INTERNAL_SERVER_ERROR,
            errorInfo: { requestParams: params, requestURL: dsUrls.baseUrl + dsUrls.store }
        });
    }
}

/**
 * delete institute in Gigya Data Store using OID on the basis of requestedByPlatform  parameter
 * 
 * if  param 'requestedByPlatform' is 'C1' then delete full institution having same OID
 * otherwise update idValue for idSystem 'C1'
 * @param {*} req : express request object
 * @param {*} res : express response object
 * @param {*} next : express callaback function
 * @param {*} isFurtherComputationRequired : custom param for further computation
 */
async function deleteInstitution(req, res, next, isFurtherComputationRequired = false) {

    let params;

    try {
        //properties required to exist on the body
        let reqBody = propsFinder(['oid', 'requestedByPlatform'], req.body);
        // if missing property fail request
        if (reqBody.isMissingProperty) {
            let errorDetails = { status: "error", message: `required property ${reqBody.missingProp} is missing` };
            return responseHandler(req, res, isFurtherComputationRequired, errorDetails, { error: true });

        }
        else {
            let gigyaResData;
            let dsUrl;
            try {

                // first fetch the instiutue for the given oid
                // and check whether systemID array only contains "C1" ref
                // if yes delete it, else remove "C1" ref from systemID array

                params = {
                    query: `Select * from sr_institution where oid='${reqBody.oid}'`
                }
                let { data: instituteData } = await axiosGigyaRequestMaker(dsUrls.baseUrl + dsUrls.search, params);

                if (instituteData.errorCode != 0) {
                    //gigya responded with error
                    let errorInfo = { response: instituteData, requestParams: params, requestURL: dsUrls.baseUrl + dsUrls.search };
                    let customError = Error("Gigya responded with error... " + JSON.stringify(errorInfo))
                    return responseHandler(req, res, isFurtherComputationRequired, customError, {
                        error: true,
                        tag: ERROR_TYPES.GIGYA_DS_ERROR
                    });
                }

                //if institute does not exist corresponding to the OID, report error
                if (instituteData.results.length == 0) {
                    let errorDetails = { status: "error", message: `No institute found for the corresponding oid ${reqBody.oid}` };
                    return responseHandler(req, res, isFurtherComputationRequired, errorDetails, { error: true });
                }

                //if systemID 'C1' does not exist corresponding to the OID, report error
                let c1Found;

                if (instituteData.results[0].data.hasOwnProperty('systemID')) {
                    c1Found = instituteData.results[0].data.systemID.find((item) => { return item.idSystem == "C1" });
                }

                if (!c1Found) {
                    let errorDetails = { status: "error", message: `No SystemID found for 'C1' corresponding to oid ${reqBody.oid}` };
                    return responseHandler(req, res, isFurtherComputationRequired, errorDetails, { error: true, errorInfo: { params } });
                }

                if (reqBody.requestedByPlatform == 'C1' && instituteData.results[0].data.systemID.length == 1) {
                    dsUrl = dsUrls.delete;
                    params = {
                        type: 'sr_institution',
                        oid: reqBody.oid
                    };

                    let { data } = await axiosGigyaRequestMaker(dsUrls.baseUrl + dsUrl, params);

                    gigyaResData = data;
                }
                else {
                    dsUrl = dsUrls.store;

                    let newSystemArray = [];

                    instituteData.results[0].data.systemID.forEach((item) => {
                        item.idSystem == "C1" ? '' : newSystemArray.push(item);
                    });

                    params = {
                        type: 'sr_institution',
                        oid: reqBody.oid,
                        data: JSON.stringify({ "systemID": newSystemArray }),
                        updateBehavior: "arraySet"
                    };


                    let { data } = await axiosGigyaRequestMaker(dsUrls.baseUrl + dsUrl, params);

                    gigyaResData = data;
                }
            } catch (error) {
                let errorDetails = { requestParams: params, requestURL: dsUrls.baseUrl + dsUrl };
                return responseHandler(req, res, isFurtherComputationRequired, error, {
                    error: true,
                    tag: ERROR_TYPES.GIGYA_DS_ERROR,
                    errorInfo: errorDetails
                });
            }

            if (gigyaResData.errorCode != 0) {
                //gigya responded with error
                let errorDetails = { response: gigyaResData, requestParams: params, requestURL: dsUrls.baseUrl + dsUrl };
                return responseHandler(req, res, isFurtherComputationRequired, errorDetails, {
                    error: true,
                    tag: ERROR_TYPES.GIGYA_DS_ERROR
                });
            } else {
                //success response from function
                let returnData = {
                    status: 'success'
                };
                return responseHandler(req, res, isFurtherComputationRequired, returnData, { error: false });
            }

        }
    } catch (error) {
        return responseHandler(req, res, isFurtherComputationRequired, error, {
            error: true,
            tag: ERROR_TYPES.INTERNAL_SERVER_ERROR,
            errorInfo: { requestParams: params, requestURL: dsUrls.baseUrl + dsUrls.store }
        });
    }
}


/**
 * update institute with given 'oid' to have empty idSystem 'C1' in systemID array
 * 
 * request body must have the following fields: oid
 * @param {*} req : express request object
 * @param {*} res : express response object
 * @param {*} next : express callaback function
 * @param {*} isFurtherComputationRequired : custom param for further computation
 */
async function addEmptyC1ReferencetoInstitution(req, res, next, isFurtherComputationRequired = false) {

    let params;

    try {
        //properties required to exist on the body
        let reqBody = propsFinder(['oid'], req.body);
        let systemID = req.body['dlsID'] ? req.body['dlsID'] : "";
        // if missing property fail request
        if (reqBody.isMissingProperty) {
            let errorDetails = { status: "error", message: `required property ${reqBody.missingProp} is missing` };
            return responseHandler(req, res, isFurtherComputationRequired, errorDetails, { error: true });

        } else {

            params = {
                type: 'sr_institution',
                oid: req.body['oid'],
                data: JSON.stringify({ "systemID": [{ "idSystem": "C1", "idValue": systemID }] })
            }

            let gigyaResData;
            try {
                let { data } = await axiosGigyaRequestMaker(dsUrls.baseUrl + dsUrls.store, params);
                gigyaResData = data;
            } catch (error) {
                let errorInfo = { info: "GIGYA_DS_ERROR, Error while attempting to call GIGYA API endpoint... ", requestParams: params, requestURL: dsUrls.baseUrl + dsUrls.store };
                return responseHandler(req, res, isFurtherComputationRequired, error, {
                    error: true,
                    tag: ERROR_TYPES.GIGYA_DS_ERROR,
                    errorInfo: errorInfo
                });
            }

            if (gigyaResData.errorCode != 0) {
                //gigya responded with error
                let errorInfo = { response: gigyaResData, requestParams: params, requestURL: dsUrls.baseUrl + dsUrls.store };
                let customError = Error("Gigya responded with error... " + JSON.stringify(errorInfo))
                return responseHandler(req, res, isFurtherComputationRequired, customError, {
                    error: true,
                    tag: ERROR_TYPES.GIGYA_DS_ERROR
                });
            } else {
                //success response from function
                let returnData = {
                    status: 'success'
                };
                return responseHandler(req, res, isFurtherComputationRequired, returnData, { error: false });
            }

        }
    } catch (error) {
        return responseHandler(req, res, isFurtherComputationRequired, error, {
            error: true,
            tag: ERROR_TYPES.INTERNAL_SERVER_ERROR,
            errorInfo: { requestParams: params, requestURL: dsUrls.baseUrl + dsUrls.store }
        });
    }
}


/**
 * update institute with given oid to have correct idValue for idSystem 'C1' in systemID array
 * and set property isVerified true
 * 
 * request body must have the following fields: oid, dlsID
 * @param {*} req : express request object
 * @param {*} res : express response object
 * @param {*} next : express callaback function
 * @param {*} isFurtherComputationRequired : custom param for further computation
 */
async function verifyAndAddC1referenceInstitution(req, res, next, isFurtherComputationRequired = false) {
    let params;

    try {
        //properties required to exist on the body
        let reqBody = propsFinder(['oid', 'dlsID'], req.body);

        // if missing property fail request
        if (reqBody.isMissingProperty) {
            let errorDetails = { status: "error", message: `required property ${reqBody.missingProp} is missing` };
            return responseHandler(req, res, isFurtherComputationRequired, errorDetails, { error: true });
        }
        else {
            let gigyaResData;
            try {

                params = {
                    query: `Select * from sr_institution where oid='${reqBody.oid}'`
                }
                let { data: instituteData } = await axiosGigyaRequestMaker(dsUrls.baseUrl + dsUrls.search, params);

                if (instituteData.errorCode != 0) {
                    //gigya responded with error
                    let errorInfo = { response: instituteData, requestParams: params, requestURL: dsUrls.baseUrl + dsUrls.search };
                    let customError = Error("Gigya responded with error... " + JSON.stringify(errorInfo))
                    return responseHandler(req, res, isFurtherComputationRequired, customError, {
                        error: true,
                        tag: ERROR_TYPES.GIGYA_DS_ERROR
                    });
                }

                //if institute does not exist corresponding to the OID, report error
                if (instituteData.results.length == 0) {
                    let errorDetails = { status: "error", message: `No institute found for the corresponding oid ${reqBody.oid}` };
                    return responseHandler(req, res, isFurtherComputationRequired, errorDetails, { error: true });
                }

                let newSystemArray = instituteData.results[0].data.systemID.map((item) => {
                    return item.idSystem == "C1" ? ({ "idSystem": "C1", "idValue": reqBody.dlsID }) : item;
                });

                params = {
                    type: 'sr_institution',
                    oid: reqBody.oid,
                    data: JSON.stringify({ "systemID": newSystemArray, "isVerified": true }),
                    updateBehavior: "arraySet"
                };


                let { data } = await axiosGigyaRequestMaker(dsUrls.baseUrl + dsUrls.store, params);

                gigyaResData = data;
            } catch (error) {
                let errorDetails = { requestParams: params, requestURL: dsUrls.baseUrl + dsUrls.store };
                return responseHandler(req, res, isFurtherComputationRequired, error, {
                    error: true,
                    tag: ERROR_TYPES.GIGYA_DS_ERROR,
                    errorInfo: errorDetails
                });
            }

            if (gigyaResData.errorCode != 0) {
                //gigya responded with error
                let errorDetails = { response: gigyaResData, requestParams: params, requestURL: dsUrls.baseUrl + dsUrls.store };
                return responseHandler(req, res, isFurtherComputationRequired, errorDetails, {
                    error: true,
                    tag: ERROR_TYPES.GIGYA_DS_ERROR
                });
            } else {
                //success response from function
                let returnData = {
                    status: 'success'
                };
                return responseHandler(req, res, isFurtherComputationRequired, returnData, { error: false });
            }

        }
    } catch (error) {
        return responseHandler(req, res, isFurtherComputationRequired, error, {
            error: true,
            tag: ERROR_TYPES.INTERNAL_SERVER_ERROR,
            errorInfo: { requestParams: params }
        });
    }

}

/**
 * returns user data across the Site Group with matching 
 * either of the following firstname, lastname, email, username
 * 
 * request body must have the following fields: globalString
 * following fields are optional fields- localString, role, limit, start, 
 * for sorting: use sortBy in [ 'lastLogin', 'data.nemo.role' ] with sortOrder 'asc' or 'desc'
 * default sortOrder is DESC 
 * @param {*} req : express request object
 * @param {*} res : express response object
 * @param {*} next : express callaback function
 * @param {*} isFurtherComputationRequired : custom param for further computation
 */
async function searchUsers(req, res, next, isFurtherComputationRequired = false) {
    let params;

    try {
        //properties required to exist on the body
        let reqBody = propsFinder(['globalString'], req.body);

        // if missing property fail request
        if (reqBody.isMissingProperty) {
            let errorDetails = { status: "error", message: `required property ${reqBody.missingProp} is missing` };
            return responseHandler(req, res, isFurtherComputationRequired, errorDetails, { error: true });
        }
        else {
            try {

                let baseQuery = "SELECT UID,profile,data,lastLogin from accounts WHERE (preferences.terms.nemo.isConsentGranted=true OR data.press.terms.nemov1.blnAccepted=true) AND ";
                const SORTABLES = ['lastLogin', 'data.nemo.role'];

                //if localString is present, add both globalString and localString AND conditions in bracket
                if (req.body['localString']) {
                    baseQuery += "( (profile.firstName CONTAINS '{STR}' OR profile.lastName CONTAINS '{STR}' OR profile.email CONTAINS '{STR}' OR profile.username CONTAINS '{STR}') ".replace(/{STR}/g, reqBody['globalString']);
                    baseQuery += "AND (profile.firstName CONTAINS '{STR}' OR profile.lastName CONTAINS '{STR}' OR profile.email CONTAINS '{STR}' OR profile.username CONTAINS '{STR}') ) ".replace(/{STR}/g, req.body['localString']);
                } else {
                    baseQuery += "(profile.firstName CONTAINS '{STR}' OR profile.lastName CONTAINS '{STR}' OR profile.email CONTAINS '{STR}' OR profile.username CONTAINS '{STR}') ".replace(/{STR}/g, reqBody['globalString']);
                }

                if (req.body['role'] && (req.body['role'] == 'student' || req.body['role'] == 'teacher')) {
                    baseQuery += `AND (data.nemo.role='${req.body['role']}' OR data.eduelt.instituteRole.role='${req.body['role']}') `;
                }

                if (req.body['sortBy'] && SORTABLES.indexOf(req.body['sortBy']) != -1) {
                    let sortOrder = (req.body['sortOrder'] && req.body['sortOrder'].toLowerCase() == 'desc') ? 'DESC' : 'ASC'
                    baseQuery += ` ORDER BY ${req.body['sortBy']} ${sortOrder} `
                }

                baseQuery += ` LIMIT ${req.body['limit'] ? req.body['limit'] : 25} START ${req.body['start'] ? req.body['start'] : 0} `;

                params = {
                    query: baseQuery
                }

                let { data: gigyaResData } = await axiosGigyaRequestMaker(accountUrls.baseUrl + accountUrls.search, params);

                if (gigyaResData.errorCode != 0) {
                    //gigya responded with error
                    let errorInfo = { response: gigyaResData, requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.search };
                    let customError = Error("Gigya responded with error... " + JSON.stringify(errorInfo))
                    return responseHandler(req, res, isFurtherComputationRequired, customError, {
                        error: true,
                        tag: ERROR_TYPES.GIGYA_ACCOUNT_ERROR
                    });
                }

                let userResultsArray = gigyaResData.results.reduce( ( usersAccumulator, user )=>{
                    //filter other support admins from list, eltSuperAdmin, eltSales and eltCustomerServices which are always either "true" or "false" string
                    if( !(user.profile.samlData && (user.profile.samlData.eltSuperAdmin=='true' || user.profile.samlData.eltCustomerServices=='true' || user.profile.samlData.eltSales=='true') ) ){
                        usersAccumulator.push({
                            role: getUserRoleFromGigyaData(user.data),
                            instituteRoles: user.data && user.data.eduelt && user.data.eduelt.instituteRole,
                            firstName: user.profile.firstName,
                            lastName: user.profile.lastName,
                            email: user.profile.email,
                            username: user.profile.username,
                            country: user.profile.country,
                            uid: user.UID,
                            lastLogin: user.lastLogin,
                            ...(user.data && user.data.parentUID && { parentuid: user.data.parentUID })
                        })
                    }
                    return usersAccumulator;

                }, [] );


                //success response from function
                let returnData = {
                    status: 'success',
                    data: userResultsArray,
                    start: req.body['start'] ? req.body['start'] : 0,
                    objectsCount: userResultsArray.length,
                    totalCount: gigyaResData.totalCount
                };
                return responseHandler(req, res, isFurtherComputationRequired, returnData, { error: false });

            } catch (error) {
                let errorDetails = { requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.search };
                return responseHandler(req, res, isFurtherComputationRequired, error, {
                    error: true,
                    tag: ERROR_TYPES.GIGYA_ERROR,
                    errorInfo: errorDetails
                });
            }

        }
    } catch (error) {
        return responseHandler(req, res, isFurtherComputationRequired, error, {
            error: true,
            tag: ERROR_TYPES.INTERNAL_SERVER_ERROR,
            errorInfo: { requestParams: params }
        });
    }

}


/**
 * returns cookie data to login as the different user
 * 
 * request body must have the following fields: uid
 * @param {*} req : express request object
 * @param {*} res : express response object
 * @param {*} next : express callaback function
 */
async function gigyaNotifyLogin(req, res, next, isFurtherComputationRequired = false) {
    let params;

    try {
        //properties required to exist on the body
        let reqBody = propsFinder(['UID'], req.body);

        // if missing property fail request
        if (reqBody.isMissingProperty) {
            let errorDetails = { status: "error", message: `required property ${reqBody.missingProp} is missing` };
            return responseHandler(req, res, true, errorDetails, { error: true });
        }

        params = { siteUID: reqBody.UID };
        let { data } = await axiosGigyaRequestMaker(accountUrls.baseUrl + accountUrls.notifyLogin, params);
        
        if(data.errorCode != 0 && data.errorCode != 206001){
            //gigya responded with error
            let errorInfo = {response: data, requestURL: accountUrls.baseUrl + accountUrls.notifyLogin };
            let customError = Error("Gigya responded with error... "+ JSON.stringify(errorInfo) )      
            return responseHandler(req, res, isFurtherComputationRequired ,  customError , {
                error : true,
                tag : ERROR_TYPES.GIGYA_ACCOUNT_ERROR
            });                  
        } else {
            return data;
        }

    } catch (error) {
        return responseHandler(req, res, true, error, {
            error: true,
            tag: ERROR_TYPES.GIGYA_ACCOUNT_ERROR,
            errorInfo: { requestParams: params }
        });
    }
}

/**
 * verify JWT token : Please don't use this function directly without isFurtherComputationRequired
 * 
 * request body must have the following fields: jwt
 * @param {*} req : express request object
 * @param {*} res : express response object
 * @param {*} next : express callaback function
 * @param {*} isFurtherComputationRequired : custom param for further computation
 */
async function validateJWTToken(req, res, next,  isFurtherComputationRequired=false) {
    let params;
    try{
        //properties required to exist on the body
        let reqBody = propsFinder( ['jwt'], {...req.query , ...req.body} );
        
        // if missing property fail request
        if(reqBody.isMissingProperty){
            let errorDetails = {status:"error", message: `required property ${reqBody.missingProp} is missing` };
            return responseHandler(req, res, isFurtherComputationRequired ,  errorDetails , {error : true});
        }
        let jwtToken= reqBody.jwt;
        let { data : jwk } = await axiosGigyaRequestMaker( accountUrls.baseUrl + accountUrls.getJWTPublicKey);
        
        if(jwk.errorCode != 0){
            //gigya responded with error
            let errorInfo = {response: jwk, requestURL: accountUrls.baseUrl + accountUrls.getJWTPublicKey };
            let customError = Error("Gigya responded with error... "+ JSON.stringify(errorInfo) )      
            return responseHandler(req, res, isFurtherComputationRequired ,  customError , {
                error : true,
                tag : ERROR_TYPES.GIGYA_JWK_ERROR
            });                  
        }

        let pem = jwkToPem(jwk);
        try{
            return new Promise((resolve)=>{
                jwt.verify(jwtToken, pem, {algorithms: [jwk.alg] ,ignoreExpiration:true} , (err, decoded) => {
                    if( err && !decoded) {
                        return resolve(responseHandler(req, res, isFurtherComputationRequired ,  false , {error : true, tag : ERROR_TYPES.INVALID_JWT, errorInfo: err}));
                    }
                    else {
                        if ( isFurtherComputationRequired ) {
                            return resolve(responseHandler(req, res, true ,  true , {error : false}));
                        }
                        else {
                            next();
                        }
                    }
                });
            });
        } catch(error) {
            return responseHandler(req, res, isFurtherComputationRequired ,  false , {error : false});  
        }
    }catch(error){
        return responseHandler(req, res, isFurtherComputationRequired ,  error , {
            error : true,
            tag : ERROR_TYPES.INTERNAL_SERVER_ERROR,
            errorInfo: { requestParams: params } 
        });
    }
}

/**
 * returns child user details for accounts that have specified data.parentUID
 * 
 * request body must have the following field: parentUID
 * 
 * @param {*} req : express request object
 * @param {*} res : express response object
 * @param {*} next : express callaback function
 * @param {*} isFurtherComputationRequired : custom param for further computation
 */
async function getChildrenUsingParentFromGigya(req, res, next, isFurtherComputationRequired = false) {
    let params
    try {

        //properties required to exist on the body
        let reqBody = propsFinder(['parentUID'], req.body);

        // if missing property fail request
        if (reqBody.isMissingProperty) {
            let errorDetails = { status: "error", message: `required property ${reqBody.missingProp} is missing` };
            return responseHandler(req, res, isFurtherComputationRequired, errorDetails, { error: true });
        }
        
        let baseQuery = `SELECT UID,profile,data,preferences from accounts WHERE data.parentUID = '${req.body.parentUID}' AND isVerified = true ORDER BY createdTimestamp ASC`;
        params = { query: baseQuery };

        try{
            let { data: gigyaResData } = await axiosGigyaRequestMaker(accountUrls.baseUrl + accountUrls.search, params);
            if (gigyaResData.errorCode != 0) {
                //gigya responded with error
                let errorInfo = { response: gigyaResData, requestURL: accountUrls.baseUrl + accountUrls.search };
                let customError = Error("Gigya responded with error... " + JSON.stringify(errorInfo))
                return responseHandler(req, res, isFurtherComputationRequired, customError, {
                    error: true,
                    tag: ERROR_TYPES.GIGYA_ACCOUNT_ERROR
                });
            }else{
                return responseHandler(req, res, isFurtherComputationRequired, gigyaResData.results, { error: false });
            }

        } catch (error) {
            let errorDetails = { requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.search };
            return responseHandler(req, res, isFurtherComputationRequired, error, {
                error: true,
                tag: ERROR_TYPES.GIGYA_ERROR,
                errorInfo: errorDetails
            });
        }

    } catch (error) {
        return responseHandler(req, res, isFurtherComputationRequired, error, {
            error: true,
            tag: ERROR_TYPES.INTERNAL_SERVER_ERROR,
            errorInfo: { requestParams: params }
        });
    }
}


/**
 * Mark User Account verified
 * 
 * request body must have the following fields: uid of user
 * @param {*} req : express request object
 * @param {*} res : express response object
 * @param {*} next : express callaback function
 * @param {*} isFurtherComputationRequired : custom param for further computation
 */
async function markUserVerified(req, res, next,  isFurtherComputationRequired=false){
    let params;
    try{
        let reqBody = propsFinder( ['UID'], req.body );
        
        // if missing property fail request
        if(reqBody.isMissingProperty){
            let errorDetails = {status:"error", message: `required property ${reqBody.missingProp} is missing` };
            return responseHandler(req, res, isFurtherComputationRequired ,  errorDetails , {error : true});
        }
        try{
            params = {
                UID: reqBody.UID,
                isVerified: true
            };
            let { data : setResponse } = await axiosGigyaRequestMaker( accountUrls.baseUrl + accountUrls.setAccountInfo, params);

            if(setResponse.errorCode != 0){
                //gigya responded with error
                let errorInfo = {response: setResponse, requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.setAccountInfo };
                let customError = Error("Gigya responded with error... "+ JSON.stringify(errorInfo) )
                return responseHandler(req, res, isFurtherComputationRequired ,  customError , {
                    error : true,
                    tag : ERROR_TYPES.GIGYA_ACCOUNT_ERROR
                });                  
            }
            else{
                //success response from function
                let returnData = {
                    status: 'success'
                };
                return responseHandler(req, res, isFurtherComputationRequired ,  returnData , {error : false});
            }
        }catch(error){
            let errorDetails = { requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.setAccountInfo };
            return responseHandler(req, res, isFurtherComputationRequired ,  error , {
                error : true,
                tag : ERROR_TYPES.GIGYA_ACCOUNT_ERROR,
                errorInfo: errorDetails
            });
        }
    }catch(error){
        return responseHandler(req, res, isFurtherComputationRequired ,  error , {
            error : true,
            tag : ERROR_TYPES.INTERNAL_SERVER_ERROR,
            errorInfo: { requestParams: params } 
        });
    }

}

/**
 * returns child password reset token
 * 
 * request body must have the following field: loginID
 * 
 * @param {*} req : express request object
 * @param {*} res : express response object
 * @param {*} next : express callaback function
 * @param {*} isFurtherComputationRequired : custom param for further computation
 */
async function getPasswordResetTokenFromGigya(req, res, next, isFurtherComputationRequired = false) {
    let params;
    try {

        //properties required to exist on the body
        let reqBody = propsFinder(['loginID'], req.body);

        // if missing property fail request
        if (reqBody.isMissingProperty) {
            let errorDetails = { status: "error", message: `required property ${reqBody.missingProp} is missing` };
            return responseHandler(req, res, isFurtherComputationRequired, errorDetails, { error: true });
        }
        
        params = { 
            loginID: reqBody.loginID,
            sendEmail :false
        };

        try{
            let { data: gigyaResData } = await axiosGigyaRequestMaker(accountUrls.baseUrl + accountUrls.resetPassword, params);
            if (gigyaResData.errorCode != 0) {
                //gigya responded with error
                let errorInfo = { response: gigyaResData, requestURL: accountUrls.baseUrl + accountUrls.resetPassword };
                let customError = Error("Gigya responded with error... " + JSON.stringify(errorInfo))
                return responseHandler(req, res, isFurtherComputationRequired, customError, {
                    error: true,
                    tag: ERROR_TYPES.GIGYA_ACCOUNT_ERROR
                });
            }else{
                return responseHandler(req, res, isFurtherComputationRequired, gigyaResData.passwordResetToken, { error: false });
            }

        } catch (error) {
            let errorDetails = { requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.resetPassword };
            return responseHandler(req, res, isFurtherComputationRequired, error, {
                error: true,
                tag: ERROR_TYPES.GIGYA_ERROR,
                errorInfo: errorDetails
            });
        }

    } catch (error) {
        return responseHandler(req, res, isFurtherComputationRequired, error, {
            error: true,
            tag: ERROR_TYPES.INTERNAL_SERVER_ERROR,
            errorInfo: { requestParams: params }
        });
    }
}

/**
 * Update Profile Info of User
 * 
 * request body must have the following fields: uid of user, profile of the user
 * @param {*} req : express request object
 * @param {*} res : express response object
 * @param {*} next : express callaback function
 * @param {*} isFurtherComputationRequired : custom param for further computation
 */
async function updateUserProfile(req, res, next,  isFurtherComputationRequired=false){
    let params;
    try{
        let reqBody = propsFinder( ['UID','profile'], req.body );
        
        // if missing property fail request
        if(reqBody.isMissingProperty){
            let errorDetails = {status:"error", message: `required property ${reqBody.missingProp} is missing` };
            return responseHandler(req, res, isFurtherComputationRequired ,  errorDetails , {error : true});
        }
        try{
            params = {
                UID: reqBody.UID,
                profile: JSON.stringify(reqBody.profile)
            };
            let { data : setResponse } = await axiosGigyaRequestMaker( accountUrls.baseUrl + accountUrls.setAccountInfo, params);

            if(setResponse.errorCode != 0){
                //gigya responded with error
                let errorInfo = {response: setResponse, requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.setAccountInfo };
                let customError = Error("Gigya responded with error... "+ JSON.stringify(errorInfo) )
                return responseHandler(req, res, isFurtherComputationRequired ,  customError , {
                    error : true,
                    tag : ERROR_TYPES.GIGYA_ACCOUNT_ERROR
                });                  
            }
            else{
                //success response from function
                let returnData = {
                    status: 'success'
                };
                return responseHandler(req, res, isFurtherComputationRequired ,  returnData , {error : false});
            }
        }catch(error){
            let errorDetails = { requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.setAccountInfo };
            return responseHandler(req, res, isFurtherComputationRequired ,  error , {
                error : true,
                tag : ERROR_TYPES.GIGYA_ACCOUNT_ERROR,
                errorInfo: errorDetails
            });
        }
    }catch(error){
        return responseHandler(req, res, isFurtherComputationRequired ,  error , {
            error : true,
            tag : ERROR_TYPES.INTERNAL_SERVER_ERROR,
            errorInfo: { requestParams: params } 
        });
    }

}

/**
 * returns user profile data
 * 
 * request body must have the following field: loginID
 * 
 * @param {*} req : express request object
 * @param {*} res : express response object
 * @param {*} next : express callaback function
 * @param {*} isFurtherComputationRequired : custom param for further computation
 */
async function getUserDataFromLoginID(req, res, next, isFurtherComputationRequired = false) {
    let params;
    try {

        //properties required to exist on the body
        let reqBody = propsFinder(['loginID'], req.body);

        // if missing property fail request
        if (reqBody.isMissingProperty) {
            let errorDetails = { status: "error", message: `required property ${reqBody.missingProp} is missing` };
            return responseHandler(req, res, isFurtherComputationRequired, errorDetails, { error: true });
        }
        
        let baseQuery = `SELECT UID,profile,data,preferences from accounts WHERE loginIDs.username = '${reqBody.loginID}' OR loginIDs.emails = '${reqBody.loginID}'`;
        params = { query: baseQuery };

        try{
            let { data: gigyaResData } = await axiosGigyaRequestMaker(accountUrls.baseUrl + accountUrls.search, params);
            if (gigyaResData.errorCode != 0) {
                //gigya responded with error
                let errorInfo = { response: gigyaResData, requestURL: accountUrls.baseUrl + accountUrls.search };
                let customError = Error("Gigya responded with error... " + JSON.stringify(errorInfo))
                return responseHandler(req, res, isFurtherComputationRequired, customError, {
                    error: true,
                    tag: ERROR_TYPES.GIGYA_ACCOUNT_ERROR
                });
            }else{
                return responseHandler(req, res, isFurtherComputationRequired, gigyaResData.results, { error: false });
            }

        } catch (error) {
            let errorDetails = { requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.search };
            return responseHandler(req, res, isFurtherComputationRequired, error, {
                error: true,
                tag: ERROR_TYPES.GIGYA_ERROR,
                errorInfo: errorDetails
            });
        }

    } catch (error) {
        return responseHandler(req, res, isFurtherComputationRequired, error, {
            error: true,
            tag: ERROR_TYPES.INTERNAL_SERVER_ERROR,
            errorInfo: { requestParams: params }
        });
    }
}

/**
 * responds with array of usernames which are already taken in gigya
 * 
 * request body must an array containing usernames to be checked in gigya for availability
 * @param {*} req : express request object
 * @param {*} res : express response object
 * @param {*} next : express callaback function
 * @param {*} isFurtherComputationRequired : custom param for further computation
 */
async function checkUsernameAvailability(req, res, next, isFurtherComputationRequired = false) {
    let params;
    try {

        // if missing property fail request
        if ( !Array.isArray(req.body) || req.body.length==0 ) {
            let errorDetails = { status: "error", message: `request body must be a non-empty array` };
            return responseHandler(req, res, isFurtherComputationRequired, errorDetails, { error: true });
        }

        try {

            const lowerCaseUserNamesMap = new Map();

            req.body.forEach((username)=>{
                if(lowerCaseUserNamesMap.has(username.toLowerCase())){
                    (lowerCaseUserNamesMap.get(username.toLowerCase())).push(username)
                }
                else lowerCaseUserNamesMap.set(username.toLowerCase(), [username])
            });
            //creating query part with usernames 
            const usernames = req.body.map(
                user => "'" + user + "'"
            ).join(" OR loginIDs.username contains ");
            
            params = { query: "SELECT loginIDs.username FROM accounts WHERE loginIDs.username contains " + usernames + "" };
            let { data } = await axiosGigyaRequestMaker(accountUrls.baseUrl + accountUrls.search, params); 
            if (data.errorCode != 0) {
                //gigya responded with error
                let errorInfo = { response: data, requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.search };
                let customError = Error("Gigya responded with error... " + JSON.stringify(errorInfo));
                return responseHandler(req, res, isFurtherComputationRequired, customError, {
                    error: true,
                    tag: ERROR_TYPES.GIGYA_ACCOUNT_ERROR
                });
            }
            else {
                //create success response with usernames that are not available in gigya
                const returnData = [];
                data.results.map(user => {
                    if(lowerCaseUserNamesMap.has(user.loginIDs.username.toLowerCase())){
                        returnData.push(...lowerCaseUserNamesMap.get(user.loginIDs.username.toLowerCase()));
                    }
                });
                
                return responseHandler(req, res, isFurtherComputationRequired, returnData, { error: false });
            }
        } catch (error) {
            let errorDetails = { requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.search };
            return responseHandler(req, res, isFurtherComputationRequired, error, {
                error: true,
                tag: ERROR_TYPES.GIGYA_ACCOUNT_ERROR,
                errorInfo: errorDetails
            });
        }
    } catch (error) {
        return responseHandler(req, res, isFurtherComputationRequired, error, {
            error: true,
            tag: ERROR_TYPES.INTERNAL_SERVER_ERROR,
            errorInfo: { requestParams: params }
        });
    }
}


/**
 * fetches user info from gigya by UID
 * 
 * request body must contain UID, omitPII and getAllUsers is optional
 * @param {*} req : express request object
 * @param {*} res : express response object
 */
async function getUserInfoFromUID(req, res, next, isFurtherComputationRequired=false) {
    try {
        //properties required to exist on the body
        let reqBody = propsFinder(['UID'], req.body);

        // if missing property fail request
        if (reqBody.isMissingProperty) {
            let errorDetails = { status: "error", message: `required property ${reqBody.missingProp} is missing` };
            return responseHandler(req, res, false, errorDetails, { error: true });
        }
        else {
            try {
                let params = { query: `SELECT UID,identities,loginIDs,profile,data,regSource,subscriptions,preferences,lastLogin FROM accounts WHERE UID='${req.body.UID}'` };
                const { data } = await axiosGigyaRequestMaker(accountUrls.baseUrl + accountUrls.search, params);
                try {
                    if (data.errorCode != 0) {
                        //gigya responded with an error
                        return responseHandler(req, res, isFurtherComputationRequired,
                            Error("Gigya responded with Error - " + JSON.stringify(data)),
                            { 
                                tag: ERROR_TYPES.GIGYA_ACCOUNT_ERROR,
                                errorInfo: {
                                    response: data, requestParams: params,
                                    requestURL: accountUrls.baseUrl + accountUrls.search 
                                },
                                error: true
                            }
                        );
                    }
                    else if (data.results.length == 0) {
                        //  email does not exists in any of the cambridge sites
                        return responseHandler(req, res, isFurtherComputationRequired, { exists: false }, { error: false });
                    }
                    else {
                        let info;
                        // return array of users if getAllUsers: true in req else return first user
                        if (req.body.getAllUsers) {
                            info = data.results;
                            info.forEach((user) => {
                                user.userRole = getUserRoleFromGigyaData(user.data);
                            });
                        } else info = data.results[0];
                        if(!req.body.hasOwnProperty("omitPII") || req.body.omitPII){
                            info = appUtils.omitPII(info, ['emails', 'name', 'thumbnailurl', 'photourl', 'contactemailaddr', 'bio', 'nickname']);
                        }
                        return responseHandler(req, res, isFurtherComputationRequired, {
                            exists: true,
                            info
                        },{ error: false });
                    }
                } catch (error) {
                    responseHandler(req, res, isFurtherComputationRequired, error, { tag: ERROR_TYPES.GIGYA_ACCOUNT_ERROR, errorInfo: { message: "GIGYA_ACCOUNT_ERROR, Error while attempting to parse Gigya response... ", requestResponse: data, requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.search } });
                }
            } catch (error) {
                responseHandler(req, res, isFurtherComputationRequired, error, { tag: ERROR_TYPES.GIGYA_ACCOUNT_ERROR, errorInfo: "GIGYA_ACCOUNT_ERROR, Error while attempting to call GIGYA API, endpoint... " });
            }
        }
    } catch (error) {
        responseHandler(req, res, isFurtherComputationRequired, error, { tag: ERROR_TYPES.INTERNAL_SERVER_ERROR, errorInfo: "GIGYA_ACCOUNT_ERROR, Error while attempting to call GIGYA API, endpoint... " });
    }
}

/**
 * fetches user info from gigya by email
 * 
 * request body must contain email, omitPII and getAllUsers is optional
 * @param {*} req : express request object
 * @param {*} res : express response object
 */
 async function getAllUserInfoFromEmail(req, res, next, isFurtherComputationRequired = false) {
    try {
        //properties required to exist on the body
        const reqBody = propsFinder(['email'], req.body);

        // if missing property fail request
        if (reqBody.isMissingProperty) {
            const errorDetails = { status: "error", message: `required property ${reqBody.missingProp} is missing` };
            return responseHandler(req, res, false, errorDetails, { error: true });
        }
        else {
            try {
                const params = { query: `SELECT UID,identities,loginIDs,profile,data,regSource,subscriptions,preferences,lastLogin FROM accounts WHERE profile.email='${req.body.email}'` };
                const { data } = await axiosGigyaRequestMaker(accountUrls.baseUrl + accountUrls.search, params);
                try {
                    if (data.errorCode != 0) {
                        //gigya responded with an error
                        return responseHandler(req, res, isFurtherComputationRequired,
                            Error("Gigya responded with Error - " + JSON.stringify(data)),
                            {
                                tag: ERROR_TYPES.GIGYA_ACCOUNT_ERROR,
                                errorInfo: {
                                    response: data, requestParams: params,
                                    requestURL: accountUrls.baseUrl + accountUrls.search
                                },
                                error: true
                            }
                        );
                    }
                    else if (data.results.length == 0) {
                        //  email does not exists in any of the cambridge sites
                        return responseHandler(req, res, isFurtherComputationRequired, { exists: false }, { error: false });
                    }
                    else {
                        let info;
                        // return array of users if getAllUsers: true in req else return first user
                        if (req.body.getAllUsers) {
                            info = data.results;
                            info.forEach((user) => {
                                user.userRole = getUserRoleFromGigyaData(user.data);
                            });
                        } else info = data.results[0];

                        if (!req.body.hasOwnProperty("omitPII") || req.body.omitPII) {
                            info = appUtils.omitPII(info, ['emails', 'name', 'thumbnailurl', 'photourl', 'contactemailaddr', 'bio', 'nickname']);
                        }
                        return responseHandler(req, res, isFurtherComputationRequired, {
                            exists: true,
                            info
                        }, { error: false });
                    }
                } catch (error) {
                    responseHandler(req, res, isFurtherComputationRequired, error, { tag: ERROR_TYPES.GIGYA_ACCOUNT_ERROR, errorInfo: { message: "GIGYA_ACCOUNT_ERROR, Error while attempting to parse Gigya response... ", requestResponse: data, requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.search } });
                }
            } catch (error) {
                responseHandler(req, res, isFurtherComputationRequired, error, { tag: ERROR_TYPES.GIGYA_ACCOUNT_ERROR, errorInfo: "GIGYA_ACCOUNT_ERROR, Error while attempting to call GIGYA API, endpoint... " });
            }
        }
    } catch (error) {
        responseHandler(req, res, isFurtherComputationRequired, error, { tag: ERROR_TYPES.INTERNAL_SERVER_ERROR, errorInfo: "GIGYA_ACCOUNT_ERROR, Error while attempting to call GIGYA API, endpoint... " });
    }
}

/**
 * fetches user info from gigya by username
 * 
 * request body must contain username, omitPII and getAllUsers is optional
 * @param {*} req : express request object
 * @param {*} res : express response object
 */
async function getUserInfoFromUsername(req, res, next, isFurtherComputationRequired = false) {
    try {
        //properties required to exist on the body
        const reqBody = propsFinder(['username'], req.body);

        // if missing property fail request
        if (reqBody.isMissingProperty) {
            const errorDetails = { status: "error", message: `required property ${reqBody.missingProp} is missing` };
            return responseHandler(req, res, false, errorDetails, { error: true });
        }
        else {
            try {
                const params = { query: `SELECT UID,identities,loginIDs,profile,data,regSource,subscriptions,preferences,lastLogin FROM accounts WHERE profile.username='${req.body.username}'` };
                const { data } = await axiosGigyaRequestMaker(accountUrls.baseUrl + accountUrls.search, params);
                try {
                    if (data.errorCode != 0) {
                        //gigya responded with an error
                        return responseHandler(req, res, isFurtherComputationRequired,
                            Error("Gigya responded with Error - " + JSON.stringify(data)),
                            {
                                tag: ERROR_TYPES.GIGYA_ACCOUNT_ERROR,
                                errorInfo: {
                                    response: data, requestParams: params,
                                    requestURL: accountUrls.baseUrl + accountUrls.search
                                },
                                error: true
                            }
                        );
                    }
                    else if (data.results.length == 0) {
                        //  username does not exists in any of the cambridge sites
                        return responseHandler(req, res, isFurtherComputationRequired, { exists: false }, { error: false });
                    }
                    else {
                        let info;
                        // return array of users if getAllUsers: true in req else return first user
                        if (req.body.getAllUsers) {
                            info = data.results;
                            info.forEach((user) => {
                                user.userRole = getUserRoleFromGigyaData(user.data);
                            });
                        } else info = data.results[0];

                        if (!req.body.hasOwnProperty("omitPII") || req.body.omitPII) {
                            info = appUtils.omitPII(info, ['emails', 'name', 'thumbnailurl', 'photourl', 'contactemailaddr', 'bio', 'nickname']);
                        }
                        return responseHandler(req, res, isFurtherComputationRequired, {
                            exists: true,
                            info
                        }, { error: false });
                    }
                } catch (error) {
                    responseHandler(req, res, isFurtherComputationRequired, error, { tag: ERROR_TYPES.GIGYA_ACCOUNT_ERROR, errorInfo: { message: "GIGYA_ACCOUNT_ERROR, Error while attempting to parse Gigya response... ", requestResponse: data, requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.search } });
                }
            } catch (error) {
                responseHandler(req, res, isFurtherComputationRequired, error, { tag: ERROR_TYPES.GIGYA_ACCOUNT_ERROR, errorInfo: "GIGYA_ACCOUNT_ERROR, Error while attempting to call GIGYA API, endpoint... " });
            }
        }
    } catch (error) {
        responseHandler(req, res, isFurtherComputationRequired, error, { tag: ERROR_TYPES.INTERNAL_SERVER_ERROR, errorInfo: "GIGYA_ACCOUNT_ERROR, Error while attempting to call GIGYA API, endpoint... " });
    }
}

/**
 * get institute details from sr_institution using idValue
 * 
 * request body must have the following field: idValue
 * Gigya sr_institute idValue is mapped with space key for the corresponding institute in DLS
 * @param {*} req : express request object
 * @param {*} res : express response object
 * @param {*} next : express callaback function
 * @param {*} isFurtherComputationRequired : custom param for further computation
 */
async function getInstitutionDetailsFromSystemID(req, res, next, isFurtherComputationRequired = false) {
    let params;

    try {
        //properties required to exist on the body
        let reqBody = propsFinder(['idValue'], req.body);

        // if missing property fail request
        if (reqBody.isMissingProperty) {
            let errorDetails = { status: "error", message: `required property ${reqBody.missingProp} is missing` };
            return responseHandler(req, res, isFurtherComputationRequired, errorDetails, { error: true });
        }
        else {
            try {
                params = {
                    query: `Select * from sr_institution where data.systemID.idValue='${reqBody.idValue}'`
                }
                let { data: instituteData } = await axiosGigyaRequestMaker(dsUrls.baseUrl + dsUrls.search, params);

                if (instituteData.errorCode != 0) {
                    //gigya responded with error
                    let errorInfo = { response: instituteData, requestParams: params, requestURL: dsUrls.baseUrl + dsUrls.search };
                    let customError = Error("Gigya responded with error... " + JSON.stringify(errorInfo))
                    return responseHandler(req, res, isFurtherComputationRequired, customError, {
                        error: true,
                        tag: ERROR_TYPES.GIGYA_DS_ERROR
                    });
                }

                //if institute does not exist corresponding to the idValue, report error
                if (instituteData.results.length == 0) {
                    let errorDetails = { status: "error", message: `No institute found for the corresponding idValue ${reqBody.idValue}` };
                    return responseHandler(req, res, isFurtherComputationRequired, errorDetails, { error: true });
                }else{
                    const returnData = {
                        status: 'success',
                        result: instituteData.results[0]
                    };
                    return responseHandler(req, res, isFurtherComputationRequired, returnData, { error: false });
                }
            } catch (error) {
                let errorDetails = { requestParams: params, requestURL: dsUrls.baseUrl + dsUrls.store };
                return responseHandler(req, res, isFurtherComputationRequired, error, {
                    error: true,
                    tag: ERROR_TYPES.GIGYA_DS_ERROR,
                    errorInfo: errorDetails
                });
            }
        }
    } catch (error) {
        return responseHandler(req, res, isFurtherComputationRequired, error, {
            error: true,
            tag: ERROR_TYPES.INTERNAL_SERVER_ERROR,
            errorInfo: { requestParams: params }
        });
    }
}


/**
 * Add institutes data to eduelt instituteRole array for a user
 * 
 * request body must have the following fields: See addInstituteDataForUserSchema
 * keep request header content-type application/json
 * @param {*} req : express request object
 * @param {*} res : express response object
 * @param {*} next : express callaback function
 * @param {*} isFurtherComputationRequired : custom param for further computation
 */
async function addInstituteDataForUser(req, res, next,  isFurtherComputationRequired=false){
    let params;
    try{
        const bodyValidation = validate( gigyaControllerValidator.addInstituteDataForUser, req.body );

        if(!bodyValidation.valid){
            const errorDetails = {status:"error", message: `validation failed: ${bodyValidation.error}` };
            return responseHandler(req, res, isFurtherComputationRequired,  errorDetails, {error : true});
        }

        const { uid, institutes } = req.body

        const institutionDetails = await Promise.all(institutes.map((insti)=>getInstitutionDetailsFromSystemID({ body: { idValue: insti.spaceKey } }, res, next, true)));
        
        const userData = await getUserInfoFromUID({ body: { UID: uid, omitPII: false } }, res, next, true)
        // if missing property fail request
        if (!userData.exists) {
            const errorDetails = { status: "error", message: `no user found with given UID` };
            return responseHandler(req, res, isFurtherComputationRequired, errorDetails, { error: true });
        }

        const { data : { eduelt: eduelt } } = userData.info;

        //add eduelt data if it doesn't exist
        const data = { eduelt: {} }
        data.eduelt.instituteRole = (eduelt && eduelt.instituteRole) ? eduelt.instituteRole : [ getInstituteRoleObject(institutes[0].role) ]


        institutes.forEach((institute, index)=>{
            if (!data.eduelt.instituteRole.some((entry) => entry.key_s == institutionDetails[index].result.oid && entry.platform == "nemo")) {    
                data.eduelt.instituteRole.push(getInstituteRoleObject(institute.role, institutionDetails[index].result.oid, institute.name));
            }
        });

        try{
            params = {
                UID: uid,
                data: JSON.stringify(data)
            };
            const { data : setResponse } = await axiosGigyaRequestMaker( accountUrls.baseUrl + accountUrls.setAccountInfo, params);

            if(setResponse.errorCode != 0){
                //gigya responded with error
                const errorInfo = {response: setResponse, requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.setAccountInfo };
                const customError = Error("Gigya responded with error... "+ JSON.stringify(errorInfo) )
                return responseHandler(req, res, isFurtherComputationRequired ,  customError , {
                    error : true,
                    tag : ERROR_TYPES.GIGYA_EDUELT_ERROR
                });                  
            }
            else{
                //success response from function
                const returnData = {
                    status: 'success'
                };
                return responseHandler(req, res, isFurtherComputationRequired ,  returnData , {error : false});
            }
        }catch(error){
            const errorDetails = { requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.setAccountInfo };
            return responseHandler(req, res, isFurtherComputationRequired ,  error , {
                error : true,
                tag : ERROR_TYPES.GIGYA_EDUELT_ERROR,
                errorInfo: errorDetails
            });
        }
    }catch(error){
        return responseHandler(req, res, isFurtherComputationRequired ,  error , {
            error : true,
            tag : ERROR_TYPES.GIGYA_EDUELT_ERROR,
            errorInfo: { requestParams: params } 
        });
    }

}


/**
 * Update institute data for Admin in case of Promotion/Demotion
 * 
 * request body must have the following fields: uid of user, institute details, action(promote/demote)
 * institute { spaceKey, institutionName }
 * @param {*} req : express request object
 * @param {*} res : express response object
 * @param {*} next : express callaback function
 * @param {*} isFurtherComputationRequired : custom param for further computation
 */
async function updateInstituteDataForAdmin(req, res, next,  isFurtherComputationRequired=false){
    let params;
    try{

        const bodyValidation = validate( gigyaControllerValidator.updateInstituteDataForAdmin, req.body );

        if(!bodyValidation.valid){
            const errorDetails = {status:"error", message: `validation failed: ${bodyValidation.error}` };
            return responseHandler(req, res, isFurtherComputationRequired,  errorDetails, {error : true});
        }

        const { uid, institute, action } = req.body

        if(!institute.oid){
            institute.oid = (await getInstitutionDetailsFromSystemID({ body: { idValue: institute.spaceKey } },res, next, true)).result.oid;
        }
        
        const userData = await getUserInfoFromUID({ body: { UID: uid, omitPII: false } }, res, next, true)
        // if missing property fail request
        if (!userData.exists) {
            const errorDetails = { status: "error", message: `no user found with given UID` };
            return responseHandler(req, res, isFurtherComputationRequired, errorDetails, { error: true });
        }

        //add eduelt data if it doesn't exist
        const data = { eduelt: {} }
        data.eduelt.instituteRole = userData.info.data && userData.info.data.eduelt && userData.info.data.eduelt.instituteRole;

        if (action == "promote") {
            // add teacher role if not present
            if (!data.eduelt.instituteRole) {
                data.eduelt.instituteRole = [getInstituteRoleObject("teacher")];
            }
            //If while admin promotion, a teacher entry is not present for the same institute, Add it
            if (!data.eduelt.instituteRole.some((entry) =>entry.key_s == institute.oid && entry.role == "teacher")) {
                data.eduelt.instituteRole && data.eduelt.instituteRole.push(getInstituteRoleObject("teacher",institute.oid, institute.name));
            }
            
            if(!data.eduelt.instituteRole.some((entry) => (entry.key_s == institute.oid && entry.role == "admin"))){
                data.eduelt.instituteRole && data.eduelt.instituteRole.push(getInstituteRoleObject("admin", institute.oid, institute.name));
            }
        } else if (action == "demote") {
            const adminNodeIndex = data.eduelt.instituteRole && data.eduelt.instituteRole.findIndex((entry) => (entry.key_s == institute.oid && entry.role == "admin"))
            if (adminNodeIndex >= 0) {
                data.eduelt.instituteRole.splice(adminNodeIndex, 1);
            }
        }

        try{
            params = {
                UID: uid,
                data: JSON.stringify(data)
            };
            const { data : setResponse } = await axiosGigyaRequestMaker( accountUrls.baseUrl + accountUrls.setAccountInfo, params);

            if(setResponse.errorCode != 0){
                //gigya responded with error
                let errorInfo = {response: setResponse, requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.setAccountInfo };
                let customError = Error("Gigya responded with error... "+ JSON.stringify(errorInfo) )
                return responseHandler(req, res, isFurtherComputationRequired ,  customError , {
                    error : true,
                    tag : ERROR_TYPES.GIGYA_EDUELT_ERROR
                });                  
            }
            else{
                //success response from function
                let returnData = {
                    status: 'success'
                };
                return responseHandler(req, res, isFurtherComputationRequired ,  returnData , {error : false});
            }
        }catch(error){
            let errorDetails = { requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.setAccountInfo };
            return responseHandler(req, res, isFurtherComputationRequired ,  error , {
                error : true,
                tag : ERROR_TYPES.GIGYA_EDUELT_ERROR,
                errorInfo: errorDetails
            });
        }
    }catch(error){
        return responseHandler(req, res, isFurtherComputationRequired ,  error , {
            error : true,
            tag : ERROR_TYPES.GIGYA_EDUELT_ERROR,
            errorInfo: { requestParams: params } 
        });
    }

}

/**
 * Schedule dataflow execution after specified time
 *
 * @param {number} sec number of seconds after which to schedule dataflow execution
 */
async function scheduleDataflowExecution(sec) {
    const timeStamp = new Date().getTime() + sec * 1000;
    const nextJobStartTime = new Date(timeStamp).toISOString().split('.')[0];

    const params = {
      data: JSON.stringify({
        name: 'Bulk Child Accounts Creation Schedule',
        dataflowId: config.app.gigya.dataflowId,
        frequencyType: 'once',
        nextJobStartTime,
      }),
    };
  
    let gigyaResData;
    try {
      ({ data: gigyaResData } = await axiosGigyaRequestMaker(
        idxUrls.baseUrl + idxUrls.schedule,
        params,
        {keyType: "sso"}
      ));
      
      if (gigyaResData.errorCode != 0) {
        //gigya responded with error
        const errorInfo = {
          response: gigyaResData,
          requestURL: idxUrls.baseUrl + idxUrls.schedule,
        };
        throw 'Gigya responded with error... ' + JSON.stringify(errorInfo);
      }
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

/**
 * Set 'requirePasswordChange' to true in Gigya which forces the user to change the password on login
 * 
 * request body must have the following fields: uid of user, isPasswordReset
 * @param {*} req : express request object
 * @param {*} res : express response object
 * @param {*} next : express callaback function
 * @param {*} isFurtherComputationRequired : custom param for further computation
 */
async function setRequirePasswordChange(req, res, next,  isFurtherComputationRequired=false){
    let params;
    try{
        const bodyValidation = validate( gigyaControllerValidator.setRequirePasswordChangeSchema, req.body );

        if(!bodyValidation.valid){
            const errorDetails = {status:"error", message: `validation failed: ${bodyValidation.error}` };
            return responseHandler(req, res, isFurtherComputationRequired,  errorDetails, {error : true});
        }

        const { uid, isPasswordReset } = req.body

        try{
            params = {
                UID: uid,
                requirePasswordChange: isPasswordReset
            };
            let { data : setResponse } = await axiosGigyaRequestMaker( accountUrls.baseUrl + accountUrls.setAccountInfo, params);
            if(setResponse.errorCode != 0){
                //gigya responded with error
                let errorInfo = {response: setResponse, requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.setAccountInfo };
                let customError = Error("Gigya responded with error... "+ JSON.stringify(errorInfo) )
                return responseHandler(req, res, isFurtherComputationRequired ,  customError , {
                    error : true,
                    tag : ERROR_TYPES.GIGYA_ACCOUNT_ERROR
                });                  
            }
            else{
                //success response from function
                let returnData = {
                    status: 'success'
                };
                return responseHandler(req, res, isFurtherComputationRequired ,  returnData , {error : false});
            }
        }catch(error){
            let errorDetails = { requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.setAccountInfo };
            return responseHandler(req, res, isFurtherComputationRequired ,  error , {
                error : true,
                tag : ERROR_TYPES.GIGYA_ACCOUNT_ERROR,
                errorInfo: errorDetails
            });
        }
    }catch(error){
        return responseHandler(req, res, isFurtherComputationRequired ,  error , {
            error : true,
            tag : ERROR_TYPES.INTERNAL_SERVER_ERROR,
            errorInfo: { requestParams: params } 
        });
    }
}




/**
 * Delete institutes data to eduelt instituteRole array for a user
 * 
 * request body must have the following fields: See deleteInstituteDataForUserSchema
 * keep request header content-type application/json
 * @param {*} req : express request object
 * @param {*} res : express response object
 * @param {*} next : express callaback function
 * @param {*} isFurtherComputationRequired : custom param for further computation
 */
 async function deleteInstituteDataForUser(req, res, next,  isFurtherComputationRequired=false){
    let params;
    try{
        const bodyValidation = validate( gigyaControllerValidator.deleteInstituteDataForUserSchema, req.body );

        if(!bodyValidation.valid){
            const errorDetails = {status:"error", message: `validation failed: ${bodyValidation.error}` };
            return responseHandler(req, res, isFurtherComputationRequired,  errorDetails, {error : true});
        }

        const { uid, institutes } = req.body

        const institutionDetails = await Promise.all(institutes.map((insti)=>getInstitutionDetailsFromSystemID({ body: { idValue: insti.spaceKey } }, res, next, true)));
        
        const userData = await getUserInfoFromUID({ body: { UID: uid, omitPII: false } }, res, next, true)
        // if missing property fail request
        if (!userData.exists) {
            const errorDetails = { status: "error", message: `no user found with given UID` };
            return responseHandler(req, res, isFurtherComputationRequired, errorDetails, { error: true });
        }

        const { data : { eduelt: eduelt } } = userData.info;

        //check if eduelt data exists
        if(! (eduelt && eduelt.instituteRole && Array.isArray(eduelt.instituteRole))){
            const message = { status: "success", message: "User does not have eduelt array"}
            return responseHandler(req, res, isFurtherComputationRequired, message, { error: false });
        }

        //create set of institution oids
        const instituteOidsSet = new Set(institutionDetails.map((i)=>i.result.oid))

        // filter institues for which key_s matches the oid 
        const filteredInstituteRoles = eduelt.instituteRole.filter((entry)=>!instituteOidsSet.has(entry['key_s']))
        const data = { eduelt: {instituteRole: filteredInstituteRoles} }

        try{
            params = {
                UID: uid,
                data: JSON.stringify(data)
            };
            const { data : setResponse } = await axiosGigyaRequestMaker( accountUrls.baseUrl + accountUrls.setAccountInfo, params);

            if(setResponse.errorCode != 0){
                //gigya responded with error
                const errorInfo = {response: setResponse, requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.setAccountInfo };
                const customError = Error("Gigya responded with error... "+ JSON.stringify(errorInfo) )
                return responseHandler(req, res, isFurtherComputationRequired ,  customError , {
                    error : true,
                    tag : ERROR_TYPES.GIGYA_EDUELT_ERROR
                });                  
            }
            else{
                //success response from function
                const returnData = {
                    status: 'success'
                };
                return responseHandler(req, res, isFurtherComputationRequired ,  returnData , {error : false});
            }
        }catch(error){
            const errorDetails = { requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.setAccountInfo };
            return responseHandler(req, res, isFurtherComputationRequired ,  error , {
                error : true,
                tag : ERROR_TYPES.GIGYA_EDUELT_ERROR,
                errorInfo: errorDetails
            });
        }
    }catch(error){
        return responseHandler(req, res, isFurtherComputationRequired ,  error , {
            error : true,
            tag : ERROR_TYPES.GIGYA_EDUELT_ERROR,
            errorInfo: { requestParams: params } 
        });
    }

}




/**
 * Register new user and emails associated with the user are also auto-verified
 * 
 * request body must have the following fields: check registerUser schema in ajv validators file
 * @param {*} req : express request object
 * @param {*} res : express response object
 * @param {*} next : express callaback function
 * @param {*} isFurtherComputationRequired : custom param for further computation
 */
 async function registerUser(req, res, next, isFurtherComputationRequired=false){
    let params;
    try{

        const bodyValidation = validate( gigyaControllerValidator.registerUser, req.body );

        if(!bodyValidation.valid){
            const errorDetails = {status:"error", message: `validation failed: ${bodyValidation.error}` };
            return responseHandler(req, res, isFurtherComputationRequired,  errorDetails, {error : true});
        }

        
        const randomPassword = crypto.randomBytes(10).toString('base64').replace(/(\=|\/|\+)/g, "0") + (new Date().getTime()).toString().slice(-2)

        params = {
            email: req.body.email,
            password: randomPassword,
            profile: JSON.stringify({
                firstName: req.body.profile.firstName,
                lastName: req.body.profile.lastName,
                email: req.body.profile.email,
                country: req.body.profile.country
            }),
            data: JSON.stringify({
                eduelt: {
                instituteRole: [
                    {    
                        "default": false,
                        "isVerified": true,
                        "platform": "nemo",
                        "role": req.body.role,
                        "title": req.body.role
                    }
                ]
                }
            })
        }

        if(req.body.regSource){
            params.regSource = req.body.regSource
        }

        let gigyaResData;
        try {
            ({ data: gigyaResData } = await axiosGigyaRequestMaker(accountUrls.baseUrl + accountUrls.register, params))
        } catch (error) {
            let errorInfo = { info: "GIGYA_ACCOUNTS_ERROR, Error while attempting to call GIGYA API endpoint... ", requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.register };
            return responseHandler(req, res, isFurtherComputationRequired, error, {
                error: true,
                tag: ERROR_TYPES.GIGYA_ACCOUNT_ERROR,
                errorInfo: errorInfo
            });
        }

        if(gigyaResData.errorCode != 206001){ //account verification error should be received
            let errorInfo = { info: "GIGYA_ACCOUNTS_ERROR, Error while attempting to call GIGYA API endpoint... ", requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.register };
            return responseHandler(req, res, isFurtherComputationRequired, Error(JSON.stringify(gigyaResData)), {
                error: true,
                tag: ERROR_TYPES.GIGYA_ACCOUNT_ERROR,
                errorInfo: errorInfo
            });
        }

        await markUserVerified({body: {UID: gigyaResData.UID}}, res, null, true) //TODO: how to handle errors here

        let finalizeResData;
        try {
            params = { regToken: gigyaResData.regToken };
            ({ data: finalizeResData } = await axiosGigyaRequestMaker(accountUrls.baseUrl + accountUrls.finalizeRegistration, params))
        } catch (error) {
            let errorInfo = { info: "GIGYA_ACCOUNTS_ERROR, Error while attempting to call GIGYA API endpoint... ", requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.finalizeRegistration };
            return responseHandler(req, res, isFurtherComputationRequired, error, {
                error: true,
                tag: ERROR_TYPES.GIGYA_ACCOUNT_ERROR,
                errorInfo: errorInfo
            });
        }

        if(finalizeResData.errorCode != 0 && finalizeResData.errorCode != 206001){
            let errorInfo = { info: "GIGYA_ACCOUNTS_ERROR, Error while attempting to call GIGYA API endpoint... ", requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.finalizeRegistration };
            return responseHandler(req, res, isFurtherComputationRequired, Error(JSON.stringify(finalizeResData)), {
                error: true,
                tag: ERROR_TYPES.GIGYA_ACCOUNT_ERROR,
                errorInfo: errorInfo
            });
        }


        return responseHandler(req, res, isFurtherComputationRequired, finalizeResData, {error: false})

    }catch(error){
        return responseHandler(req, res, isFurtherComputationRequired , error , {
            error : true,
            tag : ERROR_TYPES.GIGYA_EDUELT_ERROR,
            errorInfo: { requestParams: params } 
        });
    }

}

/**
 * get institute details from sr_institution using oid
 * 
 * request body must have the following field: oid
 * @param {*} req : express request object
 * @param {*} res : express response object
 * @param {*} next : express callaback function
 * @param {*} isFurtherComputationRequired : custom param for further computation
 */
async function getInstitutionDetailsFromOID(req, res, next, isFurtherComputationRequired = false) {
    let params;

    try {
        //properties required to exist on the body
        let reqBody = propsFinder(['oid'], req.body);

        // if missing property fail request
        if (reqBody.isMissingProperty) {
            let errorDetails = { status: "error", message: `required property ${reqBody.missingProp} is missing` };
            return responseHandler(req, res, isFurtherComputationRequired, errorDetails, { error: true });
        }
        else {
            try {
                params = {
                    query: `Select * from sr_institution where oid='${reqBody.oid}'`
                }
                let { data: instituteData } = await axiosGigyaRequestMaker(dsUrls.baseUrl + dsUrls.search, params);

                if (instituteData.errorCode != 0) {
                    //gigya responded with error
                    let errorInfo = { response: instituteData, requestParams: params, requestURL: dsUrls.baseUrl + dsUrls.search };
                    let customError = Error("Gigya responded with error... " + JSON.stringify(errorInfo))
                    return responseHandler(req, res, isFurtherComputationRequired, customError, {
                        error: true,
                        tag: ERROR_TYPES.GIGYA_DS_ERROR
                    });
                }

                //if institute does not exist corresponding to the idValue, report error
                if (instituteData.results.length == 0) {
                    let errorDetails = { status: "error", message: `No institute found for the corresponding oid ${reqBody.oid}` };
                    return responseHandler(req, res, isFurtherComputationRequired, errorDetails, { error: true });
                }else{
                    const returnData = {
                        status: 'success',
                        result: instituteData.results[0]
                    };
                    return responseHandler(req, res, isFurtherComputationRequired, returnData, { error: false });
                }
            } catch (error) {
                let errorDetails = { requestParams: params, requestURL: dsUrls.baseUrl + dsUrls.search };
                return responseHandler(req, res, isFurtherComputationRequired, error, {
                    error: true,
                    tag: ERROR_TYPES.GIGYA_DS_ERROR,
                    errorInfo: errorDetails
                });
            }
        }
    } catch (error) {
        return responseHandler(req, res, isFurtherComputationRequired, error, {
            error: true,
            tag: ERROR_TYPES.INTERNAL_SERVER_ERROR,
            errorInfo: { requestParams: params }
        });
    }
}
/**
 * Change Role in Gigya
 * request body must have the following field: UID , role
 * @param {*} req : express request object
 * @param {*} res : express response object
 * @param {*} next : express callaback function
 * @param {*} isFurtherComputationRequired : custom param for further computation
 */
async function changeGigyaRole(req, res, next, isFurtherComputationRequired = false) {
    let params;
    try {
        let reqBody = propsFinder(['UID', 'role'], req.body);
        // if missing property fail request
        if (reqBody.isMissingProperty) {
            let errorDetails = { status: "error", message: `required property ${reqBody.missingProp} is missing` };
            return responseHandler(req, res, isFurtherComputationRequired, errorDetails, { error: true });
        }

        const userData = await getUserInfoFromUID({ body: { UID: reqBody.UID, omitPII: false } }, res, next, true)
        // if missing property fail request
        if (!userData.exists) {
            const errorDetails = { status: "error", message: `no user found with given UID` };
            return responseHandler(req, res, isFurtherComputationRequired, errorDetails, { error: true });
        }

        const data = { eduelt: {} }
        data.eduelt.instituteRole = userData.info.data && userData.info.data.eduelt && userData.info.data.eduelt.instituteRole;

        data.eduelt.instituteRole = data.eduelt.instituteRole.map(instituteRoleEntry => {
            if (instituteRoleEntry.platform == "nemo") {
                instituteRoleEntry.role = reqBody.role;
                instituteRoleEntry.title = reqBody.role;
            }
            return instituteRoleEntry;
        })

        try{
            params = {
                UID: reqBody.UID,
                data:JSON.stringify(data)
            };
            let { data: setResponse } = await axiosGigyaRequestMaker(accountUrls.baseUrl + accountUrls.setAccountInfo, params);
            if (setResponse.errorCode != 0) {
                //gigya responded with error
                let errorInfo = { response: setResponse, requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.setAccountInfo };
                let customError = Error("Gigya responded with error... " + JSON.stringify(errorInfo))
                return responseHandler(req, res, isFurtherComputationRequired, customError, {
                    error: true,
                    tag: ERROR_TYPES.GIGYA_ACCOUNT_ERROR
                });
            }
            else {
                //success response from function
                let returnData = {
                    status: 'success'
                };
                return responseHandler(req, res, isFurtherComputationRequired, returnData, { error: false });
            }

        }
        catch (error) {
            let errorDetails = { requestParams: params, requestURL: accountUrls.baseUrl + accountUrls.setAccountInfo };
            return responseHandler(req, res, isFurtherComputationRequired, error, {
                error: true,
                tag: ERROR_TYPES.GIGYA_ACCOUNT_ERROR,
                errorInfo: errorDetails
            });
        }

    } catch (error) {
        return responseHandler(req, res, isFurtherComputationRequired, error, {
            error: true,
            tag: ERROR_TYPES.INTERNAL_SERVER_ERROR,
            errorInfo: { requestParams: params }
        });
    }
}

/************************************
* Private/Utility function definitions
************************************/
function getCrendentials(credParams) {

    let key = config.app.gigyaKey;
    if(credParams && credParams.keyType){
        switch(credParams.keyType){
            case "sso": 
                key = config.app.gigya.ssoApiKey
                break
            case "child": 
                key = config.app.gigya.childApiKey
                break
            default:
                key = config.app.gigyaKey
        }
    }

    return {
        'apiKey': key,
        'userKey': config.app.gigya.appKey,
        'secret': config.app.gigya.appSecret
    }
}


function axiosGigyaRequestMaker(gigyaEndPoint, params, credParams) {
    return axios.post(gigyaEndPoint, querystring.stringify({ ...params, ...getCrendentials(credParams) }), { 'content-type': 'application/x-www-form-urlencoded' });
}

/**
 * 
 * @param {*} identities array of identity providers {provider, allowsLogin}
 * @returns comma separated list of true login providers
 * 
 * Error in this code will be caught by the calling routine
 */
function getProviders(identities) {
    return identities.filter(id => id.allowsLogin).map(id => id.provider).join(',');
}

/**
 * returns the missing property from body or
 * object with the required props
 * 
 * @param {*} expectedProperties array of properties that must exist on req.body
 * @param {*} reqBody req.body
 */
function propsFinder(expectedProperties, reqBody) {
    let data = {}, missingProp, isMissingProperty = false;

    for (let prop of expectedProperties) {
        if (!reqBody.hasOwnProperty(prop)) {
            isMissingProperty = true;
            missingProp = prop;
            break;
        }
        data[prop] = reqBody[prop];
    }
    return isMissingProperty ? { isMissingProperty: isMissingProperty, missingProp: missingProp } : data;
}

/**
 * 
 * @param {*} isFurtherComputationRequired  if true function returns promise 
 * @param {*} resObj contains new Error object or Success object to be send to user
 * @param {*} info contains { error: boolean, tag: errorTag, errorInfo , res, req }
 */
function responseHandler(req, res, isFurtherComputationRequired, resObj, info) {
    if (isFurtherComputationRequired) {
        if (info.error) {
            errorHandler.handleError(req, false, resObj, { tag: info.tag ? info.tag : ERROR_TYPES.GIGYA_ERROR, errorInfo: info.errorInfo });
            return Promise.reject(resObj);
        }
        else {
            return Promise.resolve(resObj);
        }
    }
    else {
        if (info.error) {
            errorHandler.handleError(req, res, resObj, { tag: info.tag ? info.tag : ERROR_TYPES.GIGYA_ERROR, errorInfo: info.errorInfo });
        }
        else {
            res.send(resObj);
        }
    }
}

/**
 * returns user nemo/C1 role 
 * @param {string} data Gigya data object
 */
function getUserRoleFromGigyaData(data) {
    if (data && data.eduelt && data.eduelt.instituteRole) {
        const institute = data.eduelt.instituteRole.find((item) => item.platform === "nemo" && !item.key_s)
        return (institute && institute.role) || ''
    }
    return (data && data.nemo && data.nemo.role) || ''
}


/**
 * returns instituteRole object
 * @param {string} role role of the user
 * @param {string} [oid] oid of the institute
 * @param {string} [instiName] name of the institute
 */
function getInstituteRoleObject(role, oid, instiName ){
    
    const instiRole = {
        "default": false,
        "isVerified": true,
        "platform": "nemo",
        "role": role,
        "title": role
    }

    if(oid) instiRole["key_s"] = oid
    if(instiName) instiRole["institute"] = instiName

    return instiRole
}