/*************************************************************************
*
* COMPRO CONFIDENTIAL
* __________________
*
*  [2015] - [2020] Compro Technologies Private Limited
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Compro Technologies Private Limited. The
* intellectual and technical concepts contained herein are
* proprietary to Compro Technologies Private Limited and may
* be covered by U.S. and Foreign Patents, patents in process,
* and are protected by trade secret or copyright law.
*
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Compro Technologies Pvt. Ltd..
***************************************************************************/

/**********************************************************************
* Provides functions for user authentication. 
***********************************************************************/
'use strict';

/************************************
* Internal npm Modules
************************************/
//Get Application config
const config = require('./../../../server/config');
//Error Handler
const errorHandler =  require("../error/error-handler");
//Get App Constants
const appConstants = require('../libs/app-constants');
// gigya controller
const gigyaController = require('./gigya-controller');
// app utils
const appUtils = require('../libs/app-utils');
// session utils
const sessionUtils = require('../libs/session-utils');
/************************************
* Module exports / Public functions
************************************/
exports.login = login;
exports.logout = logout;
exports.isUserAuthenticated = isUserAuthenticated;
exports.proxyLogin = proxyLogin;
// Private functions exports
exports.passportLogin = passportLogin;
exports.getUserSpaces = getUserSpaces;
exports.isUserAdmin = isUserAdmin;

/************************************
* Public function definitions
************************************/
async function login(req, res, next, isFurtherComputationRequired=false) {
 try {
   const user = { "extUserId" : req.body.UID }
   if(req.body.c1UserRole)    user['role'] = req.body.c1UserRole;
   if(req.body.profile.email)     user['email'] = req.body.profile.email;
   if(req.body.profile.firstName) user['firstName'] = req.body.profile.firstName;
   if(req.body.profile.lastName)  user['lastName'] = req.body.profile.lastName;

   let errorCaught = false;
   let userSpaces;
   let userSpaceCount;
   const comproDLS = await sessionUtils.initializeComproDLS(req);
   try {
       if(req.body.samlData && (req.body.samlData.eltCustomerServices == "true" || req.body.samlData.eltSuperAdmin == "true" || req.body.samlData.eltSales == "true")){
         user.role = "superadmin";
         user.samlData = req.body.samlData;
       }else if(user.role == 'teacher') {
         const params = { extuserid: user.extUserId };
         userSpaces = await comproDLS.Spaces(config.app.dlsAccountId).getUserSpaces(params);
         if(userSpaces.count > 0 && isUserAdmin(userSpaces)) {
           user.role = 'admin';
         }
       } 
   } catch(error) {
     errorCaught = true;
     errorHandler.handleError(req, res, error, { tag : appConstants.APP.ERROR_TYPES.DLS_CORE });
   }

   if(!errorCaught) {
     //Login into passport
     await passportLogin(req,res,user);

     if(req.body.isSpaceDataNeeded) {
       userSpaces = await getUserSpaces(req, res, next, userSpaces)
     }
     let loginResponse;
     if(req.body.isSpaceCountNeeded || user.role == 'teacher' || user.role == 'admin')
     {
       if(!userSpaces)
       {
         const params = { extuserid: user.extUserId };
         userSpaces = await comproDLS.Spaces(config.app.dlsAccountId).getUserSpaces(params);
       }
      
       userSpaceCount = userSpaces.count;
       loginResponse = { user:user, userSpaceCount:userSpaceCount};

       if(user.role == 'teacher' || user.role == 'admin') {
         let userId = '';
         userSpaces.entities.forEach((entity)=> {
           if (entity.dls_org_id == req.body.orgId) {
             userId = entity.dls_teacher_id;
           }
         });
         loginResponse.userId = userId;
       }
     }
     else{
       loginResponse = {user:user};
     }
      if(req.body.isSpaceDataNeeded &&  user.role == 'student') {
        loginResponse.userSpaces = userSpaces;
      }
      if(isFurtherComputationRequired) return loginResponse;
      res.send(loginResponse)

   }  
 } catch(error) {
   errorHandler.handleError(req, res, error, { tag : appConstants.APP.ERROR_TYPES.NODE_SERVER });
 }
}

//Handle user logout request
function logout(req, res){  
 //Passport logout and destroy session
 req.logout();
 req.session.destroy(() => {   
   //Return success response
   return res.status(200).send({success:true})
 });
}

//Function to check if passport session for user exist or not 
function isUserAuthenticated(req, res, next, isFurtherComputationsNeeded = false) {
  let response;
  if (req.isAuthenticated()) {
    response = {
      userAuthenticated: true,
      user: {
        extUserId: req.session.extUserId,
        role: req.session.role,
        email: req.session.email,
        firstName: req.session.firstName,
        lastName: req.session.lastName,
        launchType: req.session.launchType
      },
      serviceAnnouncement: config.app.announcement.msg
    }
    if(req.session.samlData) response.user.samlData = req.session.samlData;

  } else {
    response = {
      userAuthenticated: false,
      serviceAnnouncement: config.app.announcement.msg
    }
  }
  if (isFurtherComputationsNeeded) {
    return response;
  } else {
    res.send(response);
  }
}

/**
 * 
 * allows support admins to login as another user
 * also used by parent to login as child
 * please use this function with extra precaution
 * use middleware to ascertain user role/permission level before calling this function
 * at the client, after successful response from this function refresh the browser tab for proxy login to take effect
 * 
 */
async function proxyLogin(req, res, next) {
  try {        
      let { sessionInfo } = await gigyaController.notifyLogin(req, res, next);
      if(!sessionInfo){
        res.status(500).send({status: 'fail'});
        return;
      }

      // set cookies provide by gigya,
      // client gigya.js will read these cookies to dynamically switch session 
      res.cookie(sessionInfo.cookieName, sessionInfo.cookieValue);
      
      let currentUserInfo = {
        uid: req.session.extUserId,
        firstName: req.session.firstName,
        lastName: req.session.lastName
      }
      
      //retain cookie and passport in session delete the rest
      for(let key in req.session){
        if(key!='cookie' && key!='passport')
          delete req.session[key];
      }
      
      // use normal login process
      // this will switch the redis-passport app session
      await login(req, res, next);

      let info = {
          success: true,
          status: 200,
          code: appConstants.APP.INFO_TYPES.PROXY_LOGIN_SUCCESS,
          description: "User with details "+ JSON.stringify(currentUserInfo) + " proxy login as user "+ JSON.stringify(
            {
              uid: req.session.extUserId,
              firstName: req.session.firstName,
              lastName: req.session.lastName
            })
      };
      
      syslog.info({req}, appUtils.getUserInfoFromReq(req) + "Info= " + JSON.stringify(info));

  } catch (error) {
    moduleAppMicroBase.errorHandler.handleError(req, res, error, {tag : appConstants.SUPPORT_ADMIN.ERROR_TYPES.DLS_CORE});
  }
}



/************************************
* Private functions
************************************/

// Passport Login
function passportLogin(req,res,user){

 return new Promise((resolve, reject) => {
   //Passport Login
   req.logIn({ "extUserId" : user.extUserId }, (err) => {            
       //If error logging in passport, send error response
       if (err) {
         reject(err);
       }
       req.session.extUserId = user.extUserId;
       req.session.role = user.role;
       req.session.email = user.email;
       req.session.firstName = user.firstName;
       req.session.lastName = user.lastName;
       if(user.samlData) req.session.samlData = user.samlData;
       resolve();
   });

 });
}

function isUserAdmin(spacesData) {
 return spacesData.entities.some(particularSpace => {
     return particularSpace.space_role === 'admin'
 });
}



//Function to get all spaces of user, classes and products(if spaces exists)
async function getUserSpaces(req, res, next,userSpaces) {
 /*
  * isFurtherComputationsNeeded param (true) is passed if the response of current function is
  * used for further promise chaining and need not to be returned to frontend
  */
 const comproDLS = await sessionUtils.initializeComproDLS(req);
 try {
     if(!userSpaces) {
       const params = { extuserid: req.session.extUserId }; 
       userSpaces = await comproDLS.Spaces(config.app.dlsAccountId).getUserSpaces(params);
     }
     const provisionUserPromises = [];

     if(userSpaces.count > 0) {
        userSpaces.entities.forEach(userSpace => {
          provisionUserPromises.push(provisionUser(req,userSpace))
        })

        //Get all products of user in a particular space
        userSpaces.entities = await Promise.all(provisionUserPromises);

        return userSpaces;
     } else {
       return userSpaces;
     }


 } catch (error) {
   return Promise.reject(error); 
 }
}


//Function for provisioning user 
async function provisionUser(req,userSpace) {
  try {
    const comproDLS = await sessionUtils.initializeComproDLS(req);
    const provisionParams = {
      "ext_user_id": req.session.extUserId,
    }

    if (!req.session[userSpace.space_key]) {
      //Provision Gigya User in DLS
      const provisioningResponse = await comproDLS.authWithExtUser(userSpace.dls_org_id, provisionParams, {});

      //Store token,orgId etc in session
      req.session[userSpace.space_key] = {
        "orgId": provisioningResponse.user.org.id,
        "userId": provisioningResponse.user.uuid,
        "accessToken": provisioningResponse.token.access_token
      }
    }

    if (req.session.role === "student"){
      if(userSpace.space_type !== 'student-private') {
        await comproDLS.authWithToken(req.session[userSpace.space_key].orgId, await sessionUtils.getTokenFromSession(req, userSpace.space_key), {});
        // Get classes of teacher
        userSpace.classes = await comproDLS.Auth().getUserClasses({
          userid: req.session[userSpace.space_key].userId,
          details: true,
          limit: 25,
          sortField: 'title',
          sortOrder: 'asc',
          bundleDetails: true
        })
      } else {
        const entitlementsParams = {
            extUserId: req.session.extUserId,
            productDetails: true,
            bundleDetails: true
        }
        // Get Products of a user
        const products = await comproDLS.Product(config.app.dlsAccountId).getGlobalEntitlementsForAUser(entitlementsParams);
        userSpace.products = products.entities;   
      }
    }


    //Updated user space
    return userSpace;

  } catch (error) {
    return Promise.reject(error);
  }
}