/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

/**********************************************************************
 * Provides utility functions to be used across App
 ***********************************************************************/
'use strict';


/************************************
* External npm Modules
************************************/


/************************************
* Internal npm Modules
************************************/
const config = require('./../../../server/config');
const { inspect } = require("util")


/************************************
* Module exports / Public functions
************************************/
exports.getUserInfoFromReq = getUserInfoFromReq;
exports.getUserInfoObjFromReq = getUserInfoObjFromReq;
exports.omitPII = omitPII;
exports.getAppDomain = getAppDomain;
exports.stringify = stringify


/************************************
* Public function definitions
************************************/

// Get User Info From Request
/**
 * This function will generate and return the userInfo as string
 * @param {*} req 
 * @param {*} spaceId 
 */
function getUserInfoFromReq(req, spaceId = undefined) {
    const keysMapping = {
        clientIpAddress: 'Client IP address',
        extUserId: 'External UserId',
        spaceId: 'SpaceId',
        orgId: 'OrgId',
        userId: 'UserId'
    }

    const userInfoObj = getUserInfoObjFromReq(req, spaceId);
    var retString = '';
    Object.keys(userInfoObj).forEach(key => {
        if(!keysMapping[key]) return;
        retString += `${keysMapping[key]}= ${userInfoObj[key]}, `;
    });
    return retString;
}

/**
 * This function will generate and return the userInfo as object
 * @param {*} req 
 * @param {*} spaceId 
 */
function getUserInfoObjFromReq(req, spaceId = undefined) {
    let userInfo = {};
    if (req) {
        if (config.app.appEnv != 'local') {
            let ipaddress;
            if (req.headers && req.headers['x-forwarded-for']) {
                ipaddress = req.headers['x-forwarded-for'];
            } else if (req.connection && req.connection.remoteAddress) {
                ipaddress = req.connection.remoteAddress;
            }
            if (ipaddress)
                userInfo.clientIpAddress = ipaddress;
        }
        if (req.session) {
            userInfo.extUserId = req.session.extUserId;
        }
        if (!spaceId && req.params && req.params.spaceId) spaceId = req.params.spaceId;
        if (spaceId) {
            userInfo.spaceId = spaceId;
            if (req.session[spaceId]) {
                userInfo.orgId = req.session[spaceId].orgId;
                userInfo.userId = req.session[spaceId].userId;
            }
        }

        // adding class id
        const classId = getParamValue('classid');
        if(classId) {
            userInfo.classId = classId;
        }
        
        // adding product code
        const productCode = getParamValue('productcode');
        if(productCode) {
            userInfo.productCode = productCode;
        }
    }
    return userInfo;

    function getParamValue(paramName) {
        if (!(req && paramName)) return;

        const mapData = {
            classid: ['classid', 'classId'],
            productcode: ['productcode', 'productCode', 'prodCode']
        };

        const possibleParamNames = mapData[paramName];

        let value;
        for (const pName of possibleParamNames) {
            value = (req.params && req.params[pName])
                || (req.body && req.body[pName])
                || (req.query && req.query[pName]);
            if (value) break;
        }
        return value;
    }
}


/**
 *
 * Remove PIIs (Personally identifiable information) from any object
 *  
 * @param {*} input object from which PIIs need to be removed
 * @param {*} list more keys to be removed from object (in lowercase)
 */
function omitPII(input, list = []) {
    const PIISet = new Set([...config.app.piiList,...list])
    //TODO: remove circular json?
    return recursiveOmitter(input, PIISet)
}

/**
 * @returns {string} current app domain
 */
function getAppDomain(){
    switch(config.app.appEnv){
        case 'local':
        case 'thor':
            return 'https://micro-nemo.comprodls.com/';
        case 'qa':
            return 'https://qa.cambridgeone.org/';
        case 'alpha':
            return 'https://c1-alpha.cambridgeone.org/';
        case 'hfx':
            return 'https://hotfix.cambridgeone.org/';
        case 'rel':
            return 'https://release.cambridgeone.org/';
        case 'prod1':
            return 'https://www.cambridgeone.org/';
    }
}

/**
 * stringify circular and non-circular objects
 * @param {*} obj 
 * @returns string 
 */
function stringify(obj){
    try {
        return JSON.stringify(obj)
    }catch{
        try{
            return inspect(obj, {depth: null, maxStringLength: null})
        }catch{
            return toString.call(obj)
        }
    }
}   


function recursiveOmitter(obj, omitList) {
    
    // return if obj is not array or object
    if (!Array.isArray(obj) && !(Object.prototype.toString.call(obj) === "[object Object]")) {
        return obj;
    }

    const o = Array.isArray(obj) ? [] : {}
    
    for (const key in obj) {
        if ( obj.hasOwnProperty(key) && !omitList.has(key.toLowerCase()) ) {
            const val = recursiveOmitter(obj[key], omitList)

            if(Array.isArray(o)) o.push(val)
            else o[key]=val
            
        }
    }
    
    return o
}
