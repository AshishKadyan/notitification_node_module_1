/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

/**********************************************************************
 * Provides functions for sending email using ses
 ***********************************************************************/
"use strict";

/************************************
 * Internal Modules
 ************************************/
const config = require("./../../../server/config");

const awsS3 = require("aws-sdk/clients/s3");
/************************************
 * Module exports / Public functions
 ************************************/
exports.getServiceFlags = getServiceFlags;
exports.putServiceFlags = putServiceFlags;
exports.getServiceNames = getServiceNames;
/************************************
 * Public function definitions
 ************************************/
const dlsShareds3 = new awsS3({
  accessKeyId: config.app.appsData.accessKey,
  secretAccessKey: config.app.appsData.secretKey,
  region: config.app.appsData.region,
});

let cachedServicesFlags = {};

// return array of services from serviceAvailet cachedServicesFlags = {};
// sets a service data as fetched from s3 and adds cachingTimeStamp to it
function setServiceFlag(data) {
  cachedServicesFlags[data.id] = {};
  cachedServicesFlags[data.id]["v"] = data.value;
  cachedServicesFlags[data.id]["t"] = Date.now();
}

// return services from serviceAvailability bucket in s3
// set options.forceFetchFromDataStore to true in case you need to fetch data from s3 and want full json data as well
async function getServiceFlags(services, options = {}) {
  let currTimeStamp = Date.now();
  let promiseArray = [];
  let serviceFlagsToReturn = {};

  for (let service of services) {
    // only fetch data from s3 if not cached and if caching time has expired
    if (
      options.forceFetchFromDataStore ||
      !cachedServicesFlags[service] ||
      cachedServicesFlags[service].t +
        config.app.availabilityService.cachingTime <
        currTimeStamp
    ) {
      let fileName = service;
      let params = {
        Bucket: config.app.appsData.bucketName,
        Key: config.app.availabilityService.s3Folder + fileName + ".json",
      };
      promiseArray.push(getS3Object(dlsShareds3, params));
    }
  }
  let res = await Promise.all(promiseArray);
  res = res.map((data) => {
    return JSON.parse(data.Body.toString());
  });
  // cache the services data which were not cached before
  res.forEach((serviceData) => {
    setServiceFlag(serviceData);
    // fill all json data in serviceFlagsToReturn
    if (options.forceFetchFromDataStore) {
      serviceFlagsToReturn[serviceData.id] = serviceData;
    }
  });

  if (options.forceFetchFromDataStore) {
    return serviceFlagsToReturn;
  }else{
    // fill the services data from already cachedServicesFlags
    services.forEach((service) => {
      serviceFlagsToReturn[service] = cachedServicesFlags[service];
    });
    return serviceFlagsToReturn;
  }
}
//  returns all the services mentioned in the Availability Services
function getServiceNames() {
  return config.app.availabilityService.services;
}

//  Sets/Unsets the flag for the selected service and uploads it to s3 bucket
async function putServiceFlags(id, serviceName, state, options = {}) {
  let obj = config.app.availabilityService.services;
  let key = Object.keys(obj);
  let flag = false;
  let firstname = options.firstName ? options.firstName : "";
  let lastname = options.lastName ? options.lastName : "";
  let username = firstname + " " + lastname;
  // Updating flags only for the services available in config file.
  for(let currKey of key){
    if(id === currKey){
      flag = true;
      break;
    }
  }
  if(flag == false) {
    throw new Error("Service not found in config");
  }
  let data = {
    id: id,
    name: serviceName,
    description: options.description ? options.description : "",
    value: state,
    "last-modified": {
      name: username,
      email: options.email,
      time: Date.now(),
      comment: options.comment ? options.comment : "",
    },
    message: options.message ? options.message : "",
  };

  let params = {
    Bucket: config.app.appsData.bucketName,
    Key: config.app.availabilityService.s3Folder + id + ".json" ,
    Body: JSON.stringify(data),
  };
  let response = {}
  await uploadToS3Bucket(dlsShareds3, params);
  let t = JSON.parse(params.Body);
  if (t.value) response["status"] = "On";
  else response["status"] = "Off";
  response["service_name"] = t.name;
  response["last_updated_by"] = t["last-modified"]["name"];
  response["last_updated"] = t["last-modified"]["time"];

  return response;
}

//  uploads to s3 bucket
function uploadToS3Bucket(s3, params) {
  return new Promise((resolve, reject) => {
    try {
      s3.upload(params, function (err, data) {
        if (err) {
          reject(err);
        } else {
          resolve(data);
        }
      });
    } catch (err) {
      reject(err);
    }
  });
}

// fetches from s3 bucket
function getS3Object(s3, params) {
  return new Promise((resolve, reject) => {
    try {
      s3.getObject(params, function (err, data) {
        if (err) {
          reject(err);
        } else {
          resolve(data);
        }
      });
    } catch (err) {
      reject(err);
    }
  });
}