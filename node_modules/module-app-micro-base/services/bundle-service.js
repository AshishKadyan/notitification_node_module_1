/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/


/**********************************************************************
 * Provides functions for getting class related data
 ***********************************************************************/
'use strict';
/************************************
* Internal npm Modules
************************************/
const config = require('./../../../server/config');
/************************************
 * External npm Modules
 ************************************/
let q = require('q');
const requestModule = require('request');

// Load the SDK and UUID
let AWS = require('aws-sdk');

// ************************************
// * Module exports  Public functions
// ************************************
exports.getBundleById = getBundleById;

exports.getBundles = getBundles;
exports.createBundle = createBundle;
exports.updateBundle = updateBundle;
exports.deleteBundle = deleteBundle;

/************************************
* Private variables
************************************/
const bundleTabelName = `Realm_${config.app.dlsRealm}.${config.app.dlsEnv}_peas_bundles`;

/************************************
* Public function definitions
************************************/


function getBundleById(bundleId, formOptions) {

    var deferred = q.defer();
    var docClient = _getDocumentClient();
    var qParams = {
        TableName: bundleTabelName,
        KeyConditionExpression: "bundle_id = :bId",
        ExpressionAttributeValues:{
            ":bId": bundleId
        }
    };

    docClient.query(qParams, function(err, data) {
        if (err) {
            deferred.reject(_createErrorResponse("910", err, "getBundleById"));
        } else {
            if(data.Items && data.Items.length>0){
                deferred.resolve({"status": "success","data": _transformDBRecordsToBundle(data.Items)[0]});
            }else {
                deferred.reject(_createErrorResponse("910", "No bundle with the bundle id "+bundleId+" found.", "getBundleById"));
            }
        }
    });

    return deferred.promise;
}

function getBundles(formOptions, options) {
    var deferred = q.defer();
    
    var docClient = _getDocumentClient();

    var params = {
        TableName: bundleTabelName
    };

    _scanTable(docClient, params)
    .then(function(data){       
        deferred.resolve({"status": "success","data": _transformDBRecordsToBundle(data.Items)});
    }).catch(function(error){
        deferred.reject({"status": "error","data": error});
    });

    return deferred.promise;
}

function _scanTable(docClient, params) {
    var deferred = q.defer();

    docClient.scan(params, function (err, data) {
        if (err) {
            deferred.reject(err);
        } else {
            if(data.LastEvaluatedKey) {
                params.ExclusiveStartKey = data.LastEvaluatedKey;
                _scanTable(docClient, params)
                .then(function(response){
                    data.Items = data.Items.concat(response.Items);
                    deferred.resolve(data);
                })
                .catch(function(error){
                    deferred.reject(error);
                });
            } else {
                deferred.resolve(data);
            }
        }
    });
    
    return deferred.promise;
}

function createBundle(formOptions, options){
    let deferred = q.defer();
    let promiseArr = [];

    let docClient = _getDocumentClient();

    let bundle = formOptions.bundle;
    let bundleItems = _transformBundleToDBRecords(bundle, options.user.id);

    let bundleMetaItem;
    let bundleMetaIdx;

    let dbItems = bundleItems.map((item, idx) => {
        let time = (new Date()).getTime();
        item.created = item.modified = time;

        if(item.bundle_info == "meta"){
            bundleMetaItem = item;
            bundleMetaIdx = idx;
        }

        return item;
    })

    dbItems.splice(bundleMetaIdx, 1);

    let params = {
        TableName:bundleTabelName,
        Item:bundleMetaItem,
        Expected: {
            "bundle_id": {
                Exists: false
            }
        }
    };
    
    // inserting DB records for Bundle Meta
    docClient.put(params, function(err, data) {
        if (err) {
            deferred.reject({ "status": "error", "data": err });
        } else {

            // inserting DB records for Bundle Products
            for(let i=0; i<dbItems.length; i++){
                let params = {
                    TableName:bundleTabelName,
                    Item: dbItems[i]
                };
                
                let deferredProdRec = q.defer();
                docClient.put(params, function(err, data) {
                    if (err) {
                        deferredProdRec.reject(err);
                    } else {
                        deferredProdRec.resolve(data);
                    }
                });
                promiseArr.push(deferredProdRec.promise);
            }

            q.all(promiseArr).then(function(response) {
                deferred.resolve({ "status" : "success", "data" : { bundle: bundle } });
            }).catch(err => {
                deferred.reject({ "status" : "error", "data" : err });
            });
        }
    });

    return deferred.promise;
}

function updateBundle(formOptions, options){
    
    let deferred = q.defer();
    let promiseArr = [];

    let docClient = _getDocumentClient();

    let bundle = formOptions.bundle;
    let userId = options.user.id;

    // transformed state of the bundle to be updated 
    let updatedBundle = _transformBundleToDBRecords(bundle, userId);

    let newBundleItems = {};
    updatedBundle.forEach((item, idx) => {
        newBundleItems[item.bundle_info] = idx;
    });

    let itemsToBeDeleted = [];

    var qParams = {
        TableName: bundleTabelName,
        KeyConditionExpression: "bundle_id = :bId",
        ExpressionAttributeValues:{
            ":bId": bundle.id
        }
    };

    docClient.query(qParams, function(err, data) {
        if (err) {
            deferred.reject({"status": "error","data": err});
        } else {
            // update bundle meta details 
            // and those existing products which are present in the updated bundle also.
            promiseArr = updateItems(data.Items, newBundleItems, updatedBundle, itemsToBeDeleted, docClient);
            q.all(promiseArr).then(function(response) {
                deferred.resolve({ "status" : "success", "data" : response });
            }).catch(err => {
                deferred.reject({ "status" : "error", "data" : err });
            });
        }
    });

    function updateItems(existingDBItems, newBundleItems, updatedBundle, itemsToBeDeleted, docClient) {
        let resPromiseArr = [];
        let currItems = existingDBItems;
        let currItemsCnt = currItems.length;
        for (let idx = 0; idx < currItemsCnt; idx++) {
            let item = currItems[idx];

            // item index in the updated bundle
            let itemIdx = newBundleItems[item.bundle_info];

            if (itemIdx >= 0) {

                // bundle / product to be updated
                let bundle = updatedBundle[itemIdx];

                // product needs to be updated
                var params = {
                    TableName: bundleTabelName,
                    Key: {
                        bundle_id: item.bundle_id,
                        bundle_info: item.bundle_info
                    },
                    UpdateExpression: "set #bmodified = :m",
                    ExpressionAttributeNames: {
                        "#bmodified": "modified"
                    },
                    ExpressionAttributeValues: {
                        ":m": (new Date()).getTime()
                    },
                    ReturnValues: "UPDATED_NEW"
                };

                // if it's a product, update the modified field only
                if (item.bundle_info == "meta") {
                    
                    let itemData = bundle.data;
                    
                    params.UpdateExpression += ", #bname = :n, #d.umbrella_product_name = :upn, #t = :at";
                    
                    params.ExpressionAttributeNames["#d"] = "data";
                    params.ExpressionAttributeNames["#bname"] = "name";
                    params.ExpressionAttributeNames["#t"] = "access_type";
                    
                    params.ExpressionAttributeValues[":n"] = bundle.name;
                    params.ExpressionAttributeValues[":upn"] = itemData.umbrella_product_name;
                    params.ExpressionAttributeValues[":at"] = bundle.access_type;

                    if(itemData.release_date){
                        params.UpdateExpression += ", #d.release_date = :rd";
                        params.ExpressionAttributeValues[":rd"] = itemData.release_date;
                    }
                }

                let deferred = q.defer();
                docClient.update(params, function (err, data) {
                    if (err) {
                        deferred.reject(err);
                    } else {
                        deferred.resolve(data);
                    }
                });

                // remove the bundle_info from the newBundleItems
                // this operation will leave only new items to be added
                delete newBundleItems[item.bundle_info];

                resPromiseArr.push(deferred.promise);
            } else {
                // product no more present in the bundle and thus needs to be deleted
                itemsToBeDeleted.push(item);
            }
        }

        // batch write the remaining items
        // add the items remaining in newBundleItems
        let itemsToAdd = updatedBundle.filter(item => (newBundleItems[item.bundle_info] >= 0));
        // AND delete the items preset in deleteItems
        if((itemsToAdd && itemsToAdd.length>0) || (itemsToBeDeleted.length>0)){
            resPromiseArr.push( batchWriteItems(itemsToAdd, itemsToBeDeleted, docClient) );
        }
        return resPromiseArr;
    }

    function batchWriteItems(addItems, deleteItems, docClient){
        
        // add the items present in addItems
        let itemsToAdd = addItems.map( item => {
            let time = (new Date()).getTime();
            item.created = time;
            item.modified = time;
            return {
                PutRequest: {
                    Item: item
                }
            };
        })

        // delete the items preset in deleteItems
        let itemsToDel = deleteItems.map( item => {
            return {
                DeleteRequest: {
                    Key:{
                        bundle_id: item.bundle_id,
                        bundle_info: item.bundle_info
                    }
                }
            };
        })

        let items = [...itemsToAdd, ...itemsToDel];
        var params = {
            RequestItems: {
                [bundleTabelName]: items
            }
        };

        let deferred = q.defer();
        docClient.batchWrite(params, function(err, data) {
            if (err) {
                deferred.reject({"status": "error","data": err});
            } else {
                deferred.resolve({"status": "success","data": data});
            }
        });
        return deferred.promise;
    }

    return deferred.promise;
}

function deleteBundle(deleteOptions){
    var deferred = q.defer();

    let docClient = _getDocumentClient();

    let bundle = deleteOptions.bundle;
    let products = bundle.products.map( product => {
        return {
            DeleteRequest: {
                Key:{
                    bundle_id: bundle.id,
                    bundle_info: product.id
                }
            }
        };
    })

    var params = {
        RequestItems: {
            [bundleTabelName]: [
                {
                    DeleteRequest: {
                        Key:{
                            bundle_id: bundle.id,
                            bundle_info: "meta"
                        }
                    }
                },
                ...products
            ]
        }
    };

    docClient.batchWrite(params, function(err, data) {
        if (err) {
            deferred.reject({"status": "error","data": err});
        } else {
            deferred.resolve({"status": "success","data": data});
        }
    });

    return deferred.promise;

}

/************************************
* Private function/variable definitions
************************************/

/**
 * function to transform db bundle items into support bundle collection data structure
 * @param {*} dbBundle : DynamoDB bundle items
 * return: An array of bundles formed from DB items and 
 *         formatted into Support App understandable structure
 */
function _transformDBRecordsToBundle(dbBundle){

    let bundleCollection = [];

    if(dbBundle && dbBundle.length){
        let bundleMap = {};
        let bundleLength = dbBundle.length;
        for (let idx = 0; idx < bundleLength; idx++) {
            let item = dbBundle[idx]

            let bundle;
            if (bundleMap[item.bundle_id]) {
                bundle = bundleMap[item.bundle_id];
            } else {
                bundle = bundleMap[item.bundle_id] = {
                    products: []
                };
                bundleCollection.push(bundle);
            }

            if (item.bundle_info == 'meta') {
                bundle.id = item.bundle_id;
                bundle.name = item.name;
                bundle.type = item.access_type;
                bundle.created_by = item.created_by;
                bundle.modified = item.modified;
                bundle.version = item.version;
                if(item.data){
                    bundle.umbrella_product_name = item.data.umbrella_product_name;
                    bundle.release_date = item.data.release_date;
                }
            } else {
                bundle.products.push({
                    id: item.product_id,
                    created_by: item.created_by,
                    version: item.version
                });
            }
        }
    }
    
    return bundleCollection;
}

/**
 * 
 * fn to transafor the support bundle data structure to DB DS
 * @param {*} bundle : bundle received from Support App
 * return: An array of DB items
 */
function _transformBundleToDBRecords(bundle, userId){

    // let userId = "123";
    let initialVersion = 1;

    let bundleCollection = [
        {
            bundle_id: bundle.id,
            bundle_info: "meta",
            access_type: bundle.type,
            name: bundle.name,
            created_by: bundle.created_by || userId,
            version: bundle.version || initialVersion,
            data: {
                umbrella_product_name: bundle.umbrella_product_name,
                release_date: bundle.release_date
            }
        }
    ];
    
    let products = bundle.products;
    let productCnt = products.length;
    for(let idx = 0; idx < productCnt; idx++){
        let product = products[idx];
        bundleCollection.push(
            {
                bundle_id: bundle.id,
                bundle_info: product.id,
                product_id: product.id,
                created_by: userId,
                version: product.version || initialVersion
            }
        )
    }
    return bundleCollection;
}

function _getDocumentClient(){
    return new AWS.DynamoDB.DocumentClient({
        apiVersion: '2012-08-10',
        region: process.env.DYNAMODB_PEAS_REGION,
        sslEnabled: true,
        convertEmptyValues: true
    });
}

function _createErrorResponse(code, error, functionName) {
    var errorObject = {
        "status" : "error",
        "error" : {
            "code" : code,
            "message": error,
            "info" : {
                "fn-name" : functionName    
            }
        }
    };

    return errorObject;    
}