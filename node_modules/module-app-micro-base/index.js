/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

/***********************************************************
 * This module configures express app.
 ************************************************************/

'use strict';

exports.config = require('./config/base');
const appConfig = require('./../../server/config');

/************************** 
 * New Relic APM Handling 
 **************************/
if (appConfig.app.newRelic.enable) {
	// NEW_RELIC_APP_NAME format (c1-[appEnv])
	process.env.NEW_RELIC_APP_NAME = `${appConfig.app.newRelic.appNamePrefix}${appConfig.app.appEnv}`;

	require('newrelic');
}
/************************************
 * External npm Modules
 ************************************/
const express = require('express');
const frameguard = require('frameguard');
const morgan = require('morgan');
const bodyParser = require('body-parser');
const session = require('express-session');
const redisStore = require('connect-redis')(session);
const compression = require('compression');
const passport = require('passport');
const path = require('path');
const helmet = require('helmet');
const cookieParser = require('cookie-parser');
// NEMO-1480:Added this library for protection against Cross Site Request Forgery
const csrf = require('csurf');

/************************************
* Module exports / Public functions
************************************/
exports.initializeExpressApp = initializeExpressApp;
exports.serveStaticAssets = serveStaticAssets;
exports.logger = require('./libs/logging');
const redisConnectionHandler = exports.redisConnectionHandler = require('./libs/redis-connection');
const errorHandler = exports.errorHandler = require('./error/error-handler');
exports.sessionUtils = require('./libs/session-utils');
exports.appConstants = require('./libs/app-constants');
exports.appUtils = require('./libs/app-utils');
const {ltiToolGwAPIUtils} = require('./libs/lti-tool-gateway-api-utils');
exports.ltiToolGwAPIUtils = ltiToolGwAPIUtils;
const appGlobals = exports.appGlobals = require('./libs/app-globals');
const reqUtils = exports.reqUtils = require('./libs/request-utils');
exports.ptasController = require('./controllers/ptas-controller');
exports.peasController = require('./controllers/peas-controller');
exports.gigyaController = require('./controllers/gigya-controller');
exports.avoidBadWords = require('./data/avoid-bad-words');
exports.authController = require('./controllers/auth-controller');
exports.bundleController = require('./controllers/bundle-controller');
exports.konakartService = require('./services/konakart-service');
exports.flagsAvailabilityService = require('./services/flags-availability-service');
exports.emailController = require('./controllers/email-controller');
exports.metaDataTagSevice = require('./services/metadata-tags.service');
exports.bundleCountryFilterService = require('./services/bundle-country-filter-service');
exports.userTrackerController = require('./controllers/user-tracker-controller');

/************************************
* Public function definitions
************************************/
function initializeExpressApp(config, options) {

	const redisClient = redisConnectionHandler.getRedisClient();
	// Initiate Express App
	const app = express();
	
	/****************************
	 *  Security Headers
	 ****************************/
	// NEMO-1474, To remove the X-Powered-By header.
	// Refer https://helmetjs.github.io/docs/hide-powered-by/
	app.use(helmet.hidePoweredBy())

	// NEMO-1471, Adding "X-XSS-Protection: 1; mode=block" header for protection against XSS attacks.
	// Above header enables XSS filtering and the browser will prevent rendering of the page if an attack is detected (by browser).
	// Refer https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection
	app.use(helmet.xssFilter())

	// NEMO-1471, Adding "X-Content-Type-Options: nosniff" header for protection against MIME type Sniffing attacks.
	// Refer https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options and https://www.keycdn.com/support/what-is-mime-sniffing
	app.use(helmet.noSniff())

	// NEMO-1471, Adding "Strict-Transport-Security: maxage=31536000; includeSubDomains;preload" header
	// This allows the site to be loaded only via HTTPS (not HTTP) 
	// Refer https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security#Preloading_Strict_Transport_Security and https://www.chromium.org/hsts
	//
	// TODO - We are still not sure if we need to add 'preload' attribute. 'preload' attribute is generally added when a doamin is registered 
	// with Google HSTS List. Refer https://www.chromium.org/hsts and https://hstspreload.org/. For now, we have added this as 
	// this was suggested in CUP Pen Testing results and it does not have any other implications.
	app.use(helmet.hsts({
		maxAge: 31536000,
		preload: true
	}))


	
	/****************************
	 *  End Security Headers
	 ****************************/
	
	/*******
		* Enabling the "trust proxy" setting , express will have knowledge
		* that it's sitting behind a proxy and that the X-Forwarded-* header
		* fields may be trusted
	*/
	app.set('trust proxy', true);

	app.use(frameguard({ action: 'sameorigin' }));

	// Use Morgan request logger for AWS ECS
	if (config.app.orchestration === 'ECS') {
		app.use(morgan(':remote-addr - :remote-user [:date[clf]] ":method :url HTTP/:http-version" "httpcode"::status :res[content-length] :req[X-Amzn-Trace-Id]'))
	}

	// Support JSON-encoded bodies
	app.use(bodyParser.json({
		limit: '5mb'
	}));

	// handle bodyparser parsing errors
	app.use(bodyParserErrorHandler);

	// Support URL-encoded bodies
	app.use(bodyParser.urlencoded({
		limit: '5mb',
		extended: true
	}));

	// Cookie parser added for csrf library (NEMO-1480)
	app.use(cookieParser())

	const cookieConfig = {...(config.app.session.cookieConfig || {})};

	// Change cookie domain if app environment is not local 
	if (config.app.appEnv != 'local') {
		cookieConfig.secure = true;

		if (config.app.isMobileGateway) {
			cookieConfig.sameSite = "none";
		}else{
			cookieConfig.sameSite = true;
			cookieConfig.httpOnly = true;
			// Change cookie domain if app environment is not local 
			cookieConfig.domain = config.app.session.cookieDomain;
		}
	}

	console.log("cookieConfig: ", cookieConfig);

	app.use(session(
		{
			secret: config.app.session.cookieSecret,
			store: new redisStore({ client: redisClient, ttl: config.app.session.ttl }),
			saveUninitialized: false,
			resave: false,
			name: config.app.session.cookiePrefix + 'sid',
			cookie: cookieConfig,
			// Express Session Rolling - https://github.com/expressjs/session#rolling
			// NEMO-9521 re-setting rolling flag if so is required by an app
			rolling: ((config.app.session.rolling == false) ? false : true)
		}
	));

		// NEMO-1471, Adding "Content-Security-Policy: frameancestors 'none'" header
	// This prevents the site to be loaded inside iframes (of any domain)
	// Refer https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors
	// For LTI launches this security is bypassed to support embedded mode
	app.use(async (req, res, next) => {
		let frameAncestorsString = "'self'";
		if (req.query.ltik && req.query.resource) {
			let ltikInfoRes = await ltiToolGwAPIUtils.signedRequest('GET', `info?ltik=${req.query.ltik}`, { traceid: req.headers['x-amzn-trace-id'] }, null);
			let ltikData = JSON.parse(ltikInfoRes);
			if (ltikData && ltikData.c1MappingDetails && ltikData.c1MappingDetails.deploymentURL) {
				req.session.deploymentURL = ltikData.c1MappingDetails.deploymentURL;
				frameAncestorsString = req.session.deploymentURL;
				cookieConfig.sameSite = 'none';
			}
		}
		else if (req.session && req.session.launchType == 'lti' && req.session.deploymentURL) {
			frameAncestorsString = req.session.deploymentURL;
			cookieConfig.sameSite = 'none';
		} else {
			cookieConfig.sameSite = config.app.isMobileGateway || req.originalUrl.indexOf('/lti/') > -1 ? "none" : true;
		}
		req.session.cookie.sameSite = cookieConfig.sameSite;
		helmet.contentSecurityPolicy({
			directives: {
				frameAncestors: [frameAncestorsString]
			}
		})(req, res, next);
	})
	if (options.launchType != 'nativeApp') {
		//NEMO-1480, Adding csrf cookie and csrf token for protection against cross site request forgery
		var csrfProtection = csrf({
			cookie: {
				key: "csrf_cookie",
				secure: cookieConfig.secure,
				sameSite: cookieConfig.sameSite,
				httpOnly: cookieConfig.httpOnly
			}
		})

		app.use((req, res, next) => {
			if (req.query.ltik && req.query.resource ) {
				csrfProtection = csrf({
					cookie: {
						key: "csrf_cookie",
						secure: cookieConfig.secure,
						sameSite: cookieConfig.sameSite,
						httpOnly: cookieConfig.httpOnly
					}
				})
			}
			next();
		})

		//Adding in a check so as to expemt the payment endpoint from the csrf check since the endpoint will be invoked by Konakart (for use in IELTS)
		app.use(function (req, res, next) {
			if (isCSRFExemptedUrl(req.url, config.app.exemptCSRFendpointList))
			{
				return next();
			}
			else
			{
				csrfProtection(req, res, next)
			}
		})

		app.use(["/"], (req, res, next) => {
			if (isCSRFExemptedUrl(req.url, config.app.exemptCSRFendpointList))
			{
				return next();
			}
			else
			{
				res.cookie('csrf-token', req.csrfToken(), { sameSite: cookieConfig.sameSite, secure: cookieConfig.secure })
				return next();
			}
		})
	}



	//Initialize passport
	app.use(passport.initialize());
	app.use(passport.session());

	passport.serializeUser(function (user, done) {
		if (user)
			done(null, user);
	});
	passport.deserializeUser(function (userObj, done) {
		done(null, userObj);
	});

	// Status for health check by AWS ECS
	// IMPORTANT !!!! Keep This before HTTPS redirect as this route is called over HTTP by AWS Health Check
	app.get('/status', function (req, res) {
		sendAppInitialisedMessage(req, res);
	});

	//Redirect to https if configured
	app.use(function (req, res, next) {
		if (config.app.redirectToHttps && !reqUtils.isHttps(req)) {
			res.redirect('https://' + req.headers.host + req.url);
		} else {
			next();
		}
	});

	//Removing the path prefix (e.g. /onboarding/, /dashboard/) in AWS 
	app.use(function (req, res, next) {
		if (process.env.ORCHESTRATION === 'ECS' && req.url.indexOf(options.appBaseUrl) === 0) {
			//Split the route using '/'		
			var pathsArr = req.url.split('/');

			//Remove elements (/onboarding/) from pathsArr.		
			pathsArr.splice(1, (options.appBaseUrl.split('/').length - 2));

			// join the array using '/'	
			req.url = pathsArr.join('/');

			if (req.url === '') { // in case of req.url = '/onboarding/'
				req.url = '/';
			}
		}
		next();
	});
	
	// NEMO-1477
	// To disable client-side caching of backend apigateway calls
	// Refer https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching
	app.use('/apigateway', helmet.noCache())


	return app;
};

function serveStaticAssets(app, config, options) {
	/**
	 * Production Checks
	 * 1. Enable GZIP Compression for static assets(JS/CSS etc.)
	 * 2. Set cache headers for static assets(JS/CSS files) to tell browsers to cache files.
	 * These will not be needed when we start using CDN for serving static assets.
	 */
	let staticContentOptions;
	if (options.buildMode == "production") {
		app.use(compression());

		//Skip browser caching for html files
		const skipBrowserCaching = function (res, path) {
			var pathArray = path.split(".");
			var extension = pathArray[pathArray.length - 1];
			if (["html"].indexOf(extension) != -1) {
				res.setHeader('Cache-Control', 'public, max-age=0');
			} else if (path.indexOf('notifications-component') != -1) {
				res.setHeader('Cache-Control', 'public, no-store, max-age=0');
			}
		}

		if (config.app.enableBrowserCache) {
			staticContentOptions = {
				maxAge: config.app.browserCacheMaxAge,
				lastModified: false,
				setHeaders: skipBrowserCaching
			};
		}


	}
	if (options.buildMode == "development") {

		if (options.webDevServerOptions) {
			// We require the bundler inside the if block because
			// it is only needed in a development environment.
			var bundle = require('./web-dev-server.js');
			bundle(options.webDevServerOptions);
		}

	} else {
		// Accessing the static assets from the dist in production environment
		app.use(express.static(path.resolve(__dirname, './../../dist'), staticContentOptions));
		app.get('*', function (req, res) {
			const ieltsiPaths = ['/ieltsi', '/ieltsi/', '/ieltsi/home', '/ieltsi/home/'];
			// For handling the case of query params in ielts home url
			const originalUrlArray = req.originalUrl.split('?');
			//Component for notifications app and nativeApp for foc desktop
			if (['component', 'nativeApp'].indexOf(options.launchType) != -1) {
				sendAppInitialisedMessage(req, res);
			} else if (originalUrlArray.length && ieltsiPaths.indexOf(originalUrlArray[0]) != -1) { 
				res.sendFile(path.resolve(__dirname, './../../dist/home.html'));
			} else {
				res.sendFile(path.resolve(__dirname, './../../dist/index.html'));
			}
		});
	}
}

function sendAppInitialisedMessage(req, res) {
	if (appGlobals.appInitialized) {
		res.send({
			appInitialized: true, message: 'App has been intialized successfully.'
		});
	}
	else {
		syslog.info({ req }, 'App has not initialized yet.');
		res.status(503).send({
			appInitialized: false,
			message: 'App has not initialized yet.'
		});
	}
}

function isCSRFExemptedUrl(url, exemptCSRFendpointList)
{
	if (exemptCSRFendpointList != undefined && exemptCSRFendpointList.find(exemptUrl => exemptUrl == url) != undefined)
	{
		return true;
	}
	else
	{
		return false;
	}
}

// https://jira.cambridge.org/browse/NEMO-5096
// Fix for https://owasp.org/www-community/attacks/Full_Path_Disclosure
function bodyParserErrorHandler(err, req, res, next) {
	if (err.type === "entity.parse.failed") {
		errorHandler.handleError(req, res, err, { tag: 'PARSING_ERROR', isFurtherComputationsNeeded: true, errorInfo: err.message });
		res.status(err.statusCode || 400).json('Invalid JSON');
	} else {
		next(err);
	}
}
