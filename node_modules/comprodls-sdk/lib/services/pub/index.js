/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/
/***********************************************************
 * comproDLS SDK Pub Adaptor
 * Functions for calling Pub.
 ************************************************************/

var request = require('superagent');
var q = require('q');

var helpers = require('../../helpers');
var DLSError = helpers.errors.DLSError;

/*********************************
 * Setting Up Module Entry Point
 **********************************/
module.exports = pub;

function pub() {
  return {
    "promoteProduct": promoteProduct.bind(this),
    "registerProduct": registerProduct.bind(this),
    "ingestProduct": ingestProduct.bind(this),
    "createBundle": createBundle.bind(this),
    "updateBundle": updateBundle.bind(this),
    "getAllBundles": getAllBundles.bind(this),
    "getSingleBundle": getSingleBundle.bind(this),
    "createProductFamily": createProductFamily.bind(this),
    "updateProductFamily": updateProductFamily.bind(this),
    "getSingleProductFamily": getSingleProductFamily.bind(this),
    "getAllProductFamilies": getAllProductFamilies.bind(this)
  };
}

/*********************************
 * Public Function definitions
 **********************************/

/**
 * {
    "source": {
      "stage": "1" //["1", "2"]
    },
    "target": {
      "org": <target_org> //optional, mandatory for sourceStage-1 + targetStage-2
      "stage": "2" //["2", "final"]
    },
    "externalrefid": <externalID>,
    "productcode": "string"
    }
 */
function promoteProduct(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();

  //Construct API url
  var url = self.config.DEFAULT_HOSTS['PUB'] + self.config.PUB_API_URLS.promoteAPI;
  url = helpers.api.constructAPIUrl(url, {
    "orgId": self.orgId, "productcode": options.productcode
  });
  //Contruct parameters
  var params = {
    source: {},
    target: {}
  };
  if (options) {
    if (options.source && options.source.stage) {
      params.source.stage = options.source.stage;
    }
    if (options.target) {
      if(options.target.org) {
        params.target.org = options.target.org;
      }
      if(options.target.stage) {
        params.target.stage = options.target.stage;
      }
    }
    if(options.externalrefid) {
      params.externalrefid = options.externalrefid;
    }
  }

  //Setup request with URL and Post data
  var requestAPI = request.post(url).send(params);

  if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
  requestAPI.end(function (err, response) {
    if (err) {
      err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
      dfd.reject(err);
    } else {
      dfd.resolve(response);
    }
  });
  return dfd.promise;
}

//options = {
//    targetorg: 'dev',
//    repositorytype: 'github', //mandatory
//    productcode: 'Product code', //mandatory
//    title: 'Product title', //mandatory
//    producttype: 'Product type',  //mandatory e.g., etextbook, imgbook, courseware.
//    bundle-codes: ['bundle-code of the bundle']  //optional: Product register request, related to a Bundle, currently only one buldle-code in Array
//    externalrefid: <externalID>
//
// /* Note: Register via github is no more supported from v2.5. */
//    github: {
//        repository: 'Github repository',
//        token: 'Github Auth token'
//    }
//}
function registerProduct(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();

  //Construct API url
  var url = self.config.DEFAULT_HOSTS['PUB'] + self.config.PUB_API_URLS.registerProductAPI;
  url = helpers.api.constructAPIUrl(url, { "orgId" : self.orgId });
  
  //Contruct parameters
  var params = {};
  if(options) {
    if(options.targetorg) {
      params.targetorgid = options.targetorg;
    }
    if(options.repositorytype) {
      params.repositorytype = options.repositorytype;
    }
    if(options.producttitle) {
      params.producttitle = options.producttitle;
    }
    if(options.producttype) {
      params.producttype = options.producttype;
    }
    if(options.productcode) {
      params.productcode = options.productcode;
    }
    if(options.github) {
      params.github = options.github;
    }
    if(options.s3) {
      params.s3 = options.s3;
    }
    if(options.externalrefid) {
      params.externalrefid = options.externalrefid;
    }
    if(options['bundle-codes']) {
      params['bundle-codes'] = options['bundle-codes'];
    }
  }

  //Setup request with URL and Post data
  var requestAPI = request.post(url).send(params);

  if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
  requestAPI.end(function(err, response) {
    if (err) {
      err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
      dfd.reject(err);
    } else { 
      dfd.resolve(response);
    }
  });
  return dfd.promise;
}

//options = {
//    productcode: "string",
//    branchref: 'Github branch name or s3 folder path', //mandatory, ingestion via Github no more supported from v2.5.
//    "externalrefid": <externalID>,
//    "bundle-codes": ['bundle-code of the bundle'] //optional: Product register request, related to a Bundle
//}
function ingestProduct(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();

  var productCode;
  if(options && options.productcode) {
    productCode = options.productcode;
  }

  //Construct API url
  var url = self.config.DEFAULT_HOSTS['PUB'] + self.config.PUB_API_URLS.ingestByCodeAPI;
  url = helpers.api.constructAPIUrl(url, {
    "orgId" : self.orgId,
    "productcode" : productCode
  });
  //Contruct parameters
  var params = {};
  if(options) {
    if(options.branchref) {
      params.branchref = options.branchref;
    }
    if(options.externalrefid) {
      params.externalrefid = options.externalrefid;
    }
    if(options['bundle-codes']) {
      params['bundle-codes'] = options['bundle-codes'];
    }
  }

  //Setup request with URL and Post data
  var requestAPI = request.post(url).send(params);

  if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
  requestAPI.end(function(err, response) {
    if (err) {
      err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
      dfd.reject(err);
    } else {
      dfd.resolve(response);
    }
  });
  return dfd.promise;
}

// options = {
// 	stage: "",		      //stage number or version
// 	"bundle-code": "",	//bundle identifier
// 	body: {
// 		title: "",		    //bundle title
// 		products: []	    //products array of objects containing following keys:
                        //mandatory fields:  ext-product, dls-product, meta, activation, analytics, classes,
                        //optional fields: groups, segment, results-display, assignability, learning-path, activity
// 	}
// }
function createBundle(options) {
  var self = this;
  //Initializing promise
  var dfd = q.defer();
  var err;
  //Validations
  if(options && options.stage && options['bundle-code'] && options.body && options.body.title &&
      options.body.products)
  {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS['PUB'] + self.config.PUB_API_URLS.createBundle;
    url = helpers.api.constructAPIUrl(url, { orgid: self.orgId, stage: options.stage });

    //Contruct parameters
    options.body['bundle-code'] = options['bundle-code'];
    //Setup request with URL and Post data
    var requestAPI = request.post(url).send(options.body);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if(err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      } else {
        dfd.resolve(response.body);
      }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Required parameter stage or bundle-code or title or ' +
                                      'products not found in request options';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

// options = {
// 	stage: "",					//stage number or version
// 	"bundle-code": "",	//bundle identifier
// 	body: {
// 		title: "",				//bundle title (optional)
// 		products: []			//products array of objects containing following keys:
                        //mandatory fields:  ext-product, dls-product, meta, activation, analytics, classes,
                        //optional fields: groups, segment, results-display, assignability, learning-path, activity
// 	}
// }
function updateBundle(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();
  var err;

  //Validations
    if(options && options.stage && options['bundle-code'] && options.body && options.body.products) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS['PUB'] + self.config.PUB_API_URLS.updateBundle;
    url = helpers.api.constructAPIUrl(url, {
      orgid: self.orgId, stage: options.stage, bundleCode: options['bundle-code']
    });

    //Setup request with URL and Post data
    var requestAPI = request.put(url).send(options.body);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
    requestAPI.end(function (err, response) {
      if(err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      } else {
        dfd.resolve(response.body);
      }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Required parameter stage or bundle-code or ' +
                                      'products not found in request options';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

// options= {
//  stage: "",          //stage number or version
// }

function getAllBundles(options) {
  var self = this;
  //Initializing promise
  var dfd = q.defer();

  //Construct API url
  var url = self.config.DEFAULT_HOSTS['PUB'] + self.config.PUB_API_URLS.getAllBundles;

  url = helpers.api.constructAPIUrl(url, { orgid: self.orgId, });
  //Contruct parameters
  var params = {};
  if(options && options.stage) { params.stage = options.stage; }

  //Setup request with URL and Post data
  var requestAPI = request.get(url).query(params);

  if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
  requestAPI.end(function (err, response) {
    if(err) {
      err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
      dfd.reject(err);
    } else {
      dfd.resolve(response.body);
    }
  });
  return dfd.promise;
}

// options = {
//   'bundle-code': "",   //bundle identifier
//   stage: "",           //stage number/version
// }
function getSingleBundle(options) {
  var self = this;
  var dfd = q.defer();

  //Validations
  var err;
  if(options && options['bundle-code']) {

    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS['PUB'] + self.config.PUB_API_URLS.getSingleBundle;

    url = helpers.api.constructAPIUrl(url, { orgid: self.orgId, bundleCode: options['bundle-code'] });
    //Contruct parameters
    var params = {};
    if(options && options.stage) { params.stage = options.stage; }
    //Setup request with URL and Post data

    var requestAPI = request.get(url).query(params);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
    requestAPI.end(function (err, response) {
      if(err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      } else {
        dfd.resolve(response.body);
      }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Required parameter bundle-code not found in request options';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

// options = {
//   "stage": <>,                 // Mandatory
//   "body": {
//     "family-code": "string",   // Mandatory
//     "ext_user_id": "string",   // Optional
//     "assets": {                // Optional
//       "branchref": "string",   // Optional
//       "bucket": "string"       // Optional
//       "source": {              // Optional
//         "branchref": "string", // Mandatory
//         "bucket": "string"     // Mandatory
//       }
//     },
//     "externalrefid": "string", // Optional
//     "data": {... }             // Optional
//   }
// }
function createProductFamily(options) {
  var self = this;
  //Initializing promise
  var dfd = q.defer();
  var err;
  //Validations
  if (options && options.stage && options.body && options.body['family-code'])
  {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS['PUB'] + self.config.PUB_API_URLS.createProductFamily;
    url = helpers.api.constructAPIUrl(url, { orgid: self.orgId, stage: options.stage });

    //Setup request with URL and Post data
    var requestAPI = request.post(url).send(options.body);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if(err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      } else {
        dfd.resolve(response.body);
      }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Required parameter stage or family-code ' +
                                    'not found in request options';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

// options = {
//   "stage": <>,                 // Mandatory
//   "family-code": <>,           // Mandatory
//   "body": {
//     "ext_user_id": "string",   // Optional
//     "assets": {                // Optional
//       "branchref": "string",   // Optional
//       "bucket": "string"       // Optional
//       "source": {              // Optional
//         "branchref": "string", // Mandatory
//         "bucket": "string"     // Mandatory
//       }
//     },
//     "externalrefid": "string", // Optional
//     "data": {... }             // Optional
//   }
// }
function updateProductFamily(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();
  var err;

  //Validations
    if (options && options.stage && options['family-code']) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS['PUB'] + self.config.PUB_API_URLS.updateProductFamily;
    url = helpers.api.constructAPIUrl(url, {
      orgid: self.orgId, stage: options.stage, familyCode: options['family-code']
    });

    //Setup request with URL and Post data
    var requestAPI = request.put(url).send(options.body);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
    requestAPI.end(function (err, response) {
      if(err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      } else {
        dfd.resolve(response.body);
      }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Required parameter stage or family-code ' +
                                    'not found in request options';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/**
 * options = {
 *   "family-code": "",   //product family identifier, Mandatory
 *   "stage"      : "",   //stage number
 * }
 */
function getSingleProductFamily(options) {
  var self = this;
  var dfd = q.defer();

  //Validations
  var err;
  if(options && options['family-code']) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS['PUB'] + self.config.PUB_API_URLS.getSingleProductFamily;
    url = helpers.api.constructAPIUrl(url, {
      orgid: self.orgId, familyCode: options['family-code']
    });

    //Contruct parameters
    var params = {};
    if(options.stage) { params.stage = options.stage; }

    //Setup request with URL and Post data
    var requestAPI = request.get(url).query(params);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if(err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      } else {
        dfd.resolve(response.body);
      }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Required parameter family-code not found in request options';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/**
 * options = {
 *   "stage": <>,   // Optional
 *  }
 */
function getAllProductFamilies(options) {
  var self = this;
  //Initializing promise
  var dfd = q.defer();

  //Construct API url
  var url = self.config.DEFAULT_HOSTS['PUB'] + self.config.PUB_API_URLS.getAllProductFamilies;

  url = helpers.api.constructAPIUrl(url, { orgid: self.orgId, });
  //Contruct parameters
  var params = {};
  if(options && options.stage) { params.stage = options.stage; }

  //Setup request with URL and Post data
  var requestAPI = request.get(url).query(params);

  if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
  requestAPI.end(function (err, response) {
    if(err) {
      err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
      dfd.reject(err);
    } else {
      dfd.resolve(response.body);
    }
  });
  return dfd.promise;
}
