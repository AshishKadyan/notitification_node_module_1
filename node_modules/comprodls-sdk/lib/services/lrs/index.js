/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/
/***********************************************************
 * comproDLS SDK Product API Adaptor
 * Functions for calling Product API.
 ************************************************************/
var TinCan = require('tincanjs');
var q = require('q');

var helpers = require('../../helpers');
var DLSError = helpers.errors.DLSError;

/*********************************
 * Setting Up Module Entry Point
 **********************************/
module.exports = lrs;

function lrs() {
    var error = {};
    //Initializing promise
    try {
        this.lrs = new TinCan.LRS({
            endpoint: this.config.DEFAULT_HOSTS.XAPI + '/' + this.orgId + '/tapi',
            auth: this.token.access_token,
            allowFail: false
        });

        this.tincan = new TinCan({
            recordStores: [this.lrs]
        });
    } catch (err) {
        err.description = 'Error while initializing lrs.';
        err.message = err.description;
        error = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
        return err;
    }
    return {
        "getStatement": getStatement.bind(this),
        "createStatement": createStatement.bind(this)
        /*"setState": setState.bind(this),
        "getState": getState.bind(this),
        "deleteState": deleteState.bind(this)*/
    };
}

/*********************************
 * Public Function definitions
 **********************************/

//options = {
//	verb: {object} - (Optional) Verb / Action performed by the acting person.
//  actor: {object} - (Optional) The acting person.
//	since: {String} - (Optional) <ISO-8601> date time,
//	until: {String} - (Optional) <ISO-8601> date time,
//  limit: {Number} - (Optional) limit of documents per function call
//  registration: {String} - (Optional) product to which the actor is entitled.
//  moreUrl: {String} - (Optional) Endpoint to get the next set of statements.
//}
function getStatement(options) {
    var self = this;

    //Initializing promise
    var dfd = q.defer(), params = {}, bMoreUrl = false;
    /*var supportedVerbs = ['attempted', 'scored', 'started', 'launched',
                        'answered', 'closed', 'terminated'];*/
    if(options) {
        params = {
            limit: options.limit || 10,
            since: options.since || null,
            until: options.until || null
        };
        if(options.actor) { params.agent = new TinCan.Agent(options.actor); }
        if(options.verb) { params.verb = new TinCan.Verb(options.verb); }
        if(options.moreUrl) { bMoreUrl = true; }
        if(options.registration) { params.registration = options.registration; }
    }

    if(bMoreUrl) {
        self.lrs.moreStatements({
            url: options.moreUrl,
            callback: function (err, sr) {
                if (err !== null) {
                    var error = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
                    dfd.reject(error);
                } else {
                    var statementsArray = [];
                    for(var i in sr.statements) {
                        statementsArray.push(JSON.parse(sr.statements[i].originalJSON));
                    }
                    sr.statements = statementsArray;
                    dfd.resolve(sr);
                }
            }
        });
    } else {
        self.lrs.queryStatements({
            params: params,
            callback: function (err, sr) {
                if (err !== null) {
                    var error = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
                    dfd.reject(error);
                } else {
                    var statementsArray = [];
                    for(var i in sr.statements) {
                        statementsArray.push(JSON.parse(sr.statements[i].originalJSON));
                    }
                    sr.statements = statementsArray;
                    dfd.resolve(sr);
                }
            }
        });
    }

    return dfd.promise;
}


//options = [{
//	verb: {object} - (Required) Verb / Action performed by the acting person.
//  actor: {object} - (Required) The acting person.
//  object: {object} - (Required) The activity on which the statement is performed. Ref - http://rusticisoftware.github.io/TinCanJS/doc/api/latest/classes/TinCan.Activity.html
//  registration: {String} - (Required) Product the actor is entitled to.
//  timestamp: {ISO8601 Date/time value} - (Optional) Time string
//  result: {TinCAN Result} - http://rusticisoftware.github.io/TinCanJS/doc/api/latest/classes/TinCan.Result.html
//}]
function createStatement(options) {
    var self = this;
    //Initializing promise
    var dfd = q.defer(), error;
    var createStatementObject = {}, createStatementsArray = [];
    if(Array.isArray(options)) {
        for(var i in options) {
            if (!(options[i].actor && options[i].verb && options[i].object &&
                options[i].registration))
            {
                error = {};
                error.message = error.description = 'Mandatory parameter options' +
                    ' not found in request options';
                error = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, error);
            } else {
                createStatementObject = {
                    verb: new TinCan.Verb(options[i].verb), actor: new TinCan.Agent(options[i].actor),
                    object: new TinCan.Activity(options[i].object), context: { registration: options[i].registration }
                };
                if(options[i].timestamp) {
                    createStatementObject.timestamp = options[i].timestamp;
                }
                if(options[i].result) {
                    createStatementObject.result = options[i].result;
                }
                createStatementsArray.push(createStatementObject);
            }
        }
    } else {
        error = {};
        error.message = error.description = 'Mandatory parameter options' +
            ' not found in request options';
        error = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, error);
    }
    if(error) {
        dfd.reject(error);
    } else {
        self.tincan.sendStatements(
            createStatementsArray,
            function (err) {
                for(var i in err) {
                    if(err[i].err !== null) {
                        var errObj = {
                            message: err[i].xhr.statusText,
                            description: JSON.parse(err[i].xhr.response),
                            status: err[i].xhr.status
                        };
                        if(errObj) {
                            error = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, errObj);
                            dfd.reject(error);
                            break;
                        }
                    }
                }

                if (!error) { dfd.resolve(); }
            }
        );
    }

    return dfd.promise;
}


//options = {
//  email: {String} - (Required) Email address of acting person,
//  verb: {String} - (Required) Verb / Action performed by the acting person. Supported verbs are
//                   ['attempted', 'scored', 'started', 'launched', 'answered', 'closed', 'terminated'],
//  itemcode: {String} - (Required) - Item code of the item that the user is acting on.
//  productid: {String} - (Required) - Product to which the acting user is entitled.
//  classid: {String} - (Optional) - Class in which the acting user is enrolled.
//}

/*function createStatement1(options) {
    var self = this;

    //Initializing promise
    var dfd = q.defer(), error;

    if (options && options.email && options.verb && options.itemcode &&
        options.productid) {
        var createStatementObject = {};
        var supportedVerbs = ['attempted', 'scored', 'started', 'launched',
                            'answered', 'closed', 'terminated'];
        for (var field in options) {
            if (options[field]) {
                switch (field) {
                    case 'email':
                        createStatementObject.actor = { mbox: 'mailto:' + options[field] };
                        break;
                    case 'verb':
                        if (supportedVerbs.indexOf(options[field]) > -1) {
                            createStatementObject.verb = {
                                id: 'http://adlnet.gov/expapi/verbs/' + options[field]
                            };
                        } else {
                            error = {};
                            error.message = 'Verb: ' + options[field] + ' is not supported.';
                            error.description = error.message;
                            error = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, error);
                            dfd.reject(error);
                        }
                        break;
                    case 'itemcode':
                        createStatementObject.target = {
                            id: self.config.DEFAULT_HOSTS.PRODUCT + '/product/' +
                                options.productid + '/' + encodeURIComponent(options[field])
                        };
                        break;
                    case 'productid':
                        createStatementObject.context = { productid: options[field] };
                        break;
                }
                if(error) { break; }
            }
        }

        createStatementObject = new TinCan.Statement(createStatementObject);

        if(!error) {
            self.tincan.sendStatements(
                [createStatementObject],
                function (err) {
                    err = err[0];
                    if (err.err !== null) {
                        error = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
				                dfd.reject(error);
                    } else {
                        dfd.resolve();
                    }
                }
            );
        }
    } else {
        error = {};
        error.message = error.description = 'Mandatory parameter options' +
            ' not found in request options';
        error = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, error);
        dfd.reject(error);
    }
    return dfd.promise;
}*/

//options = {
//	verb: {object} - (Optional) Verb / Action performed by the acting person. Supported verbs are
//                   ['attempted', 'scored', 'started', 'launched', 'answered', 'closed', 'terminated'],
//	since: {String} - (Optional) <ISO-8601> date time,
//	until: {String} - (Optional) <ISO-8601> date time,
//  cursor: {String} - (Optional) cursor to next set of documents
//  limit: {String} - (Optional) limit of documents per function call
//}

/*function getStatement1(options) {
    var self = this;

    //Initializing promise
    var dfd = q.defer(), error, params = {};
    var supportedVerbs = ['attempted', 'scored', 'started', 'launched',
                        'answered', 'closed', 'terminated'];
    if(options) {
        params = {
            limit: options.limit || 10,
            since: options.since || null,
            until: options.until || null
        };
        if(options.actor) {

        }
        if(options.verb) {
            params.verb = options.verb;
          if (supportedVerbs.indexOf(options.verb) > -1) {
                params.verb = new TinCan.Verb({
                    id: 'http://adlnet.gov/expapi/verbs/' + options.verb
                });
            } else {
                error= {};
                error.message = 'Verb: ' + options.verb + ' is not supported.';
                error.description = error.message;
                error = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, error);
                dfd.reject(error);
            }
        }
    }

    if(!error) {
        self.lrs.queryStatements({
            params: params,
            callback: function (err, sr) {
                if (err !== null) {
                    error = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
                    dfd.reject(error);
                } else {
                    dfd.resolve(sr);
                }
            }
        });
    }
    return dfd.promise;
}*/


//options = {
//  key: {string} - (Required)
//  email: {String} - (Required) Email address of acting person,
//  itemcode: {String} - (Required) - Item code of the item that the user is acting on.
//  productid: {String} - (Required) - Product to which acting user is entitled.
/*function getState(options) {
    var self = this;

    //Initializing promise
    var dfd = q.defer(), error;

    if (options && options.email && options.verb && options.itemcode &&
        options.productid)
    {
        var agent = new TinCan.Agent({ mbox: 'mailto:' + options.email });
        var activity = new TinCan.Activity({
            id: self.config.DEFAULT_HOSTS.PRODUCT + '/product/' + options.productid +
                '/' + encodeURIComponent(options.itemcode)
        });

        if(!error) {
            self.tincan.getState (options.key, {
                agent: agent,
                activity: activity,
                callback: function (err, sr) {
                    if (err !== null) {
                        error = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
                        dfd.reject(error);
                    } else {
                        dfd.resolve(sr);
                    }
                }
            });
        }
    } else {
        error = {};
        error.message = error.description = 'Mandatory parameter options' +
            ' not found in request options';
        error = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, error);
        dfd.reject(error);
    }

    return dfd.promise;
}*/

//options = {
//  key: {string}
//  email: {String} - (Required) Email address of acting person,
//  itemcode: {String} - (Required) - Item code of the item that the user is acting on.
//  productid: {String} - (Required) - Product to which the acting user is entitled.

/*function setState(options) {
    var self = this;

    //Initializing promise
    var dfd = q.defer(), error;

    if (options && options.email && options.itemcode && options.productid) {
        self.tincan.setState(options.key, options.value, {
            agent: new TinCan.Agent({ mbox: options.email }),
            activity: new TinCan.Agent({
                id: self.config.DEFAULT_HOSTS.PRODUCT + '/product/' +
                    options.productid + '/' +
                    encodeURIComponent(options.itemcode)
            }),
            function (err) {
                err = err[0];
                if (err.err !== null) {
                    error = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
                    dfd.reject(error);
                } else {
                    dfd.resolve();
                }
            }
        });
    } else {
        error.message = error.description = 'Mandatory parameter options,' +
            '  email, itemcode, productidnot found in request options';
        error = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, error);
        dfd.reject(error);
    }
    return dfd.promise;
}*/

//options = {
//  key: {string}
//  email: {String} - (Required) Email address of acting person,
//  itemcode: {String} - (Required) - Item code of the item that the user is acting on.
//}

/*function deleteState (options) {

    var self = this;

    //Initializing promise
    var dfd = q.defer(), error;
    var agent = new TinCan.Agent({ mbox: options.email });
    var activity = new TinCan.Agent({ id: options.itemcode });

    if(!error) {
        self.tincan.deleteState(options.key, {
            agent: agent,
            activity: activity,
            callback: function (err, sr) {
                if (err !== null) {
                    error = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
                    dfd.reject(error);
                } else {
                    dfd.resolve(sr);
                }
            }
        });
    }
    return dfd.promise;
}*/

