/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

/***********************************************************
 * comproDLS SDK attempts Adaptor
 * Functions for calling attempts.
 ************************************************************/

/*********************************
 * Setting Up Module Entry Point
 **********************************/

var q = require('q');
var request = require('superagent');

var helpers = require('../../helpers');
var DLSError = helpers.errors.DLSError;

module.exports = attempts;

/*********************************
 * Public Function definitions
 **********************************/
function attempts() {
  return {
    getUserAllAttemptsForActivity: getUserAllAttemptsForActivity.bind(this),
    createUserAttemptForActivity: createUserAttemptForActivity.bind(this),
    getUserAttemptStatsForActivity: getUserAttemptStatsForActivity.bind(this),
    getUserAttemptForActivity: getUserAttemptForActivity.bind(this),
    getUserFirstAttemptForActivity: getUserFirstAttemptForActivity.bind(this),
    getUserLastAttemptForActivity: getUserLastAttemptForActivity.bind(this)
  };
}

/*
  options = {
  userid: 'string', //mandatory
  activityid: 'string', //mandatory
  allorgs: boolean, //default = false
  classid: 'string',
  assignmentid: 'string',
  productcode: 'string',
  cursor: 'string',
  limit: 'integer',
  sortOrder: 'string' //'asc' or 'desc'
  }
*/
function getUserAllAttemptsForActivity(options) {
  var self = this;
  var dfd = q.defer();
  var err;

  if(options && options.userid && options.activityid) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.ATTEMPTS + self.config.ATTEMPTS_API_URLS.userAttempts;
    url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, userId: options.userid, activityId: options.activityid });

    // Contruct parameters
    var params = {};
    if(options.allorgs) { params.allorgs = options.allorgs; }
    if(options.classid) { params.classid = options.classid; }
    if(options.assignmentid) { params.assignmentid = options.assignmentid; }
    if(options.productcode) { params.productcode = options.productcode; }
    if(options.cursor) { params.cursor = options.cursor; }
    if(options.limit) { params.limit = options.limit; }
    if(options.sortOrder) { params.sortOrder = options.sortOrder; }

    //Setup request with URL and Params
    var requestAPI = request.get(url).query(params);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if (err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Mandatory params - userid or activityid ' +
      'not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/*
  options = {
  userid: 'string', //mandatory
  activityid: 'string', //mandatory
  "body": {
      "classid": "string",
      "assignmentid": "string",
      "itemcode":"string",
      "productcode": "string",
      "max_allowed":"string"
    }
  }
*/
function createUserAttemptForActivity(options) {
  var self = this;
  var dfd = q.defer();
  var err;

  if(options && options.userid && options.activityid && options.body) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.ATTEMPTS + self.config.ATTEMPTS_API_URLS.userAttempts;
    url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, userId: options.userid, activityId: options.activityid });

    //Setup request with URL and Body
    var requestAPI = request.post(url).send(options.body);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if (err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Mandatory params - userid or activityid or body ' +
      'not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/*
  options = {
  userid: 'string', //mandatory
  activityid: 'string', //mandatory
  classid: 'string', //mandatory with assignmentid
  assignmentid: 'string',
  allorgs: boolean // default = false
  }
*/
function getUserAttemptStatsForActivity(options) {
  var self = this;
  var dfd = q.defer();
  var err;

  if(options && options.userid && options.activityid) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.ATTEMPTS + self.config.ATTEMPTS_API_URLS.getUserAttemptStatsForActivity;
    url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, userId: options.userid, activityId: options.activityid });

    // Contruct parameters
    var params = {};
    if(options.allorgs) { params.allorgs = options.allorgs; }
    if(options.classid) { params.classid = options.classid; }
    if(options.assignmentid) { params.assignmentid = options.assignmentid; }

    //Setup request with URL and Params
    var requestAPI = request.get(url).query(params);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if (err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Mandatory params - userid or activityid ' +
      'not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/*
  options = {
  userid: 'string', //mandatory
  activityid: 'string', //mandatory
  attemptid: 'string', //mandatory
  details: boolean
  }
*/
function getUserAttemptForActivity(options) {
  var self = this;
  var dfd = q.defer();
  var err;

  if(options && options.userid && options.activityid && options.attemptid) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.ATTEMPTS + self.config.ATTEMPTS_API_URLS.getUserAttemptForActivity;
    url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, userId: options.userid, activityId: options.activityid,
                                              attemptId: options.attemptid });

    // Contruct parameters
    var params = {};
    if(options.details) { params.details = options.details; }

    //Setup request with URL and Params
    var requestAPI = request.get(url).query(params);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if (err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Mandatory params - userid or activityid or attemptid ' +
      'not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/*
  options = {
  userid: 'string', //mandatory
  activityid: 'string', //mandatory
  classid: 'string' //mandatory with assignmentid
  assignmentid: 'string'
  details: boolean
  }
*/
function getUserFirstAttemptForActivity(options) {
  var self = this;
  var dfd = q.defer();
  var err;

  if(options && options.userid && options.activityid) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.ATTEMPTS + self.config.ATTEMPTS_API_URLS.getUserFirstAttemptForActivity;
    url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, userId: options.userid, activityId: options.activityid });

    // Contruct parameters
    var params = {};
    if(options.details) { params.details = options.details; }
    if(options.classid) { params.classid = options.classid; }
    if(options.assignmentid) { params.assignmentid = options.assignmentid; }

    //Setup request with URL and Params
    var requestAPI = request.get(url).query(params);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if (err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Mandatory params - userid or activityid ' +
      'not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/*
  options = {
  userid: 'string', //mandatory
  activityid: 'string', //mandatory
  classid: 'string'//mandatory with assignmentid
  assignmentid: 'string'
  details: boolean
  }
*/
function getUserLastAttemptForActivity(options) {
  var self = this;
  var dfd = q.defer();
  var err;

  if(options && options.userid && options.activityid) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.ATTEMPTS + self.config.ATTEMPTS_API_URLS.getUserLastAttemptForActivity;
    url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, userId: options.userid, activityId: options.activityid });

    // Contruct parameters
    var params = {};
    if(options.details) { params.details = options.details; }
    if(options.classid) { params.classid = options.classid; }
    if(options.assignmentid) { params.assignmentid = options.assignmentid; }

    //Setup request with URL and Params
    var requestAPI = request.get(url).query(params);
    console.log(url, params, requestAPI);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if (err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Mandatory params - userid or activityid ' +
      'not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}
