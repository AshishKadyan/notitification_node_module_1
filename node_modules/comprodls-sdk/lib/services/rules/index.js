/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

/***********************************************************
 * comproDLS SDK Rules API Adaptor
 * Functions for calling Rules API.
 ************************************************************/

var q = require('q');
var request = require('superagent');
var helpers = require('../../helpers');

var DLSError = helpers.errors.DLSError;

/*********************************
 * Setting Up Module Entry Point
 **********************************/
module.exports = rules;
//Rules Adaptor Contsructor
function rules() {
  return {
    getRules: getRules.bind(this),
    getParticularRule: getParticularRule.bind(this),
    getUserRule: getUserRule.bind(this),
    updateRuleDisplay: updateRuleDisplay.bind(this),
    createRule: createRule.bind(this),
    updateRule: updateRule.bind(this),
    deleteRule: deleteRule.bind(this)
  };
}

/*********************************
 * Public Function definitions
 **********************************/

/**
 * options = {
 *   context: '',   // Mandatory
 *   ruleType: '',  // Mandatory
 *   cursor: ''     // Optional
 * }
 */
function getRules(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();

  //Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if (err) {
    dfd.reject(err);
  } else {
    if (options && options.context && options.ruleType) {
      //Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.RULES_API_URLS.rules;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        context: encodeURIComponent(options.context),
        ruleType: options.ruleType
      });

      //Setup request with URL and Params
      var queryParam = { cursor: options.cursor };

      var requestAPI = request.get(url)
        .set('Content-Type', 'application/json')
        .set('Accept', 'application/json')
        .query(queryParam);

      if (self.traceid) {
        requestAPI.set('X-Amzn-Trace-Id', self.traceid);
      }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (err, response) {
        if (err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body);
        }
      });
    } else {
      err = {};
      err.message = err.description = 'context or ruleType not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/**
 * options = {
 *   context: '',   // Mandatory
 *   ruleType: '',  // Mandatory
 *   ruleId: ''     // Mandatory
 * }
 */
function getParticularRule(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();

  //Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if (err) {
    dfd.reject(err);
  } else {
    if (options && options.context && options.ruleType && options.ruleId) {
      //Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.RULES_API_URLS.particularRule;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        context: encodeURIComponent(options.context),
        ruleType: options.ruleType,
        ruleId: options.ruleId
      });

      //Setup request with URL and Params
      var requestAPI = request.get(url);

      if (self.traceid) {
        requestAPI.set('X-Amzn-Trace-Id', self.traceid);
      }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (err, response) {
        if (err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body);
        }
      });
    } else {
      err = {};
      err.message = err.description = 'context or ruleType or ruleId not found' +
        ' in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/**
 * options = {
 *   orgId: '',          // Mandatory
 *   context: '',        // Mandatory
 *   ruleType: '',       // Mandatory
 *   userId: '',         // Mandatory
 *   mergeGlobalRules:'' // Optional
 * }
 */
function getUserRule(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();

  if (options && options.orgId && options.context && options.ruleType && options.userId) {
    //Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH + self.config.RULES_API_URLS.getUserRule;
    url = helpers.api.constructAPIUrl(url, {
      orgId: self.orgId,
      context: encodeURIComponent(options.context),
      ruleType: options.ruleType,
      userId: options.userId
    });

    //Setup request with URL and Params
    var queryParam = { mergeGlobalRules: options.mergeGlobalRules };

    var requestAPI = request.get(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .query(queryParam);

    if (self.traceid) {
      requestAPI.set('X-Amzn-Trace-Id', self.traceid);
    }

    //Setup token in Authorization header
    requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

    requestAPI.end(function (err, response) {
      if (err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      } else {
        dfd.resolve(response.body);
      }
    });
  } else {
    var err = {};
    err.message = err.description = 'Mandatory params - orgId or context or ruleType or userId ' +
      'not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/**
 * options = {
 *   context: '',        // Mandatory
 *   ruleType: '',       // Mandatory
 *   ruleId: '',         // Mandatory
 *   body: {
 *     rule_display: ''  // Mandatory
 *   }
 *  }
 */
function updateRuleDisplay(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if (err) { dfd.reject(err); }
  else {
    if (options && options.context && options.ruleType && options.ruleId &&
      options.body && options.body.rule_display) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.RULES_API_URLS.updateRuleDisplay;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        context: encodeURIComponent(options.context),
        ruleType: options.ruleType,
        ruleId: options.ruleId
      });

      // Setup request with URL and Params
      var requestAPI = request.put(url)
        .set('Content-Type', 'application/json')
        .set('Accept', 'application/json')
        .send(options.body);
      if (self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (error, response) {
        if (error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory params - context or ruleType or ruleId ' +
        'or body.rule_display not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/**
 * options = {
 *   context: '',   // Mandatory
 *   ruleType: '',  // Mandatory
 *   body: {
 *     ruleid: '',  // Mandatory
 *     scope: '',   // Mandatory
 *     entities: [  // Min. length 1
 *       {
 *         id:'',   // eg. item code
 *         type:''  // eg. item/folder/product
 *       },
 *       ...],
 *     user: ['extuserid1','extuserid2', ...],
 *     rule_data_individual: {},
 *     rule_data_common: {},
 *     rule_display: {}
 *   }
 * }
 */
function createRule(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if (err) { dfd.reject(err); }
  else {
    if (options && options.context && options.ruleType && options.body) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.RULES_API_URLS.rules;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        context: encodeURIComponent(options.context),
        ruleType: options.ruleType
      });

      // Setup request with URL and Params
      var requestAPI = request.post(url)
        .set('Content-Type', 'application/json')
        .set('Accept', 'application/json')
        .send(options.body);
      if (self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (error, response) {
        if (error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory params - context or ruleType or body' +
        ' not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/**
 * options = {
 *   context: '',   // Mandatory
 *   ruleType: '',  // Mandatory
 *   ruleId: '',     // Mandatory
 *   body: {
 *     scope: '',   // Mandatory
 *     entities: [  // Min. length 1
 *       {
 *         id:'',   // eg. item code
 *         type:''  // eg. item/folder/product
 *       },
 *       ...],
 *     user: ['extuserid1','extuserid2', ...],
 *     rule_data_individual: {}, // Optional
 *     rule_data_common: {}      // Optional
 *   }
 * }
 */
function updateRule(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if (err) { dfd.reject(err); }
  else {
    if (options && options.context && options.ruleType && options.ruleId && options.body) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.RULES_API_URLS.particularRule;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        context: encodeURIComponent(options.context),
        ruleType: options.ruleType,
        ruleId: options.ruleId
      });

      // Setup request with URL and Params
      var requestAPI = request.put(url)
        .set('Content-Type', 'application/json')
        .set('Accept', 'application/json')
        .send(options.body);
      if (self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (error, response) {
        if (error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory params - context or ruleType or ruleId or body ' +
        'not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/**
 * options = {
 *   context: '',   // Mandatory
 *   ruleType: '',  // Mandatory
 *   ruleId: ''     // Mandatory
 * }
 */
function deleteRule(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if (err) { dfd.reject(err); }
  else {
    if (options && options.context && options.ruleType && options.ruleId) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.RULES_API_URLS.particularRule;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        context: encodeURIComponent(options.context),
        ruleType: options.ruleType,
        ruleId: options.ruleId
      });

      // Setup request with URL and Params
      var requestAPI = request.delete(url);

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
      if (self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      requestAPI.end(function (error, response) {
        if (error) {
          err = {};
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else {
          dfd.resolve(response.body);
        }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory params - context or ruleType or ruleId not found' +
        ' in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}
