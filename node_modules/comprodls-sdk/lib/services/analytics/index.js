/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

/***********************************************************
 * comproDLS SDK Analytics API Adaptor
 * Functions for calling Analytics API.
 ************************************************************/

/*********************************
 * Setting Up Module Entry Point  
 **********************************/

var q = require('q');
var request = require('superagent');
var Agent = require('agentkeepalive');

var helpers = require('../../helpers');
var DLSError = helpers.errors.DLSError;

module.exports = analytics;

var keepaliveAgent = new Agent({
  timeout: 60000,
  freeSocketTimeout: 30000
});

/*********************************
 * Public Function definitions
 **********************************/
function analytics() {
  return {
		archiveUserAnalytics: archiveUserAnalytics.bind(this),
    getArchivedUserAnalytics: getArchivedUserAnalytics.bind(this),

    getOrgAnalyticsStat: getOrgAnalyticsStat.bind(this),

    getClassAnalytics: getClassAnalytics.bind(this),
    getClassProductRecentPendingSubmissions: getClassProductRecentPendingSubmissions.bind(this),
    getClassRecordUserAggregations: getClassRecordUserAggregations.bind(this),
    getClassRecord: getClassRecord.bind(this),
    getClassRecordItemAggregations: getClassRecordItemAggregations.bind(this),
    getShowcaseRecordOfAClass: getShowcaseRecordOfAClass.bind(this),

    getGroupRecord: getGroupRecord.bind(this),
    getClassGroupsRecentPendingSubmissions: getClassGroupsRecentPendingSubmissions.bind(this),
    getGroupsWithEvaluatedOnce: getGroupsWithEvaluatedOnce.bind(this),

    getUserProductAnalytics: getUserProductAnalytics.bind(this),
    getUserProductAnalyticById: getUserProductAnalyticById.bind(this),
    getExternalDataForUserAnalyticItem: getExternalDataForUserAnalyticItem.bind(this),
    searchUserProductAnalytics: searchUserProductAnalytics.bind(this),
    getUserClassRecentSubmissions: getUserClassRecentSubmissions.bind(this),
    getStudentsWithEvaluatedOnce: getStudentsWithEvaluatedOnce.bind(this),

    getAppState: getAppState.bind(this),
    updateAppState: updateAppState.bind(this),
    deleteAppState: deleteAppState.bind(this),

    getQuestionProgressByLearningObjective: getQuestionProgressByLearningObjective.bind(this),

    //AssignedPaths Related APIs
    getAllAssignedPathsOfClass: getAllAssignedPathsOfClass.bind(this),
    getMyAssignedPathsOfClass: getMyAssignedPathsOfClass.bind(this),
    getAssignedPathAnalytics: getAssignedPathAnalytics.bind(this),
    getMyParticularAssignedPathOfClass: getMyParticularAssignedPathOfClass.bind(this),
    
    getTimeseriesAnalytics: getTimeseriesAnalytics.bind(this)
  };
}

//options = {
//	type: 'users/classes', // choose any one
//	range: '', //
//	start: '', // time(ms) - start interval
//	end: '', // time(ms) - end interval
//  role: '', // The role of users i.e. student, teacher, etc. No default role (i.e. all users).
//  shadow: <boolean> // if user/class is shadow-provsioined.
//}
function getOrgAnalyticsStat(options) {
	var self = this;

  //Initializing promise
  var dfd = q.defer();
  //Validations
  var err = {};
	if(options && options.type) {
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) { dfd.reject(err); }
    else {
      err = {};
      var allowedAnalyticsDataType = ['users', 'classes'];
			if(allowedAnalyticsDataType.indexOf(options.type) > -1) {
				//Passed all validations, Construct API url
				var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +
                  self.config.ANALYTICS_API_URLS.getOrgAnalyticsStat;
				url = helpers.api.constructAPIUrl(url, {
          orgId: self.orgId, type: options.type
        });

				var params = {};
				if(options) {
					if(options.range) { params.range = options.range; }
					if(options.start) { params.start = options.start; }
					if(options.end) { params.end = options.end; }
					if(options.role) { params.role = options.role; }
					if(options.shadow) { params.shadow = options.shadow; }
				}

				//Setup request with URL and Params
				var requestAPI = request.get(url).query(params);

				//Setup token in Authorization header
				requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

        // setting up traceid
        if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

				//Call Product Timespent Api
				requestAPI.end(function(err, response) {
					if(err) {
						err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
						dfd.reject(err);
					}
          else { dfd.resolve(response.body); }
        });
			} else {
				err.message = err.description = 'Type: ' + options.type + ' is not supported';
				err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
				dfd.reject(err);
			}
		}
	} else {
		err.message = err.description = 'type not found in request options';
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}

	return dfd.promise;
}

//options = {
//  type: 'string',            // [items/summary]
//	userid: 'string',          // user uuid
//	productcode: 'string,        // product code
//	classid: 'string',         // OPTIONAL
//  itemcode: 'string',         // OPTIONAL (only for 'type=items') item-code of the required item
//  metrics: boolean            // OPTIONAL (only for 'type=items') true/false - aggregations on the
//                                 item(s), default - true
//  history: boolean            // If history is true - submission is array else submission is object
//  expiredView: boolean            // If expiredView is true - items from class record matrix will be returned.
//  externalData: boolean       // OPTIONAL(default is 'false' - only works with itemcode) whether to return external 
                                    //secondary evaluation data or not.
//  group: boolean              // If group is true - then it will return group data from P1.
//}
function getUserProductAnalytics(options) {
	var self = this;

  //Initializing promise
  var dfd = q.defer();
  //Validations
  var err = {};
	if(options && options.type && options.userid && options.productcode) {
		err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) { dfd.reject(err); }
    else {
      var supportedType = ['items', 'summary'];
      //Passed all validations, Construct API url
			var url = self.config.DEFAULT_HOSTS['ANALYTICS'];

      if(supportedType.indexOf(options.type) > -1) {
        switch(options.type) {
					case 'items':
						url += self.config.ANALYTICS_API_URLS.getAnalyticProductItems;
						break;
					case 'summary':
						url += self.config.ANALYTICS_API_URLS.getAnalyticProductSummary;
						break;
				}
				url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

				var params = { userid: options.userid, productcode: options.productcode };

				if(options.classid) { params.classid = options.classid; }
        if(options.itemcode) { params.itemcode = options.itemcode; }
        if(options.metrics) { params.metrics = options.metrics; }
        if(options.history) { params.history = options.history; }
        if(options.group) { params.group = options.group; }
        if(options.externalData) { params.externalData = options.externalData; }
        if(options.expiredView && options.type === 'items') { params.expiredView = options.expiredView; }

				//Setup request with URL and Params
				var requestAPI = request.get(url).query(params);

				//Setup token in Authorization header
				requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

        // setting up traceid
        if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

				//Call Product Timespent Api
				requestAPI.end(function(err, response) {
					if(err) {
						err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
						dfd.reject(err);
					}
          else { dfd.resolve(response.body); }
        });
			} else {
				err.message = err.description = options.type + " is not a valid value of option 'type'";
				err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
				dfd.reject(err);
			}
		}
	} else {
		err.message = err.description = "Required parameter 'type' or 'userid' or " +
                                    "'productcode' not found in request options";
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}

	return dfd.promise;
}

//options = {
// userprogressid: 'string' // userprogressid
//}
function getUserProductAnalyticById(options) {
	var self = this;

  //Initializing promise
  var dfd = q.defer();
  //Validations
  var err = {};
	if(options && options.userprogressid) {
		err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) { dfd.reject(err); }
    else {
      //Passed all validations, Construct API url
			var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +
                self.config.ANALYTICS_API_URLS.getAnalyticProductById;
			url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId, userProgressId: options.userprogressid
      });

      //Setup request with URL and Params
			var requestAPI = request.get(url);

			//Setup token in Authorization header
			requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

			//Call Product Timespent Api
			requestAPI.end(function(err, response) {
				if(err) {
					err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
					dfd.reject(err);
				}
        else { dfd.resolve(response.body); }
			});
		}
	} else {
		err.message = err.description = "Required parameter 'userprogressid' not " +
                                    "found in request options";
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}

	return dfd.promise;
}

//options = {
// ext_user_id: <ext_user_id>, // mandatory
// productcode: <productcode>, // mandatory
// itemcode: <itemcode>, // mandatory
// (any one field from 'submission_order' OR 'ext_link_id' is mandatory)
// submission_order: number, // optional
// ext_link_id: <ext_link_id>, // optional
// part: number, // mandatory
// classid: <classid>, // optional
//}
function getExternalDataForUserAnalyticItem(options) {
  var self = this;
  var dfd = q.defer();
  // Validations
  var err = {};
  if(options && options.ext_user_id && options.productcode && options.itemcode &&
      (options.submission_order || options.ext_link_id) && options.part) {
		err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) { dfd.reject(err); }
    else {
      // Passed all validations, Construct API url
			var url = self.config.DEFAULT_HOSTS.ANALYTICS +
                self.config.ANALYTICS_API_URLS.getExternalDataForUserAnalyticItem;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      var params = {
        ext_user_id: options.ext_user_id,
        productcode: options.productcode,
        itemcode: options.itemcode,
        part: options.part
      };

      if(options.submission_order) { params.submission_order = options.submission_order; }
      if(options.ext_link_id) { params.ext_link_id = options.ext_link_id; }
      if(options.classid) { params.classid = options.classid; }

      // Setup request with URL and Params
      var requestAPI = request.get(url).query(params);

      // Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Call Product Timespent Api
      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    }
	} else {
		err.message = err.description = "Required parameters 'ext_user_id' or 'productcode' or 'itemcode'" +
                                      " or (either 'submission_order' OR 'ext_link_id') or 'part'are not found in request options";
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}
	return dfd.promise;
}

//options = {
//	userid: <userid>
//	productid: <productid>,
//	classid: <classid>, // OPTIONAL
//}
function archiveUserAnalytics(options) {
	var self = this, err = {};
  //Initializing promise
  var dfd = q.defer();
	if(options && options.userid && options.productid) {
    //Validations
		err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) { dfd.reject(err); }
    else {
      var params = {};
			//Passed all validations, Construct API url
			var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +
                self.config.ANALYTICS_API_URLS.archiveUserAnalytics;
			url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

			if(options.userid) { params.userid = options.userid; }
			if(options.productid) { params.productid = options.productid; }
			if(options.classid) { params.classid = options.classid; }

      //Setup request with URL and Params
			var requestAPI = request.post(url).query(params)
                       .set('Content-Type', 'application/json');

			//Setup token in Authorization header
			requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

			requestAPI.end(function(err, response) {
				if(err) {
					err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
					dfd.reject(err);
				}
        else { dfd.resolve(response.body); }
      });
		}
	} else {
		err.message = err.description = 'Mandatory parameter [userid, productid] ' +
                                    'not found in request options';
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}

  return dfd.promise;
}

//options = {
//	userid: <userid>, // OPTIONAL
//	productid: <productid>, // OPTIONAL
//	classid: <classid>, // OPTIONAL
//  lookup: 'string', // Search query (',' separated key value pairs), e.g. key1:val1,key2:val2,key3:val3
//  cursor: '', // cursor to next set of documents
//  limit: '' // limit of documents per function call
//}
function searchUserProductAnalytics(options) {
	var self = this, err = {};
  //Initializing promise
  var dfd = q.defer();

	//Validations
	err = helpers.validations.isAuthenticated(self.orgId, self.token);
	if(err) { dfd.reject(err); }
  else {
    var params = {};
		//Passed all validations, Construct API url
		var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +
              self.config.ANALYTICS_API_URLS.searchUserProductAnalytics;
		url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

		if(options.userid) { params.userid = options.userid; }
		if(options.productid) { params.productid = options.productid; }
		if(options.classid) { params.classid = options.classid; }
		if(options.lookup) { params.lookup = options.lookup; }
		if(options.cursor) { params.cursor = options.cursor; }
		if(options.limit) { params.limit = options.limit; }

    //Setup request with URL and Params
		var requestAPI = request.get(url).query(params);

		//Setup token in Authorization header
		requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

    // setting up traceid
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

		requestAPI.end(function(err, response) {
			if(err) {
				err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
				dfd.reject(err);
			}
      else { dfd.resolve(response.body); }
		});
	}

  return dfd.promise;
}

/**
 * This function returns the count and submissions of a user in a class for a product.
 * options = {
 *  userid: string,
 *  classid: string,
 *  productcode: string,
 *  gradingStatus: string,          // optional, type of submissions required.
 *                                     Possible values: ['not-started', 'submitted', 'evaluated']
 * }
 */
function getUserClassRecentSubmissions(options) {
  var self = this;
  var dfd = q.defer(), err = {};

  if(options && options.classid && options.productcode && options.userid) {
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err) { dfd.reject(err); }
    else {
      // Passed all validations, Constructing URL
      var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +
          self.config.ANALYTICS_API_URLS.getUserClassRecentSubmissions;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      // Setup Query Params
      var queryParams = {
        userid: options.userid,
        classid: options.classid,
        productcode: options.productcode
      };

      if(options.gradingStatus) { queryParams.gradingStatus = options.gradingStatus; }

      // Setup Request with url and params
      var requestAPI = request.get(url).query(queryParams);
      // Setup token in Authorization Header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Call GET Class Product Recent Pending Submissions
      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body);
        }
      });
    }
  }
  else {
    err.message = err.description = 'Mandatory parameters ["classid", "productcode", "userid"]' +
      ' not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

//options = {
//  classid: 'string',
//  productcode: 'string',
//}
function getStudentsWithEvaluatedOnce(options) {
	var self = this, err = {};
	//Initializing promise
	var dfd = q.defer();
	if(options && options.classid && options.productcode) {
		//Validations
		err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) { dfd.reject(err); }
		else {
		// Passed all validations, Construct API url
			var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +
				self.config.ANALYTICS_API_URLS.getStudentsWithEvaluatedOnce;
			url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

			// Setup params
			var params = {
				classid: options.classid,
				productcode: options.productcode
			};
			// Setup request with URL and Params
			var requestAPI = request.get(url).query(params);
			// Setup token in Authorization header
			requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

			requestAPI.end(function(error, response) {
				if(error) {
					err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
					dfd.reject(err);
				}
				else { dfd.resolve(response.body); }
			});
		}
	} else {
		err.message = err.description = 'Required parameter classid or ' +
			'productcode not found in request options.';
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}
	return dfd.promise;
}


/*options = {
  userid: <userid>, productcode: <productcode>,
  classid: <classid>, // OPTIONAL
  itemcode: <itemcode> // OPTIONAL
  key: <string> // OPTIONAL
}*/
function getAppState(options) {
  var self = this;
  var dfd = q.defer();
  // Validations
  var err = {};
	if(options && options.userid && options.productcode) {
		err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) { dfd.reject(err); }
    else {
      // Passed all validations, Construct API url
			var url = self.config.DEFAULT_HOSTS.ANALYTICS +
                self.config.ANALYTICS_API_URLS.appState;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      var params = { userid: options.userid, productcode: options.productcode };
      if(options.classid) { params.classid = options.classid; }
      if(options.itemcode) { params.itemcode = options.itemcode; }
      if(options.key) { params.key = options.key; }

      // Setup request with URL and Params
      var requestAPI = request.get(url).query(params);

      // Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Call Product Timespent Api
      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    }
	} else {
		err.message = err.description = "Required parameters 'userid' or " +
                                 "'productcode' are not found in request options";
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}
	return dfd.promise;
}

/*options = {
  userid: <userid>,
  productcode: <productcode>,
  classid: <classid>, // OPTIONAL
  itemcode: <itemcode> // OPTIONAL
  appdata: <object>,
}*/
function updateAppState(options) {
  var self = this;
  var dfd = q.defer();
  // Validations
  var err = {};
	if(options && options.userid && options.productcode && options.appdata) {
		err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) { dfd.reject(err); }
    else {
      // Passed all validations, Construct API url
			var url = self.config.DEFAULT_HOSTS.ANALYTICS +
                self.config.ANALYTICS_API_URLS.appState;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      var params = { userid: options.userid, productcode: options.productcode };
      if(options.classid) { params.classid = options.classid; }
      if(options.itemcode) { params.itemcode = options.itemcode; }

      // Setup request with URL and Params
      var requestAPI = request.put(url).query(params)
                       .set('Content-Type', 'application/json')
                       .set('Accept', 'application/json')
                       .send(options.appdata);

      // Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Call Product Timespent Api
      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    }
	} else {
		err.message = err.description = "Required parameters 'userid' or 'appdata'" +
                              " or 'productcode' are not found in request options";
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}
	return dfd.promise;
}

/*options = {
  userid: <userid>, productcode: <productcode>,
  classid: <classid>, // OPTIONAL
  itemcode: <itemcode> // OPTIONAL
  key: <string> // OPTIONAL
}*/
function deleteAppState(options) {
  var self = this;
  var dfd = q.defer();
  // Validations
  var err = {};
	if(options && options.userid && options.productcode) {
		err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) { dfd.reject(err); }
    else {
      // Passed all validations, Construct API url
			var url = self.config.DEFAULT_HOSTS.ANALYTICS +
                self.config.ANALYTICS_API_URLS.appState;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      var params = { userid: options.userid, productcode: options.productcode };
      if(options.classid) { params.classid = options.classid; }
      if(options.itemcode) { params.itemcode = options.itemcode; }
      if(options.key) { params.key = options.key; }

      // Setup request with URL and Params
      var requestAPI = request.delete(url).query(params);

      // Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Call Product Timespent Api
      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    }
	} else {
		err.message = err.description = "Required parameters 'userid' or " +
                              "'productcode' are not found in request options";
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}
	return dfd.promise;
}


/**
 * This function returns the recent pending submissions in a Class for a Product.
 * options = {
 *  classid: string,
 *  productcode: string,
 *  details: boolean,           // optional, if details of submissions is also required.
 *  limit: number               // optional, number of submissions to be fetched at once (default & max is 100)
 * }
 */
function getClassProductRecentPendingSubmissions(options) {
  var self = this;
  var dfd = q.defer(), err = {};

  if(options && options.classid && options.productcode) {
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err) { dfd.reject(err); }
    else {
      // Passed all validations, Constructing URL
      var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +
          self.config.ANALYTICS_API_URLS.getClassProductRecentPendingSubmissions;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      // Setup Query Params
      var queryParams = {
        classid: options.classid,
        productcode: options.productcode
      };

      if(options.details) { queryParams.details = options.details; }
      if(options.limit) { queryParams.limit = options.limit; }

      // Setup Request with url and params
      var requestAPI = request.get(url).query(queryParams);
      // Setup token in Authorization Header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
      // Call GET Class Product Recent Pending Submissions

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body);
        }
      });
    }
  }
  else {
    err.message = err.description = 'Mandatory parameters ["classid", "productcode"] not found in ' +
      'request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/*options = {
 *  classid: 'string',            // class uuid
 *  productcode: 'string',          // product code
 *  includeContext: 'boolean'     // includse context or heirarchy (optional)
 *}
 */
function getClassRecord(options) {
  var self = this;

  //Initializing DFD
  var dfd = q.defer(), err = {};

  // Validations
  if(options && options.classid && options.productcode) {
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err){ dfd.reject(err); }
    else {
      // Passed all validations, Constructing URL
      var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +  self.config.ANALYTICS_API_URLS.getClassRecord;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      // Setup Query Params
      var queryParams = {
        classid: options.classid,
        productcode: options.productcode,
        includeContext: options.includeContext
      }

      // Setup Request with url and params
      var requestAPI = request.get(url).query(queryParams);
      // Setup token in Authorization Header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Call GET GET CLASS RECORD ITEM
      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body)
        }
      });
    }
  } else {
    err.message = err.description = 'Required parameter classid or ' +
			'productcode not found in request options.';
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
  }
  return dfd.promise;
}

/*options = {
 *  classid: 'string',            // class uuid
 *  productcode: 'string',          // product code
 *  item-code: 'string'                // item-code of item(optional)
 *}
 */
function getClassRecordItemAggregations(options) {
  var self = this;

  //Initializing DFD
  var dfd = q.defer(), err = {};

  // Validations
  if(options && options.classid && options.productcode) {
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err){ dfd.reject(err); }
    else {
      // Passed all validations, Constructing URL
      var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +  self.config.ANALYTICS_API_URLS.getClassRecordItemAggregations;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      // Setup Query Params
      var queryParams = {
        classid: options.classid,
        productcode: options.productcode,
        'item-code': options['item-code']
      }

      // Setup Request with url and params
      var requestAPI = request.get(url).query(queryParams);
      // Setup token in Authorization Header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Call GET GET CLASS RECORD ITEM
      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body)
        }
      });
    }
  } else {
    err.message = err.description = 'Required parameter classid or ' +
			'productcode not found in request options.';
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
  }
  return dfd.promise;
}

/*options = {
 *  classid: 'string',            // class uuid(mandatory)
 *  productcode: 'string',        // product code(optional)
 *  'item-code': 'string',        // itemcode of item(optional)
 *  groupid: 'string',            // groupid of a group(optional)
 *  id: 'string'                  // id of showcase record item(optional)
 *}
 */
function getShowcaseRecordOfAClass(options) {
  var self = this;

  //Initializing DFD
  var dfd = q.defer(), err = {};

  // Validations
  if(options && options.classid) {
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err){ dfd.reject(err); }
    else {
      // Passed all validations, Constructing URL
      var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +  self.config.ANALYTICS_API_URLS.getShowcaseRecordOfAClass;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      // Setup Query Params
      var queryParams = {
        classid: options.classid
      };

      if(options.productcode) { queryParams.productcode = options.productcode; }
      if(options.groupid) { queryParams.groupid = options.groupid; }
      if(options['item-code']) { queryParams['item-code'] = options['item-code']; }
      if(options.id) { queryParams.id = options.id; }

      // Setup Request with url and params
      var requestAPI = request.get(url).query(queryParams);
      // Setup token in Authorization Header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Call GET GET CLASS RECORD ITEM
      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body);
        }
      });
    }
  } else {
    err.message = err.description = 'Required parameter classid not found in request options.';
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
  }
  return dfd.promise;
}

/**
 * options = {
 *  classid: 'string',       // mandatory, class uuid
 *  productcode: 'string',   // mandatory, product code
 *  groupid: 'string',       // mandatory, group id
 *  itemcode: 'string',      // optional, item code of the group LO whose GR is required
 *  history: boolean         // optional, if true give all the submissions else give only the latest submission
 * }
 */
function getGroupRecord(options) {
  var self = this;

  //Initializing DFD
  var dfd = q.defer(), err = {};

  // Validations
  if(options && options.classid && options.productcode && options.groupid) {
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err){ dfd.reject(err); }
    else {
      // Passed all validations, Constructing URL
      var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +  self.config.ANALYTICS_API_URLS.getGroupRecord;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      // Setup Query Params
      var queryParams = {
        classid: options.classid,
        productcode: options.productcode,
        groupid: options.groupid
      }

      if(options.itemcode) { queryParams.itemcode = options.itemcode; }
      if(options.history) { queryParams.history = options.history; }

      // Setup Request with url and params
      var requestAPI = request.get(url).query(queryParams);
      // Setup token in Authorization Header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Call GET GET GROUP RECORD ITEM
      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body)
        }
      });
    }
  } else {
    err.message = err.description = 'Required parameter classid or ' +
			'productcode or groupid not found in request options.';
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
  }
  return dfd.promise;
}

/**
 * This function returns the recent pending submissions of all the groups in a Class for a Product.
 * options = {
 *  classid: string,
 *  productcode: string,
 *  details: boolean,           // optional, if details of submissions is also required.
 *  limit: number               // optional, number of submissions to be fetched at once (default & max is 100)
 * }
 */
function getClassGroupsRecentPendingSubmissions(options) {
  var self = this;
  var dfd = q.defer(), err = {};

  if(options && options.classid && options.productcode) {
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err) { dfd.reject(err); }
    else {
      // Passed all validations, Constructing URL
      var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +
          self.config.ANALYTICS_API_URLS.getClassGroupsRecentPendingSubmissions;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      // Setup Query Params
      var queryParams = {
        classid: options.classid,
        productcode: options.productcode
      };

      if(options.details) { queryParams.details = options.details; }
      if(options.limit) { queryParams.limit = options.limit; }

      // Setup Request with url and params
      var requestAPI = request.get(url).query(queryParams);
      // Setup token in Authorization Header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Call GET Class Product Recent Pending Submissions of all groups
      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body);
        }
      });
    }
  }
  else {
    err.message = err.description = 'Mandatory parameters ["classid", "productcode"] not found in ' +
      'request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/**
 * options = {
  * classid: 'string',  //mandatory
  * productcode: 'string' //mandatory
  *}
  */
function getGroupsWithEvaluatedOnce(options) {
	var self = this, err = {};
	//Initializing promise
	var dfd = q.defer();
	if(options && options.classid && options.productcode) {
		//Validations
		err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) { dfd.reject(err); }
		else {
		// Passed all validations, Construct API url
			var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +
				self.config.ANALYTICS_API_URLS.getGroupsWithEvaluatedOnce;
			url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

			// Setup params
			var params = {
				classid: options.classid,
				productcode: options.productcode
			};
			// Setup request with URL and Params
			var requestAPI = request.get(url).query(params);
			// Setup token in Authorization header
			requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

			requestAPI.end(function(error, response) {
				if(error) {
					err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
					dfd.reject(err);
				}
				else { dfd.resolve(response.body); }
			});
		}
	} else {
		err.message = err.description = 'Required parameter classid or ' +
			'productcode not found in request options.';
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}
	return dfd.promise;
}

//options = {
//  classid: 'string',
//  productcode: 'string',
//  userid: 'string' //optional
//}

function getClassRecordUserAggregations(options) {
	var self = this, err = {};
	//Initializing promise
	var dfd = q.defer();
	if(options && options.classid && options.productcode) {
		//Validations
		err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) { dfd.reject(err); }
		else {
		// Passed all validations, Construct API url
			var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +
				self.config.ANALYTICS_API_URLS.getClassRecordUserAggregations;
			url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

			// Setup params
			var params = {
				classid: options.classid,
				productcode: options.productcode,
        userid: options.userid
			};
			// Setup request with URL and Params
			var requestAPI = request.get(url).query(params);
			// Setup token in Authorization header
			requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

			requestAPI.end(function(error, response) {
				if(error) {
					err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
					dfd.reject(err);
				}
				else { dfd.resolve(response.body); }
			});
		}
	} else {
		err.message = err.description = 'Required parameter classid or ' +
			'productcode not found in request options.';
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}
	return dfd.promise;
}

//options = {
//  type: ['stat' / 'timeseries'],
//  analyticsDataType: ['enrolments' / 'logins']
//  classid: 'string',
//	range: '', // for type - stat // OPTIONAL
//	start: '', // time(ms) - start interval // OPTIONAL
//	end: '' // time(ms) - end interval // OPTIONAL
//  interval: '' The interval at which counters are displayed. Possible values are five_minutes, half_hour, hour, six_day, day, week, and month. Default interval is day. // Only for type - timeseries // OPTIONAL
//}
function getClassAnalytics(options) {
	var self = this;

  //Initializing promise
  var dfd = q.defer();
  //Validations
  var err = {};
	if(options && options.type && options.analyticsDataType && options.classid) {
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) { dfd.reject(err); }
    else {
      err = {};
      if((!options.range && !options.interval) ||
       (options.range && options.type === 'stat') ||
       (options.interval && options.type === 'timeseries'))
      {
        var allowedAnalyticsDataType = ['enrolments', 'logins'];
				if(allowedAnalyticsDataType.indexOf(options.analyticsDataType) > -1) {
          //Passed all validations, Construct API url
					var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +
                    self.config.ANALYTICS_API_URLS.getClassAnalytics;
					url = helpers.api.constructAPIUrl(url, {
						orgId: self.orgId, type: options.type,
						analyticsDataType: options.analyticsDataType
					});

					var params = { classid: options.classid };
					if(options) {
						if(options.range) { params.range = options.range; }
						if(options.start) { params.start = options.start; }
						if(options.end) { params.end = options.end; }
						if(options.interval) { params.interval = options.interval; }
					}

					//Setup request with URL and Params
					var requestAPI = request.get(url).query(params);

					//Setup token in Authorization header
					requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

          // setting up traceid
          if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

					//Call Product Timespent Api
					requestAPI.end(function(err, response) {
						if(err) {
							err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
							dfd.reject(err);
						}
            else { dfd.resolve(response.body); }
					});
				} else {
					err.message = err.description = 'analyticsDataType: ' +
                                          options.analyticsDataType + ' is not supported';
					err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
					dfd.reject(err);
				}
			} else {
				err.message = err.description = 'Range should be defined for type - ' +
                          '"stat" and Interval should be defined for type - "timeseries"';
				err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
				dfd.reject(err);
			}
		}
	} else {
		err.message = err.description = 'Required options ["type", "analyticsDataType",' +
                                                ' "classid"] not found in request options';
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}

	return dfd.promise;
}

//options = {
//	useranalyticid: <userid>,
//  cursor: '', // OPTIONAL cursor to next set of documents
//  limit: '' // OPTIONAL limit of documents per function call (Default is 5)
//}
function getArchivedUserAnalytics(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();
  //Validations
  var err = {};
  if(options && options.useranalyticid) {
		err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) { dfd.reject(err); }
    else {
      //Passed all validations, Construct API url
			var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +
                self.config.ANALYTICS_API_URLS.getArchivedUserAnalytics;
			url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });
			var params = { useranalyticid: options.useranalyticid };
			if(options) {
				if(options.cursor) { params.cursor = options.cursor; }
				if(options.limit) { params.limit = options.limit; }
			}

			//Setup request with URL and Params
			var requestAPI = request.get(url).query(params);

			//Setup token in Authorization header
			requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

			//Call Product Timespent Api
			requestAPI.end(function(err, response) {
				if(err) {
					err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
					dfd.reject(err);
				}
        else { dfd.resolve(response.body); }
			});
		}
	} else {
		err.message = err.description = "Mandatory field 'useranalyticid' not found" +
                                    " in request options";
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}

	return dfd.promise;
}

/*********************************************************
* This function converts the data from questions format to
* Learning Objective Format.
*********************************************************/
function getQuestionProgressByLearningObjective(questionsArray) {
    var learningObjectiveFormat = {};
    for(var i = 0; i < questionsArray.length; i++) {
        var questionLearningObjectives = questionsArray[i]['learning-objectives'];
        for(var j = 0; j < questionLearningObjectives.length; j++) {
            var analytics;
            var correct;
            var questionDataMap;
            if(!learningObjectiveFormat[questionLearningObjectives[j]]) {
                correct = 0;
                analytics = questionsArray[i].__analytics;
                if(analytics.statusEvaluation === 'correct') {
                    correct++;
                }
                var questionsMap = {
                    'status': {
                        'correct': correct,
                        'total': 1
                    },
                    'questions': []
                };
                questionDataMap = {
                    'question-code': questionsArray[i].questionCode,
                    'analytics': analytics
                };
                questionsMap.questions.push(questionDataMap);
                learningObjectiveFormat[questionLearningObjectives[j]] = questionsMap;
            }
            else {
                var savedQuestionsMap = learningObjectiveFormat[questionLearningObjectives[j]];
                analytics = questionsArray[i].__analytics;
                if(analytics.statusEvaluation === 'correct') {
                    correct = savedQuestionsMap.status.correct;
                    savedQuestionsMap.status.correct = correct + 1;
                }                        
                var total = savedQuestionsMap.status.total;
                savedQuestionsMap.status.total = total + 1;
                questionDataMap = {
                    'question-code': questionsArray[i].questionCode,
                    'analytics': analytics
                };                        
                savedQuestionsMap.questions.push(questionDataMap);
                learningObjectiveFormat[questionLearningObjectives[j]] = savedQuestionsMap;
            }
        }
    }
    return learningObjectiveFormat;
}

/* options = {
    "classid": "string", // required
  };
*/
function getAllAssignedPathsOfClass(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.classid) {

      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.ANALYTICS + self.config.ANALYTICS_API_URLS.getAllAssignedPathsOfClass;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      var queryParams = { classid: options.classid };

      // Setup request with URL and Params
      var requestAPI = request.get(url).query(queryParams);

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      requestAPI.end(function (error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory param - classid not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/* options = {
    "classid": "string", // required
    "assignedPathId" : "string", // required
    "productcode" : "string" //required
  };
*/
function getAssignedPathAnalytics(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.classid && options.assignedPathId && options.productcode) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.ANALYTICS + self.config.ANALYTICS_API_URLS.getAssignedPathAnalytics;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      var queryParams = {
        classid: options.classid,
        assignedpathid: options.assignedPathId,
        productcode: options.productcode
      };
      // Setup request with URL and Params
      var requestAPI = request.get(url).query(queryParams);

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      requestAPI.end(function (error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory params - classid or assignedPathId or productcode not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/* options = {
    "classid": "string", // required
    "userid" : "string", // required
    "progress" : "true/false",
    "group" : "true/false"
  };
*/
function getMyAssignedPathsOfClass(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.classid && options.userid ) {

      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.ANALYTICS + self.config.ANALYTICS_API_URLS.getMyAssignedPathsOfClass;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });
      var queryParams = { userid: options.userid, classid: options.classid };
      if(options.progress) { queryParams.progress =  options.progress; }
      if(options.group) { queryParams.group =  options.group; }

      // Setup request with URL and Params
      var requestAPI = request.get(url).query(queryParams);
      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      requestAPI.end(function (error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory params - classid, userid not found in ' +
                                      'request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/* options = {
    "classid": "string", // required
    "userid" : "string", // required
    "assignedPathId" : "string", // required
    "progress" : "true/false",
    "group" : "true/false"
  };
*/
function getMyParticularAssignedPathOfClass(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.classid && options.userid && options.assignedPathId ) {

      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.ANALYTICS + self.config.ANALYTICS_API_URLS.getMyAssignedPathsOfClass;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      var queryParams = {
        assignedpathid: options.assignedPathId, classid: options.classid, userid: options.userid
      };

      if(options.progress) { queryParams.progress =  options.progress; }
      if(options.group) { queryParams.group =  options.group; }

      // Setup request with URL and Params
      var requestAPI = request.get(url).query(queryParams);
      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      requestAPI.end(function (error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory params - classid, userid, assignedPathId not found in ' +
                                      'request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*
  options = {
    query: 'string', //mandatory
    cursor: 'string' //optional
  }
*/
function getTimeseriesAnalytics(options) {
  var self = this;
  var dfd = q.defer();
  var err;

  if(options && options.query) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.ANALYTICS + self.config.ANALYTICS_API_URLS.getTimeseriesAnalytics;

    // Contruct parameters
    var params = {
      query: options.query
    };

    if(options.cursor) { params.cursor =  options.cursor; }
    //Setup request with URL and Params
    var requestAPI = request.get(url).query(params);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI
      .agent(keepaliveAgent)
      .end(function (error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
  }
  else {
    err = {};
    err.message = err.description = 'Mandatory params query not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}