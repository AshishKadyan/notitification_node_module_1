/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

/***********************************************************
 * comproDLS SDK AUTH API Adaptor
 * Functions for calling AUTH API.
 ************************************************************/

var q = require('q');
var request = require('superagent');

var helpers = require('../../helpers');

var DLSError = helpers.errors.DLSError;

/*********************************
 * Setting Up Module Entry Point
 **********************************/
module.exports = spaces;

//Auth Adaptor Contsructor
function spaces(accountId) {
  this.accountId = accountId;
  return {
    getUserSpaces: getUserSpaces.bind(this),
    validateSpaceCode: validateSpaceCode.bind(this),
    validateClassCode: validateClassCode.bind(this),
    generateSpaceCode: generateSpaceCode.bind(this),
    changeSpaceCode: changeSpaceCode.bind(this),
    joinInstituteSpace: joinInstituteSpace.bind(this),
    provisionSpacesToStudent: provisionSpacesToStudent.bind(this),
    provisionSpacesToTeacher: provisionSpacesToTeacher.bind(this),
    provisionBulkSpaces: provisionBulkSpaces.bind(this),
    shadowProvision: shadowProvision.bind(this),
    entitleUserToProduct: entitleUserToProduct.bind(this),
    unentitleUserToProduct: unentitleUserToProduct.bind(this),
    revokeMicroEntitlementOfAUser: revokeMicroEntitlementOfAUser.bind(this),
    microEntitleUserToProduct: microEntitleUserToProduct.bind(this),
    bulkMicroEntitleProductToUser: bulkMicroEntitleProductToUser.bind(this),
    enrollUserInClass: enrollUserInClass.bind(this),
    getExtProduct: getExtProduct.bind(this),
    getSpaceDetails: getSpaceDetails.bind(this),
    updateUserInformation: updateUserInformation.bind(this),
    getInvitationsByEmail: getInvitationsByEmail.bind(this),
    updateInstituteTitle: updateInstituteTitle.bind(this)
  };
}

/*options = {
  extuserid: 'string',
  spaceRole: 'string',   //optional
  spaceType: 'string',   //optional
  spaceOrgContext: 'string',  //optional
  details: boolean, //optional
  cursor: 'string'   //optional
}*/
function getUserSpaces(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations

  if(options && options.extuserid) {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
              self.config.AUTH_API_URLS.getUserSpaces;
    url = helpers.api.constructAPIUrl(url, {
      accountid: self.accountId, extuserid: options.extuserid
    });

    var params = {};
    if(options.spaceRole) { params.spaceRole = options.spaceRole; }
    if(options.spaceType) { params.spaceType = options.spaceType; }
    if(options.spaceOrgContext) { params.spaceOrgContext = options.spaceOrgContext; }
    if(options.details) { params.details = options.details; }
    if(options.cursor) { params.cursor = options.cursor; }

    // Setup request with URL and Params
    var requestAPI = request.get(url).query(params);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } else {
    var err = {};
    err.message = err.description = 'extuserid not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/*options = {
  spaceCodeBody : {
      space_code: 'string'
  }
}*/
function validateSpaceCode(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  if(options && options.spaceCodeBody && options.spaceCodeBody.space_code) {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
                               self.config.AUTH_API_URLS.validateSpaceCode;
    url = helpers.api.constructAPIUrl(url, { accountid : self.accountId });

    // Setup request with URL and Params
    var requestAPI = request.post(url)
                     .set('Content-Type', 'application/json')
                     .set('Accept', 'application/json')
                     .send(options.spaceCodeBody);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } else {
    var err = {};
    err.message = err.description = 'spaceCodeBody or space_code not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/*options = {
  classCodeBody : {
      class_code: 'string'
  },
  details: boolean    // optional
}*/
function validateClassCode(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  if(options && options.classCodeBody && options.classCodeBody.class_code) {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
                               self.config.AUTH_API_URLS.validateClassCode;
    url = helpers.api.constructAPIUrl(url, { accountid : self.accountId });

    var queryParams = {};
    if (options.details) {
      queryParams.details = options.details;
    }

    // Setup request with URL and Params
    var requestAPI = request.post(url)
                     .set('Content-Type', 'application/json')
                     .set('Accept', 'application/json')
                     .query(queryParams)
                     .send(options.classCodeBody);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } else {
    var err = {};
    err.message = err.description = 'classCodeBody or class_code not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}
/* options = {
  "ignore_words": ["string"] //optional, This is the array of all bad words to be ignored.
}*/
function generateSpaceCode(options) {
  var self = this;

  // Initializing promise
  var dfd = q.defer();

  // Passed all validations, Contruct API url
  var url = self.config.DEFAULT_HOSTS.AUTH +
                              self.config.AUTH_API_URLS.generateSpaceCode;
  url = helpers.api.constructAPIUrl(url, { accountid : self.accountId });

  var bodyParams = {};
  if(options.ignore_words) { bodyParams.ignore_words = options.ignore_words }
  // Setup request with URL and Params
  var requestAPI = request.post(url)
                    .set('Content-Type', 'application/json')
                    .set('Accept', 'application/json')
                    .send(bodyParams);
  if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

  requestAPI.end(function(error, response) {
    if(error) {
      err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
      dfd.reject(err);
    }
    else { dfd.resolve(response); }
  });

  return dfd.promise;
}

/* options = {
  "ext_user_id": "string", //mandatory, This is the actor to change the spacecode.
  "ignore_words": ["string"] //optional, This is the array of all bad words to be ignored.
  "spacecode": "string" //mandatory, This is the spacecode that needs to be changed.
}*/
function changeSpaceCode(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  if(options && options.ext_user_id && options.spacecode) {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
                               self.config.AUTH_API_URLS.changeSpaceCode;
    url = helpers.api.constructAPIUrl(url, { accountid : self.accountId, spacecode: options.spacecode });
    var bodyParams = { ext_user_id: options.ext_user_id };
    if(options.ignore_words) { bodyParams.ignore_words = options.ignore_words }
    // Setup request with URL and Params
    var requestAPI = request.put(url)
                     .set('Content-Type', 'application/json')
                     .set('Accept', 'application/json')
                     .send(bodyParams);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response); }
    });
  } else {
    var err = {};
    err.message = err.description = 'Mandatory parameter options, ext_user_id or spacecode, not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/*
  ext_user_id: 'string',
  ext_role: 'string',
  space_code: 'string',
  ext_email: 'string',       //optional
  ext_first_name: 'string',  //optional
  ext_last_name: 'string,    //optional
  ref_id: 'string'           //optional
*/
function joinInstituteSpace(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  if(options && options.ext_user_id &&
      options.ext_role && options.space_code)
  {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
                               self.config.AUTH_API_URLS.joinInstituteSpace;
    url = helpers.api.constructAPIUrl(url, { accountid : self.accountId });

    // Setup request with URL and Params
    var requestAPI = request.post(url)
                     .set('Content-Type', 'application/json')
                     .set('Accept', 'application/json')
                     .send(options);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } else {
    var err = {};
    err.message = err.description = 'ext_user_id or ext_role or space_code not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/*options = {
    ext_user_id: 'string',
    ext_actor_id: 'string', (optional)
    ext_role: 'string',
    ext_first_name: 'string',
    ext_last_name: 'string',
    ext_email: 'string',
    ref_id: 'string', (optional)
    class_code: 'string' (optional)
    products: [{
      productcode: 'string',
      ext_product_id: 'string',
      ext_product_meta: {
        startdate: 'string',
        enddate: 'string',
        ...
      }
    }]
}*/
function provisionSpacesToStudent(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = {};
  if(options && options.ext_user_id && options.ext_role) {

    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
                              self.config.AUTH_API_URLS.provisionSpacesToStudent;
    url = helpers.api.constructAPIUrl(url, { accountId : self.accountId });

    // Setup request with URL and Params
    var requestAPI = request.post(url)
                    .set('Content-Type', 'application/json')
                    .set('Accept', 'application/json')
                    .send(options);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err.message = err.description = 'ext_user_id or ext_role not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/**
 * This function is used to provision spaces to a user with ext_role as teacher.
 * options = {
 *    ext_user_id: "string",
 *    ext_role: "string",
 *    ext_first_name: "string",
 *    ext_last_name: "string",
 *    ext_email: "string",
 *    ref_id: "string"
 * };
 */
function provisionSpacesToTeacher(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  if(options && options.ext_user_id && options.ext_role)
  {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
                               self.config.AUTH_API_URLS.provisionSpacesToTeacher;
    url = helpers.api.constructAPIUrl(url, { accountId : self.accountId });

    // Setup request with URL and Params
    var requestAPI = request.post(url)
                     .set('Content-Type', 'application/json')
                     .set('Accept', 'application/json')
                     .send(options);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } else {
    var err = {};
    err.message = err.description = 'Mandatory parameters [rxt_user_id, ext_role] not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/**
 * options = {
    "space_title": "string",          // mandatory
    "ext_data": {}                    //optional, external data(e.g. jobdata etc.)
		"users": [												// mandatory, min: 1, max: 200
			{
				"ext_user_id": "string",			// mandatory (it must be unique within users array)
				"ext_parent_id": "string",
				"ext_username": "string",
				"ext_role": "student",				// mandatory
				"ext_email": "string",
				"ext_first_name": "string",   // mandatory
				"ext_last_name": "string",    // mandatory
				"address": "string",
				"rowId": "string",						// mandatory (it must be unique within users array)
				"classes": [									// optional, min: 1, max: 3
					{
						"classid": "string",      // either of classid or class_code them must be
						"class_code": "string"    // present, classid is preferred
					}
        ],
        "products": [									// optional, min: 1
					{
						"productcode": "string",  // mandatory
						"ext_product_meta": {
              "startdate": "epoch",
              "enddate": "epoch"      // mandatory
            }
            "ext_data" : {}           // optional, external data (e.g., ref_id, ...)
					}
				]
			}
		]
	}
 *
 */
function provisionBulkSpaces(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.users && options.space_title) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
      self.config.AUTH_API_URLS.provisionBulkSpaces;
      url = helpers.api.constructAPIUrl(url, { orgId : self.orgId });

      // Setup request with URL and Params
      var requestAPI = request.post(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
			.send(options);

      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
			requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

			requestAPI.end(function(error, response) {
				if(error) {
					err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
					dfd.reject(err);
				}
				else { dfd.resolve(response.body); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory parameters: space_title or users not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
	}

	return dfd.promise;
}

/**
 * options = {
 *  ext_user_id: 'string',      // mandatory
 * "ext_role": "string",        // mandatory
 * "ext_first_name": "string",
 * "ext_last_name": "string",
 * "ext_email": "string",
 * "address": {
 *  "country": "string"
 * },
 * "ref_id": "string",
 * "ext_classid" : "string",
 * "ext_class_meta" :
 *  {
 *    "description": "string",
 *    "ext_data": {},
 *    "title": "string",       // mandatory
 *    "startdate": <epoch>,   // mandatory
 *    "enddate": <epoch>      // mandatory
 *  }
 * }
 **/
function shadowProvision(options) {
  var self = this;
  //Initializing promise
  var dfd = q.defer(), err = {};
  //Validations
  if (options && options.ext_user_id && options.ext_role) {
    //Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.shadowProvision;
    url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

    // Setup request with URL and Params
    var requestAPI = request.post(url)
    .set('Content-Type', 'application/json')
    .set('Accept', 'application/json')
    .send(options);
    if (self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if (err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err.message = err.description = 'Mandatory parameters: ext_user_id or ext_role not ' +
      'found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/*options = {
    ext_user_id: 'string',
    ext_actor_id: 'string',
    ext_role: 'string',
    ref_id: 'string', (optional)
    productcode: 'string',
    ext_product_id: 'string',
    ext_product_meta: {
      startdate: 'string',
      enddate: 'string',
      ...
    },
    audit: boolean
}*/
function entitleUserToProduct(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  if(options && options.ext_user_id &&
      options.ext_role && (options.productcode || options.ext_product_id))
  {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
                               self.config.AUTH_API_URLS.entitleUserToProduct;
    url = helpers.api.constructAPIUrl(url, { accountId : self.accountId });

    // Setup request with URL and Params
    var requestAPI = request.post(url)
                     .set('Content-Type', 'application/json')
                     .set('Accept', 'application/json')
                     .send(options);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } else {
    var err = {};
    err.description = 'Missing mandatory keys in request options. \'ext_user_id\', \'ext_role\' and ' +
                      'either of \'ext_product_id\' or \'productcode\' must be present.'
    err.message = err.description;
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/*options = {
    ext_user_id: 'string',
    ext_actor_id: 'string',
    productcode: 'string',
    audit: 'boolean'
}*/
function unentitleUserToProduct(options) {
  var self = this;
  var dfd = q.defer();

  if (options && options.ext_user_id && options.productcode && options.ext_actor_id
    && (options.audit !== undefined)) {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.entitleUserToProduct;
    url = helpers.api.constructAPIUrl(url, { accountId : self.accountId });

    // Setup request with URL and Params
    var requestAPI = request.delete(url)
                    .set('Content-Type', 'application/json')
                    .set('Accept', 'application/json')
                    .send(options);

    if (self.traceid) {
      requestAPI.set('X-Amzn-Trace-Id', self.traceid);
    }

    requestAPI.end(function(error, response) {
      if (error) {
        var err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else {
        dfd.resolve(response.body);
      }
    });
  } else {
    var err = {};
    err.message = err.description = 'Missing mandatory keys in request options.' +
                  ' \'ext_user_id\', \'ext_actor_id\', \'productcode\' and \'audit\'' +
                  ' must be present';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);

    dfd.reject(err);
  }

  return dfd.promise;
}

/* This function calls the ComproDLS API to micro entitle user to a product.
options = {
    "ext_user_id": "string",    // Mandatory
    "ext_actor_id": "string",   // Optional
    "feature_key": "string",    // Mandatory
    "feature_id": "string",     // Mandatory
    "context": "string",        // Mandatory
    "data": {},                 // Optional
    "productcode": "string",    // one of productcode and ext_product_id is mandatory
    "ext_product_id": "string",
    "ext_entitlement_meta": {    //Optional
      "startdate": "epoch",
      "enddate": "epoch"       //mandatory, if ext_entitlement_meta provided.
    },
    "audit": boolean            // Optional
}*/
function microEntitleUserToProduct(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var bValidOptions = true;
  var err = {
    description: '',
    message: ''
  };

  if (!(options && options.ext_user_id && options.context && options.feature_key &&
    options.feature_id)) {
    bValidOptions = false;
    err.description = 'ext_user_id or context or feature_key or feature_id ' +
      'not found in request options. ';
  }

  if (bValidOptions && (options.productcode || options.ext_product_id)) {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
                               self.config.AUTH_API_URLS.microEntitleUserToProduct;
    url = helpers.api.constructAPIUrl(url, { accountId : self.accountId });

    // Setup request with URL and Params
    var requestAPI = request.post(url)
                     .set('Content-Type', 'application/json')
                     .set('Accept', 'application/json')
                     .send(options);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } else {
    if(!(options.productcode || options.ext_product_id)) {
      err.description += 'Either of ext_product_id or productcode must be ' +
                                      'present in request options.';
    }
    err.message = err.description;
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/* This function calls the ComproDLS API to micro entitle user to product.
options = {
    "micro-entitlements": [{    // Mandatory, Min: 1
    "ext_user_id": "string",    // Mandatory

    "productcode": "string",
    "ext_product_id": "string",

    "context": "string",
    "feature_key": "string",
    "feature_id": "string",,
    "data": {},
    "ext_entitlement_meta": {
      "startdate": 0,
      "enddate": 0
    },

    "ext_actor_id": "string",        // Mandatory if 'audit' is true
    "audit": true
    },
  â€¦
  ]
}
*/
function bulkMicroEntitleProductToUser(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  if(options && options['micro-entitlements'])
  {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
                               self.config.AUTH_API_URLS.bulkMicroEntitleProductToUser;
    url = helpers.api.constructAPIUrl(url, { accountId : self.accountId });

    // Setup request with URL and Params
    var requestAPI = request.post(url)
                     .set('Content-Type', 'application/json')
                     .set('Accept', 'application/json')
                     .send(options);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } else {
    var err = {};
    err.description = 'Missing mandatory keys in request options.' +
      ' \'micro-entitlements\' must be present.'
    err.message = err.description;
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/* This function calls the ComproDLS API to revoke micro entitlement of a user.
options = {
    "ext_user_id": "string",    // Mandatory
    "ext_actor_id": "string",   // Mandatory
    "feature_key": "string",    // Mandatory
    "context": "string",        // Mandatory
    "productcode": "string",    // one of productcode and ext_product_id is mandatory
    "ext_product_id": "string",
    "audit": boolean            // Mandatory
}*/
function revokeMicroEntitlementOfAUser(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = {
    description: '',
    message: ''
  };

  if((options && options.ext_user_id && options.context && options.feature_key &&
    options.ext_actor_id && (options.audit !== undefined) &&
    (options.productcode || options.ext_product_id))) {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
              self.config.AUTH_API_URLS.microEntitleUserToProduct;
    url = helpers.api.constructAPIUrl(url, { accountId : self.accountId });

    // Setup request with URL and Params
    var requestAPI = request.delete(url)
                    .set('Content-Type', 'application/json')
                    .set('Accept', 'application/json')
                    .send(options);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err.description = 'ext_user_id or context or feature_key or ext_actor_id or audit field ' +
                      'not found or is empty in request options. Either productcode or ' +
                      'ext_product_id must be provided.';
    err.message = err.description;
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/*options = {
    ext_product_id: 'string'
}*/
function getExtProduct(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  if(options && options.ext_product_id)
  {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
                               self.config.AUTH_API_URLS.getExtProductAPI;
    url = helpers.api.constructAPIUrl(url, { accountId : self.accountId, extProductId: options.ext_product_id});

    // Setup request with URL and Params
    var requestAPI = request.get(url);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } else {
    var err = {};
    err.message = err.description = 'ext_product_id not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/*options = {
    spacekey: 'string'
}*/
function getSpaceDetails(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  if(options && options.spacekey) {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.getSpaceDetails;
    url = helpers.api.constructAPIUrl(url, { accountId : self.accountId, spacekey: options.spacekey});

    var params = { orgid: self.orgId };

    // Setup request with URL and Params
    var requestAPI = request.get(url).query(params);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    // Setup token in Authorization header
    requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } else {
    var err = {};
    err.message = err.description = 'spacekey not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/*options = {
    ext_user_id: 'string',
    ext_role: 'string',
    ext_first_name: 'string',
    ext_last_name: 'string',
    ext_email: 'string',
    ref_id: 'string', (optional)
    class_code: 'string'
}*/
function enrollUserInClass(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  if(options && options.ext_user_id &&
      options.ext_role && options.class_code)
  {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
                               self.config.AUTH_API_URLS.enrollUserInClass;
    url = helpers.api.constructAPIUrl(url, { accountId : self.accountId });

    // Setup request with URL and Params
    var requestAPI = request.post(url)
                     .set('Content-Type', 'application/json')
                     .set('Accept', 'application/json')
                     .send(options);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } else {
    var err = {};
    err.message = err.description = 'ext_user_id or ext_role or class_code not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/**
 * This function calls the ComproDLS API to update user information.
 * options = {
 *    "ext_user_id": "string",
 *    "ref_id": "string",           // optional
 *    "ext_email": "string",        // optional
 *    "ext_first_name": "string",   // optional
 *    "ext_last_name": "string"     // optional
 * };
 */
function updateUserInformation(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer(), err = {};

  if(options && options.ext_user_id)
  {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
                               self.config.AUTH_API_URLS.updateUserInformation;
    url = helpers.api.constructAPIUrl(url, { accountId : self.accountId });
    var bodyParams = {
      ext_user_id: options.ext_user_id
    };
    if(options.ref_id) { bodyParams.ref_id = options.ref_id; }
    if(options.ext_email) { bodyParams.ext_email = options.ext_email; }
    if(options.ext_first_name) { bodyParams.ext_first_name = options.ext_first_name; }
    if(options.ext_last_name) { bodyParams.ext_last_name = options.ext_last_name; }
    if(options.address) { bodyParams.address = options.address; }
    // Setup request with URL and Params
    var requestAPI = request.put(url)
                     .set('Content-Type', 'application/json')
                     .set('Accept', 'application/json')
                     .send(bodyParams);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } else {
    err.message = err.description = 'Mandatory parameters not found in request options:' +
                                    ' ["ext_user_id"]';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/* options = {
   "email": "string", // required
   "status " : "string", // optional
  };
*/
function getInvitationsByEmail(options) {
	var self = this;
	// Initializing promise
	var dfd = q.defer();
	var err = {};
	if (options && options.email) {

	  // Passed all validations, Contruct API url
	  var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.getInvitationsByEmail;
	  url = helpers.api.constructAPIUrl(url, { accountid: self.accountId });

	  var queryParam = { email: options.email };
	  if (options.status) { queryParam.status = options.status; }

	  // Setup request with URL and Params
    var requestAPI = request.get(url).query(queryParam);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

	  requestAPI.end(function (error, response) {
	  	if (error) {
		  err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
		  dfd.reject(err);
		}
		else { dfd.resolve(response.body); }
	  });
	}
	else {
	  err.message = err.description = 'email not found in request options.';
	  err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
	  dfd.reject(err);
	}
	return dfd.promise;
}

/**
 * This API is used to update an institute's space title
 * options = {
 *   space_code: "",       // Mandatory, space code of institute whose title is to be updated
 *   body : {
 *     ext_actor_id: "",   // Mandatory
 *     data: {
 *       space_title: ""
 *     }
 *   }
 * }
 */
function updateInstituteTitle(options){
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = {};
  if (options && options.space_code && options.body && options.body.ext_actor_id ) {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.updateInstituteTitle;
    url = helpers.api.constructAPIUrl(url,
      { accountId: self.accountId, instituteSpaceCode: options.space_code });

    // Setup request with URL and Params
    var requestAPI = request.put(url)
                    .set('Content-Type', 'application/json')
                    .set('Accept', 'application/json')
                    .send(options.body);
    if (self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (error, response) {
      if (error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err.message = err.description = 'space_code or ext_actor_id not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}
