/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

/***********************************************************
 * comproDLS SDK xAPI Adaptor
 * Functions for calling xAPI.
 ************************************************************/

/*********************************
 * Setting Up Module Entry Point  
 **********************************/

var q = require('q');
var request = require('superagent');

var helpers = require('../../helpers');
var DLSError = helpers.errors.DLSError;

module.exports = xapi;

/*********************************
 * Public Function definitions
 **********************************/
function xapi(accountId) {
  this.accountId = accountId;
  return {
    postStatement: postStatements.bind(this),
    postExternalStatements: postExternalStatements.bind(this),
    resetUserProductProgress: resetUserProductProgress.bind(this)
  };
}

/*
options = {
  actor: {
    uuid: 'string', // userid of user posting statement / 'me'
    group: 'string' // (optional)
  },
  product: { // optional
    code: 'string',
    title: 'string' // (optional)
    ext-item: boolean  // (optional, all items in entities will be treated as external items, hence no progress JSON update for them)
  },
  classid: 'string', // (optional) Specify if posting via class,
  space_key: 'string'// (optional)

  entities: [{
    assigned_path_id: 'string' //optional, assigned-path of a class
    timestamp: 0,
    verb: 'string', // [redo | evaluated | launched | interacted | completed | answered | attempted | scored | submitted']
          //('redo' verb can only be sent by teacher, admin and superadmin )
    model: 'string', // (optional) model hierarchy of resource if available
    item-code: 'string', // item-code of resource(optional)
    user_data: {
        documentid: 'string',
        folderid: 'string',
        action: 'create/update/delete',
        type: 'string',
        payload: 'string'
    },
    timespent: 0, // (optional)
    activity_status: 'string', // (optional) ['in_process', 'timed_out', 'completed']
    result: { // (optional)
      response: {
          audioPath: 'string',
          text: 'string',
          link: [
            {
              url: 'string',
              title: 'string',
              description: 'string'
            }
          ],
          attribs: {}
      },
      score: { // optional
        min: 0,
        scaled: 0,
        max: 0,
        raw: 0
      },
      comment: 'string', // optional
      questions: [{ // optional
        question-code: 'string',
        status-progress: 'string',  // [not_attempted | in_progress]
        status-evaluation: 'string' // [not_applicable | partially_correct | correct | incorrect]
      }]
    },
    link-statementid: 'string' // required in case of verb = evaluated
  }],
  platform: {
    ua: 'string',
    sessionid: 'string'
  }
};
*/
function postStatements(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();
  //Validations
  var err = {}, url;

  err = helpers.validations.isAuthenticated(self.orgId, self.token);
	if(err) { dfd.reject(err); }
  else {
    url = self.config.DEFAULT_HOSTS.XAPI +
          self.config.XAPI_API_URLS.postMultiStatements;
    url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });
		//Passed all validations, Construct API url

		var params = options;

		//Setup request with URL and Params
    var requestAPI = request.post(url).send(params);

		//Setup token in Authorization header
    requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

		//Call Product Timespent Api

		requestAPI.end(function(err, response) {
      if(err) {
				err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
				dfd.reject(err);
			}
      else { dfd.resolve(response.body); }
		});
	}
  return dfd.promise;
}

/*
options = {
  actor: {
    ext_user_id: 'string', // (optional) who triggered the action - EXTERNAL_SYSTEM in case of verb = evaluated_external
    uuid: 'string' // who triggered the action - EXTERNAL_SYSTEM in case of verb = evaluated_external
  },
  product: {
    code: 'string',
    title: 'string' // (optional)
    ext-item: boolean  // (optional, all items in entities will be treated as external items, hence no progress JSON update for them)
  },
  student_userid: "string", // (optional when verb = submitted_external) ON whom is the action taking place
  student_ext_user_id: "string", // (optional when verb = submitted_external) ON whom is the action taking place
  classid: 'string', // (optional) Specify if posting via class
  space_key: 'string', // (optional)
  platform: {
    ua: "string"
  },
  group: {           // (optional)
    id: "string"
  }
  entities: [{
    assigned_path_id: 'string' //(optional) assigned-path of a class
    timestamp: 0,
    verb: 'string', // [evaluated_external, submitted_external]
    model: 'string', // (optional) model hierarchy of resource if available
    item-code: 'string', // item-code of resource
    timespent: 0, // (optional)
    part: integer, // (mandatory only for verb = evaluated_external)
    submission_order: integer, //  [1, 2, 3]
    result: { // (optional)
      "response": {
        "text": "string",
        "audioPath": "string",
        "link": [
          {
            "url": "string",
            "title": "string",
            "description": "string"
          }
        ]
      },
      "score": {
        "min": 0,
        "scaled": 0,
        "max": 0,
        "raw": 0
      },
      "comment": "string",  // (optional)
      "ext_data": "string", // (optional)
      questions: [{         // (optional)
        question-code: 'string',
        status-progress: 'string',  // [not_attempted | in_progress]
        status-evaluation: 'string' // [not_applicable | partially_correct | correct | incorrect]
      }]
    }
  }]
}
*/
function postExternalStatements(options) {
  var self = this;
  var dfd = q.defer();

  var url = self.config.DEFAULT_HOSTS.XAPI + self.config.XAPI_API_URLS.postExternalMultiStatements;
  url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });
  //Passed all validations, Construct API url

  //Setup request with URL and Params
  var requestAPI = request.post(url).send(options);

  if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

  //Call Product Timespent Api

  requestAPI.end(function(err, response) {
    if(err) {
      err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
      dfd.reject(err);
    }
    else { dfd.resolve(response.body); }
  });
  return dfd.promise;
}

/*options = {
    userid: 'string',
    productcode: 'string',
    actorid: 'string'
}*/
function resetUserProductProgress(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = {};
  if(options && options.userid && options.productcode && options.actorid) {

    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.XAPI + self.config.XAPI_API_URLS.resetUserProductProgress;
    url = helpers.api.constructAPIUrl(url, { accountId : self.accountId });

    // Setup request with URL and Params
    var requestAPI = request.delete(url)
                    .set('Content-Type', 'application/json')
                    .set('Accept', 'application/json')
                    .send(options);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err.message = err.description = 'userid, productcode or actorid not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}
