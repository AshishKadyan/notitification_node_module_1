var q = require('q');
var pubNub = require("pubnub");

var sessionManager = require('./sessionStorage');
var EventEmitter = require("events").EventEmitter;
var _und = require('underscore');

var EVENTS = {
    //Events to emit
    "USER_CHANGED": "presenceupdate", //Presense update (changes only)
    "COLLAB_EVENT": "collab", //Collaboration event (Message / Post / Announcement)
    "ACTIVITY_EVENT": "activity", //Assessment / Test / Activity event (Timeout)
    "JOB_EVENT": "job", //Job status
    "SYSTEM_EVENT": "systemevents", // comproDLS System Events

    //Events to listen
    "ACTIVEROOM": "activeroom"
};

var PRESENCE_ACTION = {
    "JOIN": "join",
    "LEAVE": "leave",
    "TIMEOUT": "timeout",
    "INTERVAL": "interval"
};

/**
 * Clientwrapper module.
 * Purpose -  Wrapper around the Saas client SDK (PubNub). Abstracts the provider/vendor (PubNun) specific
 * implementation details - allowing future switch (to a different Saas provider).
 */
module.exports = (function () {
    "use strict";

    /** ====== MODULE GLOBALS */
    var _pubnubClient; //SAAS provider client SDK (PubNub).
    var _notifications = new EventEmitter();
    var _currentUser;
    /**
     * A map to store the presence stats of all the users in my group (including me).
     *
     * @key {string} groupid - an identifier for unique group / sections.
     * @value {object} - information (userid, state, device_count) of occupants.
     */
    var _mapGroupPresence = {};
    var _mapSubscribePromise = {};


    /** ###### END OF MODULE GLOBALS */

    /** ====== UTILITY FUNCTIONS */

    /**
     * This function performs a deep cloning of a JSON object.
     *
     * @param data (JSON) : A json object that needs to be deep cloned.
     */
    var _deepClone = function(data) {
        return JSON.parse(JSON.stringify(data));
    };


    /**
     * This function is used to get device id.
     * @returns device id {integer} - device id for the current tab / device.
     */
    var _getDeviceId = function() {
        var sessionUserInfo;
        var sessionStorageData = sessionManager.getData(); // Get user information for the curret session.
        if(!sessionStorageData.error) {
            sessionUserInfo = sessionStorageData.data;
        }
        if(sessionUserInfo) {
            return sessionUserInfo.deviceId;
        } else {
            return Math.floor(100000 + Math.random() * 900000); // create new device id.
        }
    };

    var _notify = function(eventName, eventData) {
        _notifications.emit(eventName, eventData);
    };


    var _translatePubnubMessage = function(pubNubEventData) {
        var eventName = pubNubEventData.userMetadata.channel.split("push:")[1];
        var message = pubNubEventData.message;
        switch (eventName) {
            case EVENTS.COLLAB_EVENT:
            case EVENTS.ACTIVITY_EVENT:
            case EVENTS.JOB_EVENT:
            case EVENTS.SYSTEM_EVENT:
                _notify(eventName, message);
                break;
        }
    };

    var _translatePubnubPresence = function(pubNubEventData) {
        var eventName = EVENTS.USER_CHANGED;
        var orgId = _currentUser.orgId;
        var userId = pubNubEventData.uuid ? pubNubEventData.uuid.split(":")[0] : undefined;
        var deviceId = pubNubEventData.uuid ? pubNubEventData.uuid.split(":")[1] : undefined;
        var eventData = {
            orgid: orgId,
            actor: userId,
            context : 'everywhere'
        };
        var userInfo;

        switch (pubNubEventData.action){
            case PRESENCE_ACTION.JOIN:
                /**
                 * Increment the device_count for existing user and create a new entry for
                 * first time user login.
                 */
                if(parseInt(deviceId) !== _currentUser.deviceId) {
                    _updateGroupPresenceMap(PRESENCE_ACTION.JOIN, orgId, userId,
                                            pubNubEventData);
                    userInfo = _mapGroupPresence[orgId].occupants[userId];
                    if(userInfo.device_count === 1) {
                        eventData.verb = 'online';
                        _notify(eventName, eventData);
                    }
                } else {
                    // Presence event received for own device - IGNORING
                }
                break;
            case PRESENCE_ACTION.LEAVE:
                /**
                 * Decrement the device_count for the user.
                 */
                if(parseInt(deviceId) !== _currentUser.deviceId) {
                    _updateGroupPresenceMap(PRESENCE_ACTION.LEAVE, orgId, userId,
                                            pubNubEventData);
                    if(_mapGroupPresence[orgId].occupants[userId].device_count === 0) {
                        /**
                         * User left from all the devices. Propagate LEAVE event to reference app.
                         * Cleaning _mapGroupPresence for this user.
                         */
                        delete _mapGroupPresence[orgId].occupants[userId];
                        eventData.verb = 'offline';
                        _notify(eventName, eventData);
                    }
                } else {
                    // Presence event received for own device - IGNORING
                }
                break;
            case PRESENCE_ACTION.TIMEOUT:
                /**
                 * Decrement the device_count for the user.
                 */
                if(parseInt(deviceId) !== _currentUser.deviceId) {
                    _updateGroupPresenceMap(PRESENCE_ACTION.TIMEOUT, orgId, userId,
                                            pubNubEventData);
                    if(_mapGroupPresence[orgId].occupants[userId].device_count === 0) {
                        /**
                         * User left / timed-out from all the devices. Propagate LEAVE event to
                         * reference app. There is no difference between leave / timeout for
                         * reference application.
                         *
                         * Cleaning _mapGroupPresence for this user.
                         */
                        delete _mapGroupPresence[orgId].occupants[userId];
                        eventData.verb = 'offline';
                        _notify(eventName, eventData);
                    }
                } else {
                    // Presence event received for own device - IGNORING
                }
                break;
            case PRESENCE_ACTION.INTERVAL:
                /**
                 * An interval message is received from pubnub on reaching the ANNOUNCE-MAX
                 * setting. If the number of occupants in a group is greater than or equal to
                 * ANNOUNCE-MAX, then pubnub stops sending presence messages for actions JOIN,
                 * LEAVE, TIMEOUT.
                 *
                 * The interval message has array of users (userids) that joined, left and
                 * timed-out in a predefined interval.
                 */
                _splitPresenceIntervalEvent(pubNubEventData);
                break;
        }
    };


    /**
     * This function creates a presence event.
     * The structure of this event is similar to pubnub's presence event.
     */
    var _constructPresenceEvent = function(event, userid, action) {
        return {
            "channel": event.channel, "subscription": event.subscription,
            "actualChannel": event.actualChannel,
            "subscribedChannel": event.subscribedChannel,
            "timetoken": event.timetoken,
            "occupancy": event.occupancy,
            "timestamp": event.timestamp,
            "action": action,
            "uuid": userid
        };
    };

    /**
     * This function is used to update the _mapGroupPresence for presence events.
     *
     * @param action - Presence action - [KOIN, LEAVE, TIMEOUT, INTERVAL].
     * @param channel - groupid of the group for which the presence event occured.
     * @param userid - (optional) userid of user for whom the event occured.
     * @param event - event data.
     */
    var _updateGroupPresenceMap = function(action, channel, userid) {
        switch(action) {
            case PRESENCE_ACTION.JOIN:
                if(_mapGroupPresence[channel].occupants[userid]) {
                    // User already logged-in from other device.
                    _mapGroupPresence[channel].occupants[userid].device_count += 1;
                } else { // First time log-in.
                    _mapGroupPresence[channel].occupants[userid] = {
                        "device_count": 1
                    };
                }
                if(_mapGroupPresence[channel].occupants[userid].device_count === 1) {
                    _mapGroupPresence[channel].occupancy += 1;
                }
                break;
            case PRESENCE_ACTION.LEAVE:
            case PRESENCE_ACTION.TIMEOUT:
                if(_mapGroupPresence[channel].occupants[userid]) {
                    _mapGroupPresence[channel].occupants[userid].device_count -= 1;
                    if(_mapGroupPresence[channel].occupants[userid].device_count === 0) {
                        _mapGroupPresence[channel].occupancy -= 1;
                    }
                }
                break;
        }
    };

    /**
     * This function translates the interval event for each user into individual
     * JOIN or LEAVE or TIMEOUT event as received from pubnub.
     *
     * For the reference application there are only four presence actions
     * [JOIN, LEAVE, TIMEOUT, STATE-CHANGE].
     */
    var _splitPresenceIntervalEvent = function(eventData) {
        var joinedUsers = eventData.join;
        var leftUsers = eventData.leave;
        var timeoutUsers = eventData.timeout;
        if(joinedUsers) {
            for(var i in joinedUsers) {
                var joinEvent = _constructPresenceEvent(eventData, joinedUsers[i], "join");
                _translatePubnubPresence(joinEvent);
            }
        }
        if(leftUsers) {
            for(var j in leftUsers) {
                var leftEvent = _constructPresenceEvent(eventData, leftUsers[j], "leave");
                _translatePubnubPresence(leftEvent);
            }
        }
        if(timeoutUsers) {
            for(var k in timeoutUsers) {
                var timeoutEvent = _constructPresenceEvent(eventData, timeoutUsers[k],
                                                           "timeout");
                _translatePubnubPresence(timeoutEvent);
            }
        }
    };

    /**
    * Sets up necessary subscriptions (Pub/Sub) to PUSH channels. To a large extent, subscriptions are
    * driven the student's (instructor's) roster.
    * @param {object} groups - Roster information, provided during initialization, wrapper.setup().
    */
    var _subscribeToPubNubChannels = function(options) {
        _pubnubClient.subscribe({ // Calling Pubnub SDK
            "channels": [options.orgId],
            "withPresence": true
        });
        _pubnubClient.subscribe({ // Calling Pubnub SDK
            channels: [options.orgId + '.' + options.userId]
        });
    };

    /**
    * Call this function to make a new client adaptor.
      This adapter exposes functions to send message, update user state etc.
    * @return (object) : client adapter.
    */
    var _constructClientAdaptor = function() {
        //Returning the adaptor (Plain Javascript object)
        return {
            "getOnlineMembers": __getOnlineMembers,
            "joinClass": __joinClass,
            "joinProduct": __joinProduct,
            "joinGroup": __joinGroup,
            "on": _notifications.on.bind(_notifications),
            "emit": _notifications.emit.bind(_notifications)
        };
    };

    /**
     * This function converts unix epoch timestamp (ms) to pubnub's timetoken.
     *
     * @params {integer} timestamp - unix epoch timestamp (ms)
     *
     * @returns {string} - Pubnub's timetoken (timestamp = timetoken / 10000).
     */
    var _getPubnubTimeToken = function(timestamp) {
        return (timestamp * 10000).toString();
    };

    /**
     * This function converts pubnub's timetoken to unix epoch timestamp (ms).
     *
     * @params {string} timetoken - Pubnub's timetoken (timestamp = timetoken / 10000).
     *
     * @returns {integer} - unix epoch timestamp (ms).
     */
    var _getEpochTimestamp = function(timetoken) {
        return Math.round(parseInt(timetoken) / 10000);
    };


    /** ###### END OF UTILITY FUNCTIONS ############ */

    /** ====== Main Adapter Member functions ==> Mapped to Public Methods */

    /**
    * Gets Presence information (and state) for student's (instructor's) roster. Offline users are
      not support/included in this version.
    * @param {Array} groups - Roster information, provided during initialization, wrapper.setup().
    * @param {function} cbSuccess - (Optional) A function that accepts a single argument,
                                               which is an object having group level logged-in
                                               user's presence information.
    * @param {function} cbFailure - (Optional) A function that accepts an error object
                                               with statusCode and relavent message.
    */
    var __getOnlineMembers = function (groups, cbSuccess, cbFailure) {
        var responseObj = {};
        if(_und.isEmpty(_mapGroupPresence)) {
            /**
             * _mapGroupPresence is undefined, call pubnub for initialization.
             */
            _mapGroupPresence = {}; // Reset _mapGroupPresence.
            for(var i in groups) {
                _mapGroupPresence[groups[i]] = {
                    "occupants": {}, "name": groups[i], "occupancy": 1
                };
                _mapGroupPresence[groups[i]].occupants[_currentUser.userId] = {
                    "device_count": 1
                };
            }
            _pubnubClient.hereNow({
                "channels": groups,
                "includeUUIDs": true
            }, function(status, response) {
                if(status.error) {
                    if(cbFailure && typeof cbFailure === "function") {
                        cbFailure(status);
                    }
                } else {

                    if(cbSuccess && typeof cbSuccess === "function") {
                        /**
                        * Success callback parameter "response.channels" contains
                        * information on the 'online' users in a group.
                        * For Example:
                        * {
                        *   "course_3": { // group name.
                        *       "occupants": [{ // user info array (array of objects).
                        *           "uuid": "102-<device id>"   // Pubnub user uuid
                        *       }],
                        *       "name": "course_3", //group name
                        *       "occupancy": 1      //Total number of logged-in users in this group.
                        *   }
                        * }
                        */
                        for(var channel in response.channels) {
                            var users = response.channels[channel].occupants;
                            for(var j in users) {
                                var userid = users[j].uuid.split(":")[0];
                                var device_id = users[j].uuid.split(":")[1];
                                if(!_mapGroupPresence[channel].occupants[userid]) {
                                    _mapGroupPresence[channel].occupancy += 1;
                                    _mapGroupPresence[channel].occupants[userid] = {
                                        "device_count": 1
                                    };
                                } else {
                                    if(parseInt(device_id) !== _currentUser.deviceId) {
                                        _mapGroupPresence[channel].occupants[userid].device_count += 1;
                                    }
                                }
                            }
                        }

                        /**
                        * Translated _mapGroupPresence structure
                        * {
                        *   "course_3": { // group name.
                        *       "occupants": { // user info array (array of objects).
                        *           "102": {
                        *               "state": { // state of a user.
                        *                   "isTyping": false,      //Typing state
                        *                   "state": "AVAILABLE",   //User online status
                        *                   "first_name": "Albert",
                        *                   "first_name": "Smith"
                        *               },
                        *               "device_count": 2
                        *           }
                        *       },
                        *       "name": "course_3", //group name
                        *       "occupancy": 1      //Total number of logged-in users in this group.
                        *   }
                        * }
                        */

                        // Returning a copy of _mapGroupPresence
                        for(var index in groups) {
                            responseObj[groups[index]] = _mapGroupPresence[groups[index]];
                        }
                        cbSuccess(_deepClone(responseObj));

                    }
                }
            });
        } else {
            // Returning a copy of _mapGroupPresence
            for(var index in groups) {
                responseObj[groups[index]] = _mapGroupPresence[groups[index]];
            }
            cbSuccess(_deepClone(responseObj));
        }
    };

    var __joinClass = function(uuid) {
        var dfd = q.defer();
        _mapSubscribePromise[_currentUser.orgId + '.' + uuid] = dfd;
        _pubnubClient.subscribe({ // Calling Pubnub SDK
            channels: [_currentUser.orgId + '.' + uuid]
        });
        return dfd.promise;
    };

    var __joinProduct = function(uuid) {
        var dfd = q.defer();
        _mapSubscribePromise[_currentUser.orgId + '.' + uuid] = dfd;
        _pubnubClient.subscribe({ // Calling Pubnub SDK
            channels: [_currentUser.orgId + '.' + uuid]
        });
        return dfd.promise;
    };

    var __joinGroup = function(uuid) {
        var dfd = q.defer();
        _mapSubscribePromise[_currentUser.orgId + '.' + uuid] = dfd;
        _pubnubClient.subscribe({ // Calling Pubnub SDK
            channels: [_currentUser.orgId + '.' + uuid]
        });
        return dfd.promise;
    };

    /** ###### End Of Main Adapter Member functions ############ */

    /** ====== Client Wrapper Member functions ==> Mapped to Public Methods */

    /**
    * Initializes the library, and established a connection with the Saas/PUSH provider. Setup should be
    * called only once i.e. ONE CONNECTION (on a page/tab) is allowed at a time. If called again, it will throw
    * an error (failure callback)
    * @param {string} grantEndPoint - The API endpoint that will return the roster data for the user.
    * @param {object} currentUser - (Optional) If this param is available, then the user is already logged in another
    *                                tab or has refreshed the tab. Grant API will not be called.
    * @param {object} mediaOptions - Contains media-stream-manager configurations (mode), publisher and subscriber
    *                                stream DOM id.
    * @param {function} cbSuccess - Success callback. A function that accepts a single argument which is the adapter
                                    object for further operations.
    * @param {function} cbFailure - Failure callback. A function that accepts a single argument which is an
                                    error object with more information
    */
    var __setup = function (currentUser) {
        var dfd = q.defer();

        var bInitialized = false; // Flag to track when PubNub SDK is initialized. By default FALSE.
        var deviceId, pubnubConfig = currentUser.pubnub;

        if(!_pubnubClient && currentUser) {
            deviceId = _getDeviceId();
            currentUser.deviceId = deviceId;
            /*pubnubConfig.authKey = currentUser.auth_token;*/
            pubnubConfig.uuid = currentUser.userId + ":" + deviceId;
            _pubnubClient = new pubNub(pubnubConfig); //Connect with PubNub SDK
            processSetup();
        }

        function processSetup() {
            _currentUser = currentUser;
            _pubnubClient.addListener({ //Setup Listeners (events will shows up after subscription)
                "message": function (data) { _translatePubnubMessage(data); },
                "presence": function (data) { _translatePubnubPresence(data); },
                "status": function (status) {
                    switch(status.category) {
                        /*
                            Per PubNub Support...

                            There is 'no' separate event to monitor a successful connection with PubNub.
                            Instead we need to use PNConnectedCategory event post subscription to a
                            channel.
                        */
                        case "PNConnectedCategory":
                            if(!bInitialized) { // Initialization. The first Connect event is when PubNub is being initialized
                                __getOnlineMembers(
                                    [currentUser.orgId],
                                    function success() {
                                        dfd.resolve(_constructClientAdaptor());
                                    },
                                    function failure(err) {
                                        dfd.reject(err);
                                    }
                                );
                            } else { //TODO Handle posting initialization Connect events

                            }
                            break;
                        case "PNBadRequestCategory":
                        case "PNAccessDeniedCategory":
                            if(!bInitialized) { // Initialization. The first Connect event is when PubNub is being initialized
                                dfd.reject(status);
                            } else {
                                //TODO Handle posting initialization Connect events
                            }
                            break;
                    }
                }
            });

            _subscribeToPubNubChannels(currentUser); //Subscribe channels (roster)
        }
        return dfd.promise;

    }; //End of _setup()

    var __cleanup = function () {
        if(_pubnubClient) { //Skip cleanup if setup() was not called.
            _pubnubClient.unsubscribeAll();
            _pubnubClient.stop();
            sessionManager.removeData();
        }
    };

    return { // Return public methods for the wrapper
        "setup": __setup,
        "cleanup": __cleanup
    };

})(); //End of Client Wrapper module
