/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

/***********************************************************
 * comproDLS SDK PUSH Adaptor
 * Functions for calling PUSH.
 ************************************************************/
 
var EventEmitter = require("events").EventEmitter;
var io = require('socket.io-client');
var q = require('q');

var helpers = require('../../helpers');
var DLSError = helpers.errors.DLSError;
 
/*********************************
 * Setting Up Module Entry Point  
 **********************************/
module.exports = push;

/*********************************
 * Public Function definitions
 **********************************/
function push() {
    return {
        "connect": _connect.bind(this)
    };
}

/*********************************
 * Public Function definitions
 **********************************/
function _connect(orgId, userId) {
    //Reference to comproDLS SDK object, containing the token
    var self = this;

    //Initializing promise
    var dfd = q.defer();

    //Notification Event Constants
    var EVENTS = {
        //Events to listen
        "CONNECT": "push_connect", // Connection established
        "CONNECT_ERROR": "push_error", // Connection established
        "USER_NEW": "presence", // First time presence (all online users)
        "USER_CHANGED": "presenceupdate", //Presense update (changes only)
        "COLLAB_EVENT": "collab", //Collaboration event (Message / Post / Announcement)
        "ACTIVITY_EVENT": "activity", //Assessment / Test / Activity event (Timeout)
		"JOB_EVENT": "job", //Job status
        "SYSTEM_EVENT": "systemevents", // comproDLS System Events
        "ERROR": "error", // Custom Error of Push-Service

        //Events to emit
        "ACTIVEROOM": "activeroom"

    };
    
    //Setup connection URL based on AUTH style (token or userid) 
    var pushConnectionURL;
    
    if(userId && orgId) {
        //All the namespaces on push service should be in lowercase
        orgId = orgId.toLowerCase();

        //Directly apply the userid passed to us
        pushConnectionURL = self.config.DEFAULT_HOSTS['PUSH'] + '/' + orgId + '?orgid=' + orgId + '&userid=' + userId;
    } else {
        //Validate the we have a valid AUTH credentials         
        var err = helpers.validations.isAuthenticated(self.orgId, self.token);
        if (err) {
            dfd.reject(err);
        } else {
            pushConnectionURL = self.config.DEFAULT_HOSTS['PUSH'] + '/' + self.orgId.toLowerCase() + '?orgid=' + self.orgId.toLowerCase() + '&token=' + self.token.access_token;
        }
    }
    
    if(pushConnectionURL) {    
       
        var socket = io.connect(pushConnectionURL);
        
        //Setup notifications handler, and return to the caller.
        var notifications = new EventEmitter();

        //----------- Handle events to be emitted to Push-Service
        notifications.on(EVENTS.ACTIVEROOM, function(activeroomid) {
            socket.emit(EVENTS.ACTIVEROOM, activeroomid);
        });

        dfd.resolve(notifications);
        
        socket.on('connect', function(){
            //Successfully connected to PUSH service, notify caller, via "notifications" Emiter
            var eventContext = {};
            notifications.emit(EVENTS.CONNECT, eventContext);
        });
        
        //----------- Handle Connection errors and notify caller, via "notifications" Emiter
        socket.on('connect_error', function(errObj){
           
            var eventContext = {};
            eventContext.error = {}
            eventContext.error.message ="connect_error"
            eventContext.error.description = "Connection Error to PUSH API, URL: " + pushConnectionURL + ", " + JSON.stringify(errObj);
            
            notifications.emit(EVENTS.CONNECT_ERROR, eventContext)
        });
        
        socket.on('connect_timeout', function(errObj){
            
            var eventContext = {};
            eventContext.error = {}
            eventContext.error.message ="connect_timeout"
            eventContext.error.description = "Timeout error to PUSH API, URL: " + pushConnectionURL + ", " + JSON.stringify(errObj);
            
            notifications.emit(EVENTS.CONNECT_ERROR, eventContext)
        });
        
        //----------- Handle comproDLS Push Notifications, send them to the caller via "notifications" Emiter
        socket.on('presence', function (presenceMessage) {
            var eventContext = presenceMessage; 
            notifications.emit(EVENTS.USER_NEW, eventContext);
        });
        socket.on('presenceupdate', function (presenceUpdateMessage) {
            var eventContext = presenceUpdateMessage; 
            notifications.emit(EVENTS.USER_CHANGED, eventContext);
        });
        socket.on('collab', function (collabMessage) {
            var eventContext = collabMessage; 
            notifications.emit(EVENTS.COLLAB_EVENT, eventContext);
        });
        socket.on('activity', function (activityMessage) {
            var eventContext = activityMessage; 
            notifications.emit(EVENTS.ACTIVITY_EVENT, eventContext);
        });
		socket.on('job', function (jobMessage) {
            var eventContext = jobMessage;
            notifications.emit(EVENTS.JOB_EVENT, eventContext);
        });
        socket.on('systemevents', function (systemEventMessage) {
            var eventContext = systemEventMessage;
            notifications.emit(EVENTS.SYSTEM_EVENT, eventContext);
        });
        socket.on('error', function(err) {
            var eventContext;
			try {
				eventContext = JSON.parse(err);
			} catch(Ex) {
				eventContext = new Error(err);
			}
			socket.disconnect();
			notifications.emit(EVENTS.ERROR, eventContext);
        });
    } 
    
    return dfd.promise;
}

//for reference only
function _setup(orgId, userId) {
    var dfd = q.defer();

    pubnubClientWrapper.setup({
        orgId: orgId, userId: userId,
        pubnub: this.config.DEFAULT_PUBNUB_CREDENTIALS
    })
    .then(function(pushAdapter) { dfd.resolve(pushAdapter); })
    .catch(function(error) { dfd.reject(error); });

    return dfd.promise;
}
