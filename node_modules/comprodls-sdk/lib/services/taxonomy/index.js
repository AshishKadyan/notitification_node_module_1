/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

/***********************************************************
 * comproDLS SDK AUTH API Adaptor
 * Functions for calling AUTH API.
 ************************************************************/

var q = require('q');
var request = require('superagent');
var helpers = require('../../helpers');

var DLSError = helpers.errors.DLSError;

/*********************************
 * Setting Up Module Entry Point
 **********************************/
module.exports = taxonomy;
//Taxonomy Adaptor Contsructor
function taxonomy() {
  return {
    associateTagsWithEntity: associateTagsWithEntity.bind(this),
    createTags: createTags.bind(this),
    updateTags: updateTags.bind(this),
    deleteTags: deleteTags.bind(this),
    getTag: getTag.bind(this),
    getTagHierarchy: getTagHierarchy.bind(this),
    getAllTags: getAllTags.bind(this)
  };
}

/*********************************
 * Public Function definitions
 **********************************/

/**
 * options = {
 * entity_type: 'type of entity',
 * entity_id: 'id of the entity',
 * tags: 'array of tags for association with entity'
 */
function associateTagsWithEntity(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();

  //Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if (err) {
    dfd.reject(err);
  } else {
    if (options && options.entity_type && options.entity_id && options.tags) {
      //Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
        self.config.TAXONOMY_API_URLS.associateTagsWithEntity;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      //Setup request with URL and Params
      var requestAPI = request.put(url).send(options);

      if (self.traceid) {
        requestAPI.set('X-Amzn-Trace-Id', self.traceid);
      }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function(err, response) {
        if (err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body);
        }
      });
    } else {
      err = {};
      err.message = err.description = 'entity_id or entity_type or tags not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }

  return dfd.promise;
}


/*
  options = {
    context: "string", //mandatory
    taxonomyid: "string", //mandatory
    body: {
      tags: [{
        "tagid": "",
        "tagname": "",
        "tag_data": {} // optional
      }]
    }
  }
*/
function createTags(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.context && options.taxonomyid && options.body && options.body.tags && (options.body.tags.length > 0)) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.TAXONOMY_API_URLS.tags;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        context: encodeURIComponent(options.context),
        taxonomyId: options.taxonomyid
      });

      var requestAPI = request.post(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .send(options.body);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory param - context or taxonomyid or body.tags(min. 1 tag) ' +
                                      'not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

 /* options = {
    "context": "string", //mandatory
    "taxonomyid": "string" //mandatory
    "body": {
      "tagid": "string", //mandatory
      "tagname": "string",
      "tag_data": {}
    }
  };
*/
function updateTags(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.context && options.taxonomyid && options.body && options.body.tagid) {

      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.TAXONOMY_API_URLS.tags;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        context: encodeURIComponent(options.context),
        taxonomyId: options.taxonomyid
      });

      // Setup request with URL and Params
      var requestAPI = request.put(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .send(options.body);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory params - context or taxonomyid or tagid not found in ' +
                                      'request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/* options = {
    "context": "string", // required
    "taxonomyid" : "string", // required
    "tagid" : "string"
  };
*/
function deleteTags(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if (options && options.context && options.taxonomyid) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.TAXONOMY_API_URLS.tags;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        context: encodeURIComponent(options.context),
        taxonomyId: options.taxonomyid
      });

      var queryParam = {};
      if(options.tagid) { queryParam.tagid = options.tagid; }

      // Setup request with URL and Params
      var requestAPI = request.delete(url).query(queryParam);

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      requestAPI.end(function (error, response) {
        if (error) {
          err = {};
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else {
          dfd.resolve(response.body);
        }
      });
    }
    else {
      err = {};
      err.message = err.description = 'context or taxonomyid or tagid not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*
  options = {
    context: "string", //mandatory
    taxonomyid: "string", //mandatory
    tagid: "string" //mandatory
  }
*/
function getTag(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  // Validations
  else {
    if(options && options.context && options.taxonomyid && options.tagid) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.TAXONOMY_API_URLS.tags;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        context: encodeURIComponent(options.context),
        taxonomyId: options.taxonomyid
      });

      // Setup request with URL and Params
      var queryParam = {
        hierarchy: false,
        tagid: options.tagid
      };

      var requestAPI = request.get(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .query(queryParam);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory param - context or taxonomyid or tagid not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*
  options = {
    context: "string", //mandatory
    taxonomyid: "string", //mandatory
    tagid: "string" //mandatory
  }
*/
function getTagHierarchy(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  // Validations
  else {
    if(options && options.context && options.taxonomyid && options.tagid) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.TAXONOMY_API_URLS.tags;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        context: encodeURIComponent(options.context),
        taxonomyId: options.taxonomyid
      });

      // Setup request with URL and Params
      var queryParam = {
        hierarchy: true,
        tagid: options.tagid
      };

      var requestAPI = request.get(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .query(queryParam);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory param - context or taxonomyid or tagid not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*
  options = {
    context: "string", //mandatory
    taxonomyid: "string" //mandatory
  }
*/
function getAllTags(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  // Validations
  else {
    if(options && options.context && options.taxonomyid) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.TAXONOMY_API_URLS.tags;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        context: encodeURIComponent(options.context),
        taxonomyId: options.taxonomyid
      });

      // Setup request with URL and Params
      var queryParam = {
        hierarchy: true
      };

      var requestAPI = request.get(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .query(queryParam);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory param - context or taxonomyid not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}
