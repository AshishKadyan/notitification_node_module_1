/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/
/***********************************************************
 * comproDLS SDK Collab API Adaptor
 * Functions for calling Collab API.
 ************************************************************/
var request = require('superagent');
var q = require('q');

var helpers = require('../../helpers');
var DLSError = helpers.errors.DLSError;

/*********************************
 * Setting Up Module Entry Point  
 **********************************/
module.exports = collab;

function collab() {
    return {
        "getPostsInClass": getPostsInClass.bind(this),
        "createPostInClass": createPostInClass.bind(this),
        "getPostsInProduct": getPostsInProduct.bind(this),
        "createPostInProduct": createPostInProduct.bind(this),
        "getMyFollowers": getMyFollowers.bind(this),
        "getUsersFollowedByMe": getUsersFollowedByMe.bind(this),
        "followUser": followUser.bind(this),
        "unfollowUser": unfollowUser.bind(this)
    }
};

/*********************************
 * Public Function definitions
 **********************************/

//options = {
//    classid: "class uuid",
//    cursor: "string",     //(optional) cursor to get next set of activities.
//    limit: integer        //(optional) number of activities to be returned (default 10).
//}
function getPostsInClass(options) {
    var self = this;
    //Initializing promise
    var dfd = q.defer();
    var err = {};
    //Validations
    if(options && options.classid) {
        err = helpers.validations.isAuthenticated(self.orgId, self.token);
        if(err) {
            dfd.reject(err);
        } else {
            //Passed all validations, Construct API url
            var url = self.config.DEFAULT_HOSTS['COLLAB'] + self.config.COLLAB_API_URLS.postsInClassAPI;
            url = helpers.api.constructAPIUrl(url, {
                "orgId": self.orgId,
                "classId": options.classid
            });

            //Contruct parameters
            var params = {};
            if(options.cursor) {
                params.cursor = options.cursor;
            }
            if(options.limit) {
                params.limit = options.limit;
            }

            //Setup request with URL and Params
            var requestAPI = request.get(url).query(params);
            if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

            //Setup token in Authorization header
            requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

            //Call GET CLASS ALL POSTS Api
            requestAPI.end(function(error, response){
                if(error) {
                    err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
                    dfd.reject(err);
                } else {
                    dfd.resolve(response.body);
                }
            });
        }
    } else {
        err.message = err.description = 'Mandatory parameter "classid" not found in request options';
        err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
        dfd.reject(err);
    }
    return dfd.promise;
}

//options = {
//    classid: "class uuid",
//    verb: "verb",
//    post: "post",         // (optional)
//    name: "name",         // (optional)
//    email: "email",       // (optional)
//    userid: "userid"      // (optional)
//}
function createPostInClass(options) {
    var self = this;
    //Initializing promise
    var dfd = q.defer();
    var err = {};
    //Validations
    if(options && options.verb && options.classid) {
        err = helpers.validations.isAuthenticated(self.orgId, self.token);
        if(err) {
            dfd.reject(err);
        } else {
            //Passed all validations, Construct API url
            var url = self.config.DEFAULT_HOSTS['COLLAB'] + self.config.COLLAB_API_URLS.postsInClassAPI;
            url = helpers.api.constructAPIUrl(url, {
                "orgId": self.orgId,
                "classId": options.classid
            });
            //Construct parameters
            var params = {
                verb: options.verb
            };
            if(options.post) {
                params.post = options.post;
            }
            if(options.name) {
                params.name = options.name;
            }
            if(options.email) {
                params.email = options.email;
            }
            if(options.userid) {
                params.userid = options.userid;
            }
            //Setup request with url and params
            var requestAPI = request.post(url).send(params);
            if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

            //Setup token in Authorization Header
            requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
            //Call POST 'POST in CLASS'
            requestAPI.end(function(error, response) {
                if(error) {
                    err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
                    dfd.reject(err);
                } else {
                    dfd.resolve(response.body);
                }
            })
        }
    } else {
        err.message = err.description = 'Mandatory parameter "verb" or "classid" not found in request options';
        err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
        dfd.reject(err);
    }
    return dfd.promise;
}

//options = {
//    productid: "product uuid",
//    cursor: "string",           //(optional) cursor to get next set of activities
//    limit: integer              //(optional) number of activities to be returned(default 10)
//}
function getPostsInProduct(options) {
    var self = this;
    //Initializing promise
    var dfd = q.defer();
    var err = {};
    //Validations
    if(options && options.productid) {
        err = helpers.validations.isAuthenticated(self.orgId, self.token);
        if(err) {
            dfd.reject(err);
        } else {
            //Passed all validations, Construct API url
            var url = self.config.DEFAULT_HOSTS['COLLAB'] + self.config.COLLAB_API_URLS.postsInProductAPI;
            url = helpers.api.constructAPIUrl(url, {
                "orgId": self.orgId,
                "productId": options.productid
            });
            //Contruct parameters
            var params = {};
            if(options.cursor) {
                params.cursor = options.cursor;
            }
            if(options.limit) {
                params.limit = options.limit;
            }
            //Setup request with URL and Params
            var requestAPI = request.get(url).query(params);
            if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

            //Setup token in Authorization header
            requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
            //Call GET CLASS ALL POSTS Api
            requestAPI.end(function(error, response) {
                if(error) {
                    err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
                    dfd.reject(err);
                } else {
                    dfd.resolve(response.body);
                }
            });
        }
    } else {
        err.message = err.description = 'Mandatory parameter "productid" not found in request options';
        err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
        dfd.reject(err);
    }
    return dfd.promise;
}

//options = {
//    productid: "product uuid",
//    verb: "string",       // Possible value is 'post'
//    post: "post",         // (optional)
//    name: "name",         // (optional)
//    email: "email",       // (optional)
//    userid: "userid"      // (optional)
//}
function createPostInProduct(options) {
    var self = this;
    //Initializing promise
    var dfd = q.defer();
    var err = {};
    if(options && options.verb && options.productid) {
        //Validations
        err = helpers.validations.isAuthenticated(self.orgId, self.token);
        if(err) {
            dfd.reject(err);
        } else {
            //Passed all validations, Construct API url
            var url = self.config.DEFAULT_HOSTS['COLLAB'] + self.config.COLLAB_API_URLS.postsInProductAPI;
            url = helpers.api.constructAPIUrl(url, {
                "orgId": self.orgId,
                "productId": options.productid
            });
            //Contruct params
            var params = {
                verb: options.verb
            };
            if(options.post) {
                params.post = options.post;
            }
            if(options.name) {
                params.name = options.name;
            }
            if(options.email) {
                params.email = options.email;
            }
            if(options.userid) {
                params.userid = options.userid;
            }
            //Setup request with url and params
            var requestAPI = request.post(url).send(params);
            if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

            //Setup token in Authorization Header
            requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
            //Call POST 'POST in PRODUCT'
            requestAPI.end(function(error, response) {
                if(error) {
                    err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
                    dfd.reject(err);
                } else {
                    dfd.resolve(response.body);
                }
            })
        }
    } else {
        err.message = err.description = 'Mandatory parameter "verb" or "productid" not found in request options';
        err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
        dfd.reject(err);
    }
    return dfd.promise;
}

/*options = {
 *  cursor: 'string'            // (optional) cursor string to fetch next set of followers
 *  limit: number               // (optional) limits the number of followers to fetch at at time
 *}
 */
function getMyFollowers(options) {
    var self = this;

    //Initializing Promise
    var dfd = q.defer();
    var err = {};

    //Validations
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err) {
        dfd.reject(err);
    } else {
        //Passed all Validations, constructing url
        var url = self.config.DEFAULT_HOSTS['COLLAB'] + self.config.COLLAB_API_URLS.getMyFollowers;

        url = helpers.api.constructAPIUrl(url, {
            orgId: self.orgId
        })
        //Attaching Query Params
        var queryParams = {};

        if(options.cursor) { queryParams.cursor = options.cursor; }
        if(options.limit) { queryParams.limit = options.limit; }

        //Setup request with url and params
        var requestAPI = request.get(url).query(queryParams);
        if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

        //Setup token in Authorization Header
        requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
        //Call GET 'getFollower'
        requestAPI.end(function(error, response) {
           if(error) {
                err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
                dfd.reject(err);
            } else {
                dfd.resolve(response.body);
            }
        });
    }

    return dfd.promise;
}

/*options = {
 *  cursor: 'string'            // (optional) cursor string to fetch next set of following users
 *  limit: number               // (optional) limits the number of following users, to fetch at at time
 *}
 */
function getUsersFollowedByMe(options) {
    var self = this;

    //Initializing Promise
    var dfd = q.defer();
    var err = {};

    //Validations
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err) {
        dfd.reject(err);
    } else {
        //Passed all Validations, constructing url
        var url = self.config.DEFAULT_HOSTS['COLLAB'] + self.config.COLLAB_API_URLS.getUsersFollowedByMe;

        url = helpers.api.constructAPIUrl(url, {
            orgId: self.orgId
        })
        //Attaching Query Params
        var queryParams = {};

        if(options.cursor) { queryParams.cursor = options.cursor; }
        if(options.limit) { queryParams.limit = options.limit; }

        //Setup request with url and params
        var requestAPI = request.get(url).query(queryParams);
        if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

        //Setup token in Authorization Header
        requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
        //Call GET 'getFollower'
        requestAPI.end(function(error, response) {
           if(error) {
                err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
                dfd.reject(err);
            } else {
                dfd.resolve(response.body);
            }
        });
    }

    return dfd.promise;
}

/*options = {
 *  userid: 'string'                // user uuid
 *}
 */
function followUser(options) {
    //Initializing Promise
    var dfd = q.defer();

    //calling function to 'create' connection (follow user)
    updateConnectionForUser(this.orgId, this.token, this.config, options, 'create')
    .then(function(response) { dfd.resolve(response); })
    .catch(function(error) { dfd.reject(error); })
    .done();

    return dfd.promise;
}

/*options = {
 *  userid: 'string'                // user uuid
 *}
 */
function unfollowUser(options) {
    //Initializing Promise
    var dfd = q.defer();

    //calling function to 'delete' connection (unfollow user)
    updateConnectionForUser(this.orgId, this.token, this.config, options, 'delete')
    .then(function(response) { dfd.resolve(response); })
    .catch(function(error) { dfd.reject(error); })
    .done();

    return dfd.promise;
}

function updateConnectionForUser(orgid, token, config, options, action) {
    //Initializing Promise
    var dfd = q.defer();
    var err = {};

    //Validations
    if(options && options.userid) {
        //Validating Auth Token
        err = helpers.validations.isAuthenticated(orgid, token);
        if(err) {
            dfd.reject(err);
        } else {
            //Passed all Validations, constructing url
            var url = config.DEFAULT_HOSTS['COLLAB'] + config.COLLAB_API_URLS.connectionURL;
            url = helpers.api.constructAPIUrl(url, {
                orgId: orgid,
                userId: options.userid
            });
            var requestAPI;
            //Setup request with url and params
            if(action === 'create') {
                requestAPI = request.post(url).set('Content-Type', 'application/json');
            } else if(action === 'delete') {
                requestAPI = request.delete(url).set('Content-Type', 'application/json');
            }
            //Setup token in Authorization Header
            requestAPI = helpers.api.setupAPIToken(requestAPI, token);
            //Call POST/DELETE 'updateConnectionForUser'
            requestAPI.end(function(error, response) {
                if(error) {
                    err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
                    dfd.reject(err);
                } else {
                    dfd.resolve(response.body);
                }
            });
        }
    } else {
        err.message = err.description = 'Mandatory parameter "userid" not found in request options';
        err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
        dfd.reject(err);
    }
    return dfd.promise;
}
