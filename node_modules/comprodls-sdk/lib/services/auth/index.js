/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

/***********************************************************
 * comproDLS SDK AUTH API Adaptor
 * Functions for calling AUTH API.
 ************************************************************/

var q = require('q');
var request = require('superagent');
var Agent = require('agentkeepalive');

var helpers = require('../../helpers');
var converter = require('../../helpers/lib/api/converter');

var DLSError = helpers.errors.DLSError;

/*********************************
 * Setting Up Module Entry Point  
 **********************************/
module.exports = auth;

var keepaliveAgent = new Agent({
  timeout: 60000,
  freeSocketTimeout: 30000
});

//Auth Adaptor Contsructor
function auth() {
  return {
    pisImport: pisImport.bind(this),

    getAllUsers: getAllUsers.bind(this),
    getUserProfile: getUserProfile.bind(this),
    deleteUserProfile: deleteUserProfile.bind(this),
    updateUserRole: updateUserRole.bind(this),
    getUserClasses: getUserClasses.bind(this),
    getClassUsers: getClassUsers.bind(this),
    enrollUsertoClass: enrollUsertoClass.bind(this),
    enrollSelftoClass: enrollSelftoClass.bind(this),
    enrollMultiUserstoClass: enrollMultiUserstoClass.bind(this),
    unEnrollMultiUserstoClass: unEnrollMultiUserstoClass.bind(this),
    unEnrollUsertoClass: unEnrollUsertoClass.bind(this),

    getOrgSettings: getOrgSettings.bind(this),
    updateOrgSettings: updateOrgSettings.bind(this),
    generateClassCode: generateClassCode.bind(this),

    getAllJobs: getAllJobs.bind(this),
    getJob: getJob.bind(this),

    createClass: createClass.bind(this),
    updateClass: updateClass.bind(this),
    createMultipleClasses: createMultipleClasses.bind(this),
    cloneClass: cloneClass.bind(this),
    getAllClasses: getAllClasses.bind(this),
    getParticularClass: getParticularClass.bind(this),
    getParticularShadowClass: getParticularShadowClass.bind(this),
    createClassProductAssociation: createClassProductAssociation.bind(this),
    removeClassProductAssociation: removeClassProductAssociation.bind(this),
    createMultiClassProductAssociations: createMultiClassProductAssociations.bind(this),
    addItemsToShowcaseOfAClass: addItemsToShowcaseOfAClass.bind(this),
    deleteItemsFromShowcaseOfAClass: deleteItemsFromShowcaseOfAClass.bind(this),

    getClassAppdata: getClassAppdata.bind(this),
    putClassAppdata: putClassAppdata.bind(this),
    deleteClassAppdata: deleteClassAppdata.bind(this),

    encodeURLParameter: encodeURLParameter.bind(this),

    createAssignedPath: createAssignedPath.bind(this),
    deleteAssignedPath: deleteAssignedPath.bind(this),
    updateAssignedPath: updateAssignedPath.bind(this),

    //Groups related APIs
    createGroup: createGroup.bind(this),
    getAllGroupsByPath: getAllGroupsByPath.bind(this),
    getAGroup: getAGroup.bind(this),
    updateGroup: updateGroup.bind(this),
    deleteGroup: deleteGroup.bind(this),
    getAllMembersOfAGroup: getAllMembersOfAGroup.bind(this),
    getAllGroupMembersByPath: getAllGroupMembersByPath.bind(this),
    createMultiUserGroupMembership: createMultiUserGroupMembership.bind(this),
    deleteMultiUserGroupMembership: deleteMultiUserGroupMembership.bind(this),
    getMyAllMemberships: getMyAllMemberships.bind(this),
    archiveGroup: archiveGroup.bind(this),
    unarchiveGroup: unarchiveGroup.bind(this)
  };
}

/*********************************
 * Public Function definitions
 **********************************/

//options = {
//    userid: 'uuid or username',  //optional.
//}
function getUserProfile(options) {
  /* Reference to comproDLS SDK object , contains the following properties
   * 1. self.orgId [String] : organization Id
   * 2. self.token [Object] : DLS token. It has following structure
   *    {
   *      "access_token" : [String]
   *    }
   */
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    var userid = 'me';
    if(options) {
      if(options.userid) { userid = options.userid; }
    }
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
              self.config.AUTH_API_URLS.userInfoAPI;
    url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, userId: userid });

    // Contruct parameters
    var params = {};

    // Setup request with URL and Params
    var requestAPI = request.get(url).query(params);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    // Setup token in Authorization header
    requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
    // Call GET USER INFO Api
    requestAPI.end(function(err, response) {
      if(err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else {
        var res = converter.convertUserResponse({data: response.body});
        dfd.resolve(res);
      }
    });
  }
  return dfd.promise;
}

/**
 * options = {
 *     userid : ""    // dls user id, mandatory
 * }
 */

function deleteUserProfile(options) {
  var self = this;
  var dfd = q.defer();

  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if (options.userid) {
      var userid = options.userid;

      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
        self.config.AUTH_API_URLS.userInfoAPI;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, userId: userid });

      // Setup request with URL
      var requestAPI = request.delete(url);
      if (self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // Call DELETE USER API
      requestAPI.end(function (error, response) {
        if (error) {
          error = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(error);
        }
        else { dfd.resolve(response.body); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory parameter userid not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

//options = {
//    search: 'search string',   //optional.
//    lookup: 'string', // Search query (',' separated key value pairs), e.g. key1:val1,key2:val2,key3:val3
//    lookup-operator: 'AND'/'OR', // Operator to use while lookup. Current Possible Value - AND, OR
//    cursor: 'cursor',      //optional, cursor to get next set of groups.
//    limit: number,         //optional, limit the number of Users to fetch at a time.
//    role: 'string'         //optional, to search Users by Role
//    sortField: ['first_name', 'last_name', 'ext_email', 'created', 'roles', ... (other fields of response entity)]
//              Sort the result according to given field. By default is 'last_name’, followed by ‘first_name’ in asc order.
//    sortOrder: ['desc', 'asc']   //optional, By default is 'desc’.
//}
function getAllUsers(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    var queryStr = 'orgid:"' + self.orgId + '"';

    if(options.lookup && options['lookup-operator']) {
      var lookupString = options.lookup;
      lookupString = lookupString.replace(/ext_/ig, '');
      var lookupArray = lookupString.split(',').map(function(item) {
        var lookupItem = item.trim();
        var tempArr = lookupItem.split(':');
        lookupItem = '(' + lookupItem + ' OR ' + tempArr[0] + '.keyword:' + tempArr[1] + ')';
        return lookupItem;
      });
      queryStr = queryStr + ' AND (' + lookupArray.join(' ' + options['lookup-operator'] + ' ') + ')';
    }

    if(options.role) {
      var roleNameString = options.role;
      var roleNameArray = roleNameString.split(',').map(function(item) { return item.trim(); });
      for(var idx in roleNameArray){
        roleNameArray[idx] = 'roles:' + roleNameArray[idx];
      }
      queryStr = queryStr + ' AND (' + roleNameArray.join(' OR ') + ')';
    }

    if(options.search) {
      queryStr = queryStr + ' AND (email:"' + options.search + '" OR first_name:"' + options.search + '" OR last_name:"'
                  + options.search + '" OR username:"' + options.search + '" OR userid:"' + options.search + '")';
    }

    var sortField = options.sortField || '';
    sortField = sortField.replace(/ext_/ig, '').split(',').shift().trim() || 'last_name';
    var sortOrder = options.sortOrder || 'asc';
    if(sortField !== 'created') {
      sortField = sortField + '.keyword';
    }
    var sortObj = {}, sortArr = [];
    sortObj[sortField] = sortOrder;
    sortArr.push(sortObj);

    var queryObj = {
      query: { query_string: { query: queryStr } },
      sort: sortArr
    };

    if(options.cursor) { queryObj.search_after = JSON.parse(options.cursor); }
    if(options.limit) { queryObj.size = options.limit; }
    else { options.limit = 10; } // by default ES returns only 10 elements at max.

    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.INTEGRATION +
              self.config.INTEGRATIONS_API_URLS.queryDataFromSearch;
    url = helpers.api.constructAPIUrl(url, { index: 'users' });

    // Contruct parameters
    var params = {
      query: JSON.stringify(queryObj)
    };

    // Setup request with URL and Params
    var requestAPI = request.get(url).query(params);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    // Setup token in Authorization header
    requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

    // Call GET ALL USER Api
    requestAPI.end(function(err, response) {
      if(err) {
        var esErrOptions = { type: helpers.errors.ERROR_TYPES.API_ERROR, err: err };
        var error = converter.convertElasticsearchErrResponse(esErrOptions);
        dfd.reject(error);
      }
      else {
        var responseObject = { entities: [] };
        responseObject.count = response.body.hits.hits.length;
        if(responseObject.count && (options.limit  === responseObject.count)) {
          var cursor = response.body.hits.hits[response.body.hits.hits.length - 1].sort;
          responseObject.cursor = JSON.stringify(cursor);
        }

        for(var index in response.body.hits.hits) {
          var userEntity = response.body.hits.hits[index]._source;
          var userObj = {
            uuid: userEntity.dls_user_id,
            name: userEntity.first_name + ' ' + userEntity.last_name,
            email: userEntity.email || userEntity.ext_email,
            username: userEntity.userid + '--ACCOUNT',
            created: userEntity.created,
            org: { id: self.orgId }
          };
          if(userEntity.roles) {
            userObj.roles = userEntity.roles;
          }
          if(userEntity.provision_method) {
            userObj.provision_method = userEntity.provision_method;
          }
          if(userEntity.first_name) {
            userObj.first_name = userEntity.first_name;
          }
          if(userEntity.last_name) {
            userObj.last_name = userEntity.last_name;
          }
          if(userEntity.ext_parent_id) {
            userObj.ext_parent_id = userEntity.ext_parent_id;
          }
          if(userEntity.username) {
            userObj.ext_username = userEntity.username;
          }
          if(userEntity.userid) {
            userObj.ext_user_id = userEntity.userid;
          }
          if(userEntity.address) {
            userObj.address = userEntity.address;
          }
          responseObject.entities.push(userObj);
        }
        dfd.resolve(responseObject);
      }
    });
  }
  return dfd.promise;
}

//options = {
//    userid: 'dlsUserId',  //mandatory
//    target_role: 'string', //mandatory
//    ext_data: { email_template_id: string } //optional
//}
function updateUserRole(options) {
  var self = this;

  // Initializing promise
  var dfd = q.defer();
  // Validations
  var error = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(error) { dfd.reject(error); }
  else {
    if(options && options.userid && options.target_role) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                                self.config.AUTH_API_URLS.updateUserRoleAPI;
      url = helpers.api.constructAPIUrl(url, { orgId : self.orgId, userId: options.userid });
      var bodyParams = { ext_data: options.ext_data, target_role: options.target_role };
      // Setup request with URL and Params
      var requestAPI = request.put(url)
                      .set('Content-Type', 'application/json')
                      .set('Accept', 'application/json')
                      .send(bodyParams);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
      // Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        }
        else { dfd.resolve(response); }
      });
    } else {
      var err = {};
      err.message = err.description = 'Mandatory parameter options, userid or target_role, not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }

  return dfd.promise;
}

//options = {
//    userid: 'uuid or username',  //optional.
//    search: 'search string',   //optional.
//    details: true/false,  //optional, includes products & assignments information of class.
//    sortField: ['startdate', 'enddate', 'title']       //optional, By default is 'title’.
//    sortOrder: ['desc', 'asc'] //optional, By default is 'desc’.
//    enrollmentType: ['creator', 'teacher', 'student'] //optional, bydefault send all classes.
//    teacherId: 'string' //optional, get classes of a particular teacher only.
//    cursor: 'cursor'      //optional, cursor to get next set of classes
//    limit: integer      //optional, Number of entities to fetch at once
//    bundleDetails: true/false      //optional
//}
function getUserClasses(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    var userid = 'me';
    if(options) {
      if(options.userid) { userid = options.userid; }
    }
    // Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
              self.config.AUTH_API_URLS.getUserClassesAPI;
    url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, userId: userid });

    // Contruct parameters
    var params = {};
    if(options) {
      if(options.search) { params.search = 'title:' + options.search; }
      if(options.details) { params.details = options.details; }
      if(options.enrollmentType) { params.enrollmentType = options.enrollmentType; }
      if(options.sortField) { params.sortField = options.sortField; }
      if(options.sortOrder) { params.sortOrder = options.sortOrder; }
      if(options.cursor) { params.cursor = options.cursor; }
      if(options.limit) { params.limit = options.limit; }
      if(options.teacherId) { params.lookup = 'class.class.instructor.uuid:' + options.teacherId; }
      if(options.bundleDetails) { params.bundleDetails = options.bundleDetails; }
    }

    // Setup request with URL and Params
    var requestAPI = request.get(url).query(params);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    // Setup token in Authorization header
    requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

    // Call GET ALL USER Api
    requestAPI.end(function(err, response) {
      if(err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  return dfd.promise;
}

/**
 * options = {
 *    classid: 'classid',
 *    search: 'string',         // (optional) Search Query
 *    cursor: 'string',         // (optional) Cursor string to fetch next set of Users
 *    limit: 'integer'          // (optional) Number of users to fetch at a time.
 *    sortField: 'string'       // (optional) Sort the result according to given field. By default is 'email’.
 *    sortOrder: 'string'       // (optional) Sort the result according to given order. By default is 'desc’.
 * }
 */
function getClassUsers(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.classid) {
      // Passed all validations, Construct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.getClassUsersAPI;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId, classId: options.classid
      });

      // Setup params
      var params = {};
      if(options.search) { params.search = options.search; }
      if(options.cursor) { params.cursor = options.cursor; }
      if(options.limit) { params.limit = options.limit; }
      if(options.sortField) { params.sortField = options.sortField; }
      if(options.sortOrder) { params.sortOrder = options.sortOrder; }

      // Setup request with URL and Params
      var requestAPI = request.get(url).query(params);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // Call GET ALL USER Api
      requestAPI
        .agent(keepaliveAgent)
        .end(function(err, response) {
          if(err) {
            err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
            dfd.reject(err);
          }
          else {
            response.body.entities = converter.convertEnrollmetsResponse({data: response.body.entities}) ;
            dfd.resolve(response.body);
          }
        });
    } else {
      err = {};
      err.message = err.description = 'Required parameter classid is not defined.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

//options = {
//    extension: 'csv',
//    import_type: 'users'/'groups'/'user-group-enrollment',
//    upFile: '' // path to csv file to be uploaded
//}
function pisImport(options) {
	var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    // Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
              self.config.AUTH_API_URLS.pisImportAPI;
    url = helpers.api.constructAPIUrl(url, {"orgId" : self.orgId});
    // Contruct parameters
    var params = {};
    var upfile;
    if(options) {
      if(options.extension) { params.extension = options.extension; }
      if(options.import_type) { params.import_type = options.import_type; }
      if(options.upfile) { upfile = options.upfile; }
    }

    // Setup request with URL and Params
    var requestAPI = request.post(url).query(params)
                     .set('Content-Type', 'multipart/form-data')
                     .attach('upfile', upfile);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    // Setup token in Authorization header
    requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

    // Call PIS IMPORT Api
    requestAPI.end(function(err, response) {
      if(err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  return dfd.promise;
}

//options = {
//	field: '' // apps / lti / sis / pis / product[ANY ONE]
//}
function getOrgSettings(options) {
	var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    // Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
              self.config.AUTH_API_URLS.getSettings;
    url = helpers.api.constructAPIUrl(url, {orgId: self.orgId});

    // Contruct parameters
    var params = {};
    if(options && options.field) {
      url = self.config.DEFAULT_HOSTS.AUTH +
            self.config.AUTH_API_URLS.getSettingsField;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId, field: options.field
      });
    }

    // Setup request with URL and Params
    var requestAPI = request.get(url).query(params);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    // Setup token in Authorization header
    requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

    // Call SIS IMPORT Api
    requestAPI.end(function(err, response) {
      if(err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  return dfd.promise;
}

//options = {
//	body: {} // the top level settings field to be updated.
//}
function updateOrgSettings(options) {
	var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    // Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
              self.config.AUTH_API_URLS.getSettings;
    url = helpers.api.constructAPIUrl(url, {orgId: self.orgId});
    // Setup request with URL and Params
    var requestAPI = request.put(url);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    if(options.body) {
      if(options.body.sis && (! options.body.sis.productid)) {
        options.body.sis.productid = [];
      }
      requestAPI.send(options.body);
    }
    // Setup token in Authorization header
    requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

    // Call SIS IMPORT Api
    requestAPI.end(function(err, response) {
      if(err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  return dfd.promise;
}

//options = {
//	classid: "string"
//}
function generateClassCode(options) {
  var self = this, err;
  // Initializing promise
  var dfd = q.defer();
  if(options && options.classid) {
    // Validations
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err) { dfd.reject(err); }
    else {
      // Passed all validations, Construct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                              self.config.AUTH_API_URLS.generateClassCode;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId, classId: options.classid
      });
      // Setup request with URL and Params
      var requestAPI = request.post(url);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // Call Update class settings Api
      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    }
  } else {
    err = {};
    err.message = err.description = 'classid not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/**
 * {
    accountId: 'string'  //mandatory
    extUserId: 'string',  //mandatory
    jobType: 'string'  //optional queryParam, Use this param to get  All Jobs of a particular jobType.
  }
 */
function getAllJobs(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  if(options && options.accountId && options.extUserId) {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.getAllJobs;
    url = helpers.api.constructAPIUrl(url, { accountId : options.accountId, extUserId: options.extUserId });
  
    var params = {};
    if(options.jobType) { params.jobType = options.jobType; }

    // Setup request with URL and Params
    var requestAPI = request.get(url).query(params);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } else {
    var err = {};
    err.message = err.description = 'accountId or extUserId not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/**
 * options = {
    accountId: 'string', //mandatory
    extUserId: 'string', //mandatory
    jobId: 'string', //mandatory
    jobType: 'string' //mandatory
  }
 */
function getJob(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  if(options && options.accountId && options.extUserId && options.jobId && options.jobType) {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.getJob;
    url = helpers.api.constructAPIUrl(url, { accountId : options.accountId, extUserId: options.extUserId,
      jobId: options.jobId });
    var params = { jobType: options.jobType };

    // Setup request with URL and Params
    var requestAPI = request.get(url).query(params);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } else {
    var err = {};
    err.message = err.description = 'accountId or extUserId or jobType or jobId or not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}


/**
 * @param {*} options {
 *  search: 'search string',        // Optional
 *  sortField: ['startdate', 'enddate', 'title', 'created', 'tagname_1'] // Optional
 *                                  // Default: 'created’.
 *  sortOrder: ['desc', 'asc']      // Optional, Default: 'desc’.
 *  cursor: 'cursor'                // Optional, cursor to get next set of groups.
 *  limit: integer,                 // Optional, limit number of Classes in response.
 *  lookup: 'string',               // Optional, Exact query search (',' separated key value pairs).
 *                                  // E.g. key1:val1,key2:val2
 *  lookup-operator: ['OR', 'AND']  // Optional
 * }
 * @returns {entities: [{}, {}, ...], count: <integer>, cursor: <string>}
 */
function getAllClasses(options) {
    var self = this;

    //Initializing promise
    var dfd = q.defer();

    //Validations
    var err = helpers.validations.isAuthenticated(self.orgId, self.token);

    if(err) {
        dfd.reject(err);
    } else {
        var queryStr = 'orgid:"' + self.orgId + '"';

        if (options.lookup && options['lookup-operator']) {
          var lookupString = options.lookup;
          var lookupArray = lookupString.split(',').map(function (item) {
            var lookupItem = item.trim();
            var tempArr = lookupItem.split(':');
            lookupItem = '(' + tempArr[0] + '.keyword:' + tempArr[1] + ')';
            return lookupItem;
          });
          queryStr += ' AND (' + lookupArray.join(' ' + options['lookup-operator'] + ' ') + ')';
        }

        if(options.search) {
          queryStr = queryStr + ' AND (title:"' + options.search + '" OR class.instructor.first_name:"' + options.search +
                      '" OR class.instructor.last_name:"' + options.search + '" OR description:"' + options.search + '")';
        }

        var sortField = options.sortField || '';
        sortField = sortField.replace(/ext_/ig, '').split(',').shift().trim() || 'created';

        if(sortField === 'enddate' || sortField === 'startdate') {
          sortField = 'class.' + sortField;
        }

        if(sortField === 'title') {
          sortField = sortField + '.keyword';
        }

        if (sortField === 'tagname_1') {
          sortField = sortField + '.keyword';
        }

        var sortOrder = options.sortOrder || 'desc';
        var sortObj = {}, sortArr = [];
        sortObj[sortField] = sortOrder;
        sortArr.push(sortObj);

        var queryObj = {
          query: { query_string: { query: queryStr } },
          sort: sortArr
        };

        if(options.cursor) { queryObj.search_after = JSON.parse(options.cursor); }
        if(options.limit) { queryObj.size = options.limit; }
        else { options.limit = 10; } // by default ES returns only 10 elements at max.

        //Passed all validations, Construct API url
        var url = self.config.DEFAULT_HOSTS.INTEGRATION +
                  self.config.INTEGRATIONS_API_URLS.queryDataFromSearch;
        url = helpers.api.constructAPIUrl(url, { index: 'classes' });

        // Contruct parameters
        var params = {
          query: JSON.stringify(queryObj)
        };

        //Setup request with URL and Params
        var requestAPI = request.get(url).query(params);
        if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

        //Setup token in Authorization header
        requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

        //Call GET ALL USER Api
        requestAPI.end(function(err, response) {
            if(err) {
              var esErrOptions = { type: helpers.errors.ERROR_TYPES.API_ERROR, err: err };
              var error = converter.convertElasticsearchErrResponse(esErrOptions);
              dfd.reject(error);
            } else {
              var responseObject = { entities: [] };
              responseObject.count = response.body.hits.hits.length;
              if(responseObject.count && (options.limit  === responseObject.count)) {
                var cursor = response.body.hits.hits[response.body.hits.hits.length - 1].sort;
                responseObject.cursor = JSON.stringify(cursor);
              }
              for(var index in response.body.hits.hits) {
                var classEntity = response.body.hits.hits[index]._source;
                var classObj = {
                  uuid: classEntity.classid,
                  created: classEntity.created,
                  modified: classEntity.modified,
                  path: classEntity.path,
                  category: classEntity.category,
                  class: {
                    enddate: classEntity.class.enddate,
                    instructor: {
                      name: classEntity.class.instructor.first_name + ' ' + classEntity.class.instructor.last_name,
                      last_name: classEntity.class.instructor.last_name,
                      first_name: classEntity.class.instructor.first_name,
                      uuid: classEntity.class.instructor.dls_user_id,
                      email: classEntity.class.instructor.email,
                      username: classEntity.class.instructor.userid + '--ACCOUNT'
                    },
                    startdate: classEntity.class.startdate
                  },
                  'class.settings.active': classEntity['class.settings.active'],
                  class_code: classEntity.class_code,
                  class_ownership: classEntity.class_ownership || { owner_status: 'ENROLLED', model: 'STRICT' },
                  description: classEntity.description,
                  provision_method: classEntity.class.provision_method,
                  title: classEntity.title,
                  analyticsharingmodel: classEntity.analyticsharingmodel,
                  studentCount: classEntity.studentCount,
                  teacherCount: classEntity.teacherCount
                };

                /**
                 * Add class-tag association specific fields
                 */
                if (classEntity.tagid_1) {
                  classObj.tagid_1 = classEntity.tagid_1;
                  classObj.tagname_1 = classEntity.tagname_1;
                  classObj.taglookup_1 = classEntity.taglookup_1;
                }

                if (classEntity.tagid_2) {
                  classObj.tagid_2 = classEntity.tagid_2;
                  classObj.tagname_2 = classEntity.tagname_2;
                  classObj.taglookup_2 = classEntity.taglookup_2;
                }

                if (classEntity.tagid_3) {
                  classObj.tagid_3 = classEntity.tagid_3;
                  classObj.tagname_3 = classEntity.tagname_3;
                  classObj.taglookup_3 = classEntity.taglookup_3;
                }

                responseObject.entities.push(classObj);
              }
              dfd.resolve(responseObject);
            }
        });
    }
    return dfd.promise;
}


//options = {
//    classId: 'class uuid'
//}
function getParticularClass(options) {
    var self = this;

    //Initializing promise
    var dfd = q.defer();

    //Validations
    var err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err) {
        dfd.reject(err);
    } else {
        if(options && options.classId) {
            //Passed all validations, Contruct API url
            var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.getParticularClassAPI;
            url = helpers.api.constructAPIUrl(url,  { orgId: self.orgId, classId: options.classId } );

            var requestAPI = request.get(url);
            if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

            //Setup token in Authorization header
            requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

            requestAPI
              .agent(keepaliveAgent)
              .end(function(err, response) {
                  if(err) {
                      err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
                      dfd.reject(err);
                  } else {
                    dfd.resolve(response.body);
                  }
              });
        } else {
            err = {};
            err.message = err.description = 'classId not found in request options.';
            err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
            dfd.reject(err);
        }
    }
    return dfd.promise;
}

//options = {
//  ext_classid: 'ext classid' //mandatory
//}
function getParticularShadowClass(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();

  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) {
    dfd.reject(err);
  }
  else {
    if(options && options.ext_classid) {
      //Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.getParticularShadowClassAPI;
      url = helpers.api.constructAPIUrl(url,  { orgId: self.orgId, extClassId: options.ext_classid } );

      var requestAPI = request.get(url);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        } 
        else {
          dfd.resolve(response.body);
        }
      });
    } else {
      err = {};
      err.message = err.description = 'ext_classid not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

//options = {
//    classId: 'class uuid',
//    productcode: 'productcode'
//}
function createClassProductAssociation(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.classId && options.productcode) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.classProductAssociation;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId, classId: options.classId, productcode: options.productcode
      });

      // Setup request with URL and Params
      var requestAPI = request.post(url)
                       .set('Content-Type', 'application/json')
                       .set('Accept', 'application/json');
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    } else {
      err = {};
      err.message = err.description = 'classId or productcode not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

//options = {
//    classId: 'class uuid',
//    productcode: 'product code'
//}
function removeClassProductAssociation(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.classId && options.productcode) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.classProductAssociation;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId, classId: options.classId, productcode: options.productcode
      });

      // Contruct parameters
      var params = {};

      // Setup request with URL and Params
      var requestAPI = request.delete(url).query(params);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    } else {
      err = {};
      err.message = err.description = 'classId or productcode not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/**
 * This function creates multiple class-product associations.
 * @param options {
 *  *classId      : <string>,
 *  *productcodes : [<string>] // Min: 1, Max: 50
 * }
 * Note: Fields marked with '*' are mandatory.
 */
function createMultiClassProductAssociations(options) {
  var deferred = q.defer();
  var self = this;
  var error = helpers.validations.isAuthenticated(self.orgId, self.token);

  if (error) {
    deferred.reject(error);
  } else if (options && options.classId && options.productcodes) {
    // Passed all validations, Contruct API url
    var defaultHostPath = self.config.DEFAULT_HOSTS.AUTH;
    var bulkCPAssociationAPIPath = self.config.AUTH_API_URLS.multiClassProductAssociations;

    var url = defaultHostPath + bulkCPAssociationAPIPath;
    var bodyParams = { productcodes: options.productcodes };

    url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, classId: options.classId });

    // Setup request with URL and Params
    var requestAPI = request.post(url)
                      .set('Content-Type', 'application/json')
                      .set('Accept', 'application/json')
                      .send(bodyParams);

    if (self.traceid) {
      requestAPI.set('X-Amzn-Trace-Id', self.traceid);
    }

    // Setup token in Authorization header
    requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

    requestAPI.end(function(err, response) {
      if (err) {
        error = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        deferred.reject(error);
      } else {
        deferred.resolve(response.body);
      }
    });
  } else {
    error = {};
    error.message = error.description = 'Missing mandaotry fields \'classId\' or \'productcodes\' in request.';
    error = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, error);
    deferred.reject(error);
  }

  return deferred.promise;
}

/*options = {
  classid: 'string'
}*/
function getClassAppdata(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.classid) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.ClassAppdata;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId, classid: options.classid
      });
      //Setup request with URL
		var requestAPI = request.get(url);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

		//Setup token in Authorization header
		requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

		//Call Class Appdata Api
		requestAPI.end(function(err, response) {
			if(err) {
				err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
				dfd.reject(err);
			} else {
				dfd.resolve(response.body);
			}
		});
    } else {
      err = {};
      err.message = err.description = 'classid  not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*options = {
  classid: 'string',
  appdata: {}
}*/

function putClassAppdata(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.classid && options.appdata) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.ClassAppdata;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId, classid: options.classid
      });

      // Setup request with URL and Params
      var requestAPI = request.put(url)
                       .set('Content-Type', 'application/json')
                       .set('Accept', 'application/json')
                       .send(options.appdata);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    } else {
      err = {};
      err.message = err.description = 'classid or appdata not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*options = {
  classid: 'string'
}*/

function deleteClassAppdata(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.classid) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.ClassAppdata;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId, classid: options.classid
      });

      // Setup request with URL and Params
      var requestAPI = request.delete(url);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    } else {
      err = {};
      err.message = err.description = 'classid not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

//options = {
//    classid: '', //Class Id
//    userid: '', //User Id
//};
function enrollUsertoClass(options) {
    var self = this;
	var err = {};
    //Initializing promise
    var dfd = q.defer();
	if(options && options.classid && options.userid) {
		//Validations
		err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) {
			dfd.reject(err);
		} else {
			//Passed all validations, Construct API url
			var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.enrollUsertoClass;
			url = helpers.api.constructAPIUrl(url, {
				orgId: self.orgId,
				classId: options.classid,
                userId: options.userid
			});

			//Contruct parameters
			var params = {};

      //Setup request with URL and Params
      var requestAPI = request.post(url)
                              .set('Content-Type', 'application/json')
                              .set('Accept', 'application/json')
                              .query(params);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

			//Setup token in Authorization header
			requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

			//Call GET Product by it's code Api
			requestAPI.end(function(err, response) {
				if(err) {
					err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
					dfd.reject(err);
				} else {
					dfd.resolve(response.body);
				}
			});
		}
	} else {
		err.message = err.description = 'Mandatory parameter classid or userid not found in request options';
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}
    return dfd.promise;
}

//options = {
//    classid: '', //Class Id
//    classrole: ''
//};
function enrollSelftoClass(options) {
  var self = this;
  var err = {};
  //Initializing promise
  var dfd = q.defer();
  if(options && options.classid) {
    //Validations
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err) {
      dfd.reject(err);
    } else {
      //Passed all validations, Construct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.enrollSelftoClass;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        classId: options.classid
      });

      var params = { classrole: options.classrole };
      //Setup request with URL and Params
      var requestAPI = request.post(url)
                              .set('Content-Type', 'application/json')
                              .set('Accept', 'application/json')
                              .send(params);

      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      //Call GET Product by it's code Api
      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body);
        }
      });
    }
  }
  else {
    err.message = err.description = 'Mandatory parameter classid not found in request options';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

//options = {
//    classid: '', //Class Id
//    users: ['dls-userid1', 'dls-userid-2'] //Users Id
//};
function enrollMultiUserstoClass(options) {
  var self = this;
  var err = {};
  //Initializing promise
  var dfd = q.defer();
  if(options && options.classid && options.users) {
    //Validations
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err) {
      dfd.reject(err);
    } else {
      //Passed all validations, Construct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.enrollMultiUserstoClass;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        classId: options.classid
      });

      //Contruct parameters
      var params = {
        users: options.users
      };
      //Setup request with URL and Params
      var requestAPI = request.post(url)
                              .set('Content-Type', 'application/json')
                              .set('Accept', 'application/json')
                              .send(params);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      //Call GET Product by it's code Api
      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body);
        }
      });
    }
  } else {
    err.message = err.description = 'Mandatory parameter classid or users ' +
        'array not found in request options';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

//options = {
//    classid: '', //Class Id
//    users: ['dls-userid1', 'dls-userid-2'] //Users Id
//};
function unEnrollMultiUserstoClass(options) {
  var self = this;
  var err = {};
  //Initializing promise
  var dfd = q.defer();
  if(options && options.classid && options.users) {
    //Validations
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err) {
      dfd.reject(err);
    } else {
      //Passed all validations, Construct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.enrollMultiUserstoClass;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        classId: options.classid
      });

      //Contruct parameters
      var params = {
        users: options.users
      };
      //Setup request with URL and Params
      var requestAPI = request.delete(url)
                              .set('Content-Type', 'application/json')
                              .set('Accept', 'application/json')
                              .send(params);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      //Call GET Product by it's code Api
      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body);
        }
      });
    }
  } else {
    err.message = err.description = 'Mandatory parameter classid or users ' +
        'array not found in request options';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

//options = {
//    classid: '', //Class Id
//    userid: '', //User Id
//};
function unEnrollUsertoClass(options) {
    var self = this;
	var err = {};
    //Initializing promise
    var dfd = q.defer();
	if(options && options.classid && options.userid) {
		//Validations
		err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) {
			dfd.reject(err);
		} else {
			//Passed all validations, Construct API url
			var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.enrollUsertoClass;
			url = helpers.api.constructAPIUrl(url, {
				orgId: self.orgId,
				classId: options.classid,
                userId: options.userid
			});

			//Contruct parameters
			var params = {};

      //Setup request with URL and Params
      var requestAPI = request.delete(url).query(params);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

			//Setup token in Authorization header
			requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

			//Call GET Product by it's code Api
			requestAPI.end(function(err, response) {
				if(err) {
					err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
					dfd.reject(err);
				} else {
					dfd.resolve(response.body);
				}
			});
		}
	} else {
		err.message = err.description = 'Mandatory parameter classid or userid not found in request options';
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}
    return dfd.promise;
}

//options = ['parameter1', 'parameter2']
function encodeURLParameter(options) {
  var response = {};
  for(var param in options) {
    response[options[param]] = encodeURIComponent(options[param]);
  }
  return response;
}

/**
 * options = {
 * title: 'class title',
 * startdate: 'Epoch(Unix) timestamp in milliseconds',
 * enddate: 'Epoch(Unix) timestamp in milliseconds',
 * description: '',                          // Optional field
 * class_ownership: 'STRICT' / 'NO_OWNER',   // Default - STRICT, Optional field
 * ext_data: {}                              // Optional
 * analyticsharingmodel: ''                  // Optional - Valid values: ['NOINHERIT_SYNCBACK']
 * }
 */
function createClass(options) {
    var self = this;

    //Initializing promise
    var dfd = q.defer();

    //Validations
    var err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err) {
        dfd.reject(err);
    } else {
        if(options && options.title && options.startdate && options.enddate) {
            //Passed all validations, Contruct API url
            var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.createClass;
            url = helpers.api.constructAPIUrl(url,  { orgId: self.orgId });

            //Contruct parameters
            var params = {
              title: options.title,
              startdate: options.startdate,
              enddate: options.enddate
            };

            if(options.description){ params.description = options.description; }
            if(options.class_ownership){ params.class_ownership = options.class_ownership; }
            if(options.ext_data){ params.ext_data = options.ext_data; }
            if(options.analyticsharingmodel){ params.analyticsharingmodel = options.analyticsharingmodel; }

            //Setup request with URL and Params
            var requestAPI = request.post(url).send(params);
            if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

            //Setup token in Authorization header
            requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

            requestAPI.end(function(err, response) {
                if(err) {
                    err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
                    dfd.reject(err);
                } else {
                  var res = converter.convertClassResponse({data: response.body}) ;
                  dfd.resolve(res);
                }
            });
        } else {
            err = {};
            err.message = err.description = 'title or startdate or enddate not found in request options.';
            err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
            dfd.reject(err);
        }
    }
    return dfd.promise;
}

//options = {
//    classid: 'class id',
//    title: 'class title', //Optional field
//    startdate: 'Epoch(Unix) timestamp in milliseconds', //Optional field
//    enddate: 'Epoch(Unix) timestamp in milliseconds', //Optional field
//    description: '',    //Optional field
//    ext_data: ''        //Optional field
//}
function updateClass(options) {
    var self = this;

    //Initializing promise
    var dfd = q.defer();

    //Validations
    var err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err) {
        dfd.reject(err);
    } else {
        if(options && options.classid)
        {
            //Passed all validations, Contruct API url
            var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.specificClass;
            url = helpers.api.constructAPIUrl(url,  { orgId: self.orgId, classId: options.classid });

            //Setup request with URL and Params
            var requestAPI = request.put(url).send(options);
            if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

            //Setup token in Authorization header
            requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

            requestAPI.end(function(err, response) {
                if(err) {
                    err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
                    dfd.reject(err);
                } else {
                    dfd.resolve(response.body);
                }
            });
        } else {
            err = {};
            err.message = err.description = 'Mandatory parameter \'classid\' is not found in request options.';
            err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
            dfd.reject(err);
        }
    }
    return dfd.promise;
}

/** options =
 *{
  "space_title": "string",
  "classes": [
    {
      "title": "class tiltle",
      "startdate": 'Epoch(Unix) timestamp in milliseconds',
      "enddate": 'Epoch(Unix) timestamp in milliseconds',
      "rowId": 'string with max limit 3 characters,
      "description": "string",
      "ext_data": {},                    // optional
      "model": "STRICT",
      "analyticsharingmodel":"NOINHERIT_SYNCBACK"  // optional
      "owner": {
        "userid": "string" //Mandatory if model is 'STRICT'
      },
      "teachers": [
        {
          "userid": "string",
          "email": "string"
          "first_name": "string"
          "last_name": "string"
          "userid": "string"             // optional
          "ext_user_id": "string"        // optional
          "dls_org_status": "string"     // optional
          "ext_account_status": "string" // optional
      ],
      "products": [                      // optional
        {
          "productcode": "string",       //mandatory
          "title": ""
        },
        {
          "productcode": "string",       //mandatory
          "title": ""
        }
      ]
    }
  ],
  "clone_classes": [
    {
      "title": "string",
      "startdate": 0,
      "enddate": 0,
      "instructor": "string",
      "rowId": "string",
      "classid": "string",
      "clone_settings": {
        "students": true,
        "teachers": true,
        "products": true,
        "groups": true,
        "assigned_paths": true,
        "tags": true,
        "analyticsharingmodel": true,
        "ext_data": true,
        "advanced": {
          "students": [ { "ext_user_id": "string" } ],
          "teachers": [ { "ext_user_id": "string" } ],
          "groups": [ { "groupid": "string" } ],
          "assigned_paths": [
            {
              "assigned_path_id": "string",
              "startdate": 0,
              "duedate": 0
            }
          ],
          "products": [ { "productcode": "string" } ]
        }
      }
    }
  ]
}
 */
function createMultipleClasses(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();

  //Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if (err) { dfd.reject(err); }
  else {
    if ((options.classes && options.classes.length > 0) ||
      (options.clone_classes && options.clone_classes.length > 0)) {

      //Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.createMultipleClasses;
      url = helpers.api.constructAPIUrl(url, {
          orgId: self.orgId
      });

      //Setup request with URL and Params and Query
      var requestAPI = request.post(url).send(options);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (err, response) {
        if (err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory parameters - [classes, clone_classes], ' +
                                      'not found in request options';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*
options = {
  "classid": "classid", //mandatory
  "data": {
    "title": "assigned path title", //mandatory
    "duedate": "epoch due date", //mandatory
    "startdate": "epoch start date", //optional
    "shared_progress": true, //optional, default=true
    "path_type": ‘flat’, //optional, default=flat , ['flat', 'hierarchical']
    "rules": {}, //optional
    "items": [  //mandatory
      {
        "item-code": "required_item-code",  //mandatory
        "item_type": "required_item-type",  //mandatory, ['dls-internal','external']
        "dls_product_code": "product_code" //mandatory only if item_type is 'dls-internal'
      }
    ],
    "context": {
       "bundle-code": "string",
       "space_key": "string"
     }
  }
}
*/
function createAssignedPath(options) {
  var self = this;
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.classid && options.data && options.data.title &&
        options.data.duedate && options.data.items && options.data.items.length > 0) {

      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.createAssignedPath;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, classId: options.classid });

      // Setup request with URL and Params
      var requestAPI = request.post(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .send(options.data);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory params - title or classid or duedate or items ' +
                                      'not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*
  options = {
  classid: 'string' //mandatory
  assignedpathid: 'string' //mandatory
  }
*/
function deleteAssignedPath(options) {
  var self = this;
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.classid && options.assignedpathid) {

      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.deleteAssignedPath;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, classId: options.classid, assignedPathId: options.assignedpathid });

      // Setup request with URL and Params
      var requestAPI = request.delete(url);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory params - classid or assignedpathid ' +
                                      'not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*
  options = {
    classid: 'string' //mandatory
    assignedpathid: 'string' //mandatory
    data: 
      { 
        title: 'string' //optional
        startdate: 'string' //optional
        duedate: 'string' //optional
      }
  }
*/
function updateAssignedPath(options) {
  var self = this;
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.classid && options.assignedpathid) {

      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.deleteAssignedPath;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, classId: options.classid, assignedPathId: options.assignedpathid });

      // Setup request with URL and Params
      var requestAPI = request.put(url);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
		  if(options.data) { requestAPI.send(options.data); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory params - classid or assignedpathid ' +
                                      'not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/**
 * options={
  "title": "string", //mandatory
  "startdate": 0, //mandatory
  "enddate": 0, //mandatory
  "path": "string"
}
 */
function createGroup(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    // Validations

    if(options && options.title && options.startdate && options.enddate) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.allGroups;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      // Setup request with URL and Params
      var requestAPI = request.post(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .send(options);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'title or startdate or enddate not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/* options = {
    "path": "string" //mandatory, Path of the group(this path group will also be returned,
    "cursor": "string"
  };
*/
function getAllGroupsByPath(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.path) {

      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.allGroups;
      url = helpers.api.constructAPIUrl(url,{ orgId: self.orgId });

      var queryParams = { path: options.path };
      if(options.cursor) { queryParams.cursor = options.cursor; }

      // Setup request with URL and Params
      var requestAPI = request.get(url).query(queryParams);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory params - path not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/* options = {
    "groupId": "string" //mandatory
  };
*/
function getAGroup(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.groupId) {

      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.aParticularGroup;
      url = helpers.api.constructAPIUrl(url,{ orgId: self.orgId, groupId: options.groupId });

      // Setup request with URL and Params
      var requestAPI = request.get(url);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory params - groupId not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/* options = {
    "groupId": "string" //mandatory
    "body": {
      "title": "string"
      "startdate": "string",
      "enddate":"string"
    }
  };
*/
function updateGroup(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.groupId) {

      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.aParticularGroup;
      url = helpers.api.constructAPIUrl(url,{ orgId: self.orgId, groupId: options.groupId });

      // Setup request with URL and Params
      var requestAPI = request.put(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .send(options.body);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory params - groupId not found in ' +
                                      'request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/* options = {
    "groupId": "string" //mandatory
  };
*/
function deleteGroup(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.groupId) {

      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.aParticularGroup;
      url = helpers.api.constructAPIUrl(url,{ orgId: self.orgId, groupId: options.groupId });

      // Setup request with URL and Params
      var requestAPI = request.delete(url);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory params - groupId not found in ' +
                                      'request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*
  options = {
    groupId: "string", //mandatory
    cursor: "cursor"
  }
*/
function getAllMembersOfAGroup(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer(), params = {};
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  // Validations
  else{
    if(options && options.groupId) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.getAllMembersOfAGroup;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        groupId: options.groupId
      });
  
      // Setup request with URL and Param
      if(options.cursor){ params.cursor = options.cursor };
  
      var requestAPI = request.get(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .send(params);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
  
      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory param - groupId not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*
  options = {
    path: "string", //mandatory
    cursor: "string"
  }
*/
function getAllGroupMembersByPath(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer(), params = {};
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  // Validations
  else {
    if(options && options.path) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.getAllGroupMembersByPath;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId
      });
  
      // Setup request with URL and Params
      params.path = options.path;
      if(options.cursor){ params.cursor = options.cursor };
  
      var requestAPI = request.get(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .query(params);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
  
      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory param - path not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*
  options = {

    groupId: "string", //mandatory
    body: {
      users: [
        {
          id: "string", // User’s external id - mandatory
          dls_user_id: "string", // User’s dls id - mandatory
          email: "string", //mandatory
          first_name: "string", //mandatory
          last_name: "string", //mandatory
          name: "string", //mandatory
          role: "string" //mandatory
        }
      ]
    }
  }
*/
function createMultiUserGroupMembership(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer(), params = {};
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  // Validations

  else {
    if(options && options.groupId && options.body && options.body.users && (options.body.users.length > 0)) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.userGroupMembership;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, groupId: options.groupId });
  
      // Setup request with URL and Params
      params = options.body;
  
      var requestAPI = request.post(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .send(params);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
  
      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory param - groupId or body or body.users(min. 1 user) ' +
                                      'not found in request options.'
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*
  options = {
    "groupId": "string", //mandatory
    "body": {            //mandatory
      users: [           //mandatory
        {
          id: "string" // User’s external id - mandatory
        }
      ]
  }
*/
function deleteMultiUserGroupMembership(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer(), params = {};
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  // Validations
  else {
    if(options && options.groupId && options.body && options.body.users && (options.body.users.length > 0)) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.userGroupMembership;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        groupId: options.groupId
      });
  
      // Setup request with URL and Params
      params = options.body;
      var requestAPI = request.delete(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .send(params);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory param - groupId or body or body.users(min. 1 user) ' +
                                      'not found in request options.'
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/* options= {
   "groupId": "string", //mandatory
  };
*/
function archiveGroup(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if (options && options.groupId) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.archiveAParticularGroup;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        groupId: options.groupId
      });

      // Setup request with URL and Params
      var requestAPI = request.put(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .send({});
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (error, response) {
        if (error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body);
        }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory param - groupId not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/* options= {
   "groupId": "string", //mandatory
  };
*/
function unarchiveGroup(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if (options && options.groupId) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.unarchiveAParticularGroup;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        groupId: options.groupId
      });

      // Setup request with URL and Params
      var requestAPI = request.put(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .send({});
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (error, response) {
        if (error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body);
        }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory param - groupId not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*
  options = {
    userId: "string", //mandatory
    path: "string", //mandatory
    cursor: "string", // optional
  }
*/
function getMyAllMemberships(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer(), params = {};
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  // Validations
  else {
    if(options && options.userId && options.path) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.getMyAllMemberships;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        userId: options.userId
      });
  
      // Setup request with URL and Params
      params.path = options.path;
      if(options.cursor){ params.cursor = options.cursor };
  
      var requestAPI = request.get(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .query(params);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
  
      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory param - userId or path not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*
  options = {
    classId: "string", //mandatory
    body : {
      items :         //mandatory, Min: 1, Max: 200
      [{
        "productcode": "string",
        "item-code": "string",
        "link-statementid": "string",
        "groupid": "string",
        “type”: “dls-internal”, //mandatory
        "data": { ... }
       }]
    }
  }
*/
function addItemsToShowcaseOfAClass(options){
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  // Validations
  else {
    if(options && options.classId && options.body) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.showcaseItems;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, classId: options.classId });

      // Setup request with URL and Params
      var requestAPI = request.post(url);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
      requestAPI.send(options.body);

      // Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // Call Add items to showcase API
      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory param - classId or body not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*
  options = {
    classId: "string", //mandatory
    body : {
      items : [ "id1", "id2", "id3", ... ] //mandatory
    }
  }
*/
function deleteItemsFromShowcaseOfAClass(options){
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  // Validations
  else {
    if(options && options.classId && options.body) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.showcaseItems;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, classId: options.classId });

      // Setup request with URL and Params
      var requestAPI = request.delete(url);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
      requestAPI.send(options.body);

      // Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // Call delete items from showcase API
      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory param - classId or body not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/**
 * options = {
 * classid: 'class id of the class',
 * title: 'title of clone class',
 * startdate: 'Epoch(Unix) timestamp in milliseconds',
 * enddate: 'Epoch(Unix) timestamp in milliseconds',
 * instructor: 'user who clones the class',
 * clone_setting: {},                          // Optional field
 * }
 */
function cloneClass(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();

  //Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) {
    dfd.reject(err);
  } else {
    if(options && options.title && options.startdate && options.enddate
      && options.instructor && options.classid) {
      //Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.cloneClass;
      url = helpers.api.constructAPIUrl(url,  { orgId: self.orgId, classId: options.classid });

      //Setup request with URL and Params
      var requestAPI = request.post(url).send(options);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body);
        }
      });
    } else {
      err = {};
      err.message = err.description = 'title or startdate or enddate or instructor or classid not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}
