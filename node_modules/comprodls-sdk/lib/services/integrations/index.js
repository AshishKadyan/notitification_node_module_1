/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

/***********************************************************
 * comproDLS SDK AUTH API Adaptor
 * Functions for calling AUTH API.
 ************************************************************/

var q = require('q');
var request = require('superagent');

var helpers = require('../../helpers');
var converter = require('../../helpers/lib/api/converter');

var DLSError = helpers.errors.DLSError;

/*********************************
 * Setting Up Module Entry Point
 **********************************/
module.exports = integrations;

//Integrations Adaptor Constructor
function integrations(accountId) {
    this.accountId = accountId;
  return {
      getGetStreamCredentials: getGetStreamCredentials.bind(this),
      queryDataFromSearch: queryDataFromSearch.bind(this),
      getAuditTrailForAttempts: getAuditTrailForAttempts.bind(this),
      getAuditTrailForEntitlements: getAuditTrailForEntitlements.bind(this),
      getAuditTrailForMicroEntitlements: getAuditTrailForMicroEntitlements.bind(this),
      publishCustomEvents: publishCustomEvents.bind(this),
      createSchedule: createSchedule.bind(this),
      getSchedule: getSchedule.bind(this),
      updateSchedule: updateSchedule.bind(this)
  };
}

//params: NONE
function getGetStreamCredentials() {
  var self = this;
  var dfd = q.defer(), err;

  var url = self.config.DEFAULT_HOSTS.INTEGRATION +
            self.config.INTEGRATIONS_API_URLS.getGetStreamCredentials;
  url = helpers.api.constructAPIUrl(url, { accountId: self.accountId });

  // Setup request with URL and Params
  var requestAPI = request.post(url)
  .set('Content-Type', 'application/json')
  .set('Accept', 'application/json')
  .send();
  if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

  requestAPI.end(function (error, response) {
    if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
    }
    else {  dfd.resolve(response); }
  });
  return dfd.promise;
}

/*
  options = {
  index: 'string', //mandatory
  query: 'string' //mandatory
  }
*/
function queryDataFromSearch(options) {
  var self = this;
  var dfd = q.defer();
  var err;

  if(options && options.index && options.query) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.INTEGRATION +
            self.config.INTEGRATIONS_API_URLS.queryDataFromSearch;
    url = helpers.api.constructAPIUrl(url, { index: options.index });

    // Contruct parameters
    var params = {
      query: options.query
    };

    //Setup request with URL and Params
    var requestAPI = request.get(url).query(params);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if (err) {
        var esErrOptions = { type: helpers.errors.ERROR_TYPES.API_ERROR, err: err };
        var error = converter.convertElasticsearchErrResponse(esErrOptions);
        dfd.reject(error);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Mandatory params - index, type or query ' +
      'not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/*
options = {
  accountid: 'string',
  action: 'string',
  userid: 'string',
  productcode: 'string',
  item-code: 'string',
  sortOrder: 'asc/desc', // optional
  cursor: 'string'
}
*/
function getAuditTrailForAttempts(options) {
  var self = this;
  var dfd = q.defer();
  var err;

  if (options && options.accountid && options.action &&
    options.userid && options.productcode && options['item-code']) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.INTEGRATION +
      self.config.INTEGRATIONS_API_URLS.auditTrail;
    url = helpers.api.constructAPIUrl(url, { accountId: options.accountid });

    // Contruct parameters
    var params = {
      audit_context: 'ATTEMPT-' + options.accountid + '#' + options.userid,
      target_context: 'PRODUCT-' + options.productcode + '#' + options['item-code'],
      action: options.action
    };
    if(options.cursor) { params.cursor = options.cursor; }
    if(options.sortOrder) { params.sortOrder = options.sortOrder; }

    //Setup request with URL and Params
    var requestAPI = request.get(url).query(params);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if(err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Mandatory params - accountid, action,  userid, ' +
      'productcode or item-code not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/*
options = {
  accountid: 'string',
  action: 'string',
  userid: 'string',
  productcode: 'string',
  sortOrder: 'asc/desc', // optional
  cursor: 'string'
}
*/
function getAuditTrailForEntitlements(options) {
  var self = this;
  var dfd = q.defer();
  var err;

  if(options && options.accountid && options.action &&
    options.userid && options.productcode) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.INTEGRATION +
      self.config.INTEGRATIONS_API_URLS.auditTrail;
    url = helpers.api.constructAPIUrl(url, { accountId: options.accountid });

    // Contruct parameters
    var params = {
      audit_context: 'ENTITLEMENT-' + options.accountid + '#' + options.userid,
      target_context: 'PRODUCT-' + options.productcode,
      type: 'entitlement',
      action: options.action
    };
    if(options.cursor) { params.cursor = options.cursor; }
    if(options.sortOrder) { params.sortOrder = options.sortOrder; }

    //Setup request with URL and Params
    var requestAPI = request.get(url).query(params);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if(err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Mandatory params - accountid, userid or productcode ' +
      'not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/*
options = {
  accountid: 'string',
  action: 'string',
  userid: 'string',
  productcode: 'string',
  sortOrder: 'asc/desc', // optional
  context: 'string',
  cursor: 'string'
}
*/
function getAuditTrailForMicroEntitlements(options) {
  var self = this;
  var dfd = q.defer();
  var err;

  if(options && options.accountid && options.action &&
    options.userid && options.productcode && options.context) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.INTEGRATION +
      self.config.INTEGRATIONS_API_URLS.auditTrail;
    url = helpers.api.constructAPIUrl(url, { accountId: options.accountid });

    // Contruct parameters
    var params = {
      audit_context: 'ENTITLEMENT-' + options.accountid + '#' + options.userid,
      target_context: 'PRODUCT-' + options.productcode + '#' + options.context,
      type: 'micro-entitlement',
      action: options.action
    };
    if(options.cursor) { params.cursor = options.cursor; }
    if(options.sortOrder) { params.sortOrder = options.sortOrder; }

    //Setup request with URL and Params
    var requestAPI = request.get(url).query(params);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if(err){
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Mandatory params - accountid, action, userid, productcode ' +
      'or context not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/**
 * Publish custom events and send push notifications
 * @param {
 *   *events: [{
 *     *ext_actor_id: 'string',
 *     *category: "string",
 *     *action: 'string',
 *     *data: {...},
 *     push: <boolean, default: false
 *     ref_id: 'string'
 *   }, ...]
 * } options
 */
function publishCustomEvents(options) {
  var deferred = q.defer();
  var self = this, err;

  if (options && options.events) {
    // Construct API url
    var url = self.config.DEFAULT_HOSTS.INTEGRATION + self.config.INTEGRATIONS_API_URLS.customEvents;
    url = helpers.api.constructAPIUrl(url, { accountId: self.accountId });

    // Setup request with URL and Params
    var requestAPI = request.post(url)
                            .set('Content-Type', 'application/json')
                            .set('Accept', 'application/json')
                            .send(options);

    if (self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (error, response) {
      if (error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        deferred.reject(err);
      } else {
        deferred.resolve(response.body);
      }
    });
  } else {
    err = {};
    err.message = err.description = 'Mandatory params - events not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    deferred.reject(err);
  }

  return deferred.promise;
}

/*
  options = {
    accountid: "string", //mandatory
    context: "string", //mandatory
    body: {
        "scheduleid": "",  //mandatory
        "orgid": "",  // optional
        "actorid": "",  //mandatory
        "classid": "",  // optional
        "assigned_path_id": "",  // optional
        "productcode": "",  // optional
        "userid": "", // optional
        "category": "", //mandatory
        "data": {}, // optional
        "schedule_time" : ""  //mandatory
    }
  }
*/
function createSchedule(options) {
  var deferred = q.defer();
  // Initializing promise
  var self = this, err;

  if (options && options.context && options.accountid && options.body && (Object.keys(options.body).length > 0) &&
  options.body.scheduleid && options.body.actorid && options.body.category && options.body.schedule_time) {
    // Construct API url
    var url = self.config.DEFAULT_HOSTS.INTEGRATION + self.config.INTEGRATIONS_API_URLS.schedules;
    url = helpers.api.constructAPIUrl(url, { accountId: options.accountid, context: options.context });

    // Setup request with URL and Params
    var requestAPI = request.post(url)
                            .set('Content-Type', 'application/json')
                            .set('Accept', 'application/json')
                            .send(options.body);

    if (self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (error, response) {
      if (error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        deferred.reject(err);
      } else {
        deferred.resolve(response.body);
      }
    });
  } else {
    err = {};
    err.message = err.description = 'Mandatory param - accountid or context or body(scheduleid or actorid or '+
                                    'category or schedule_time) not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    deferred.reject(err);
  }

  return deferred.promise;
}

/*
  options = {
    accountid: "string", //mandatory
    context: "string", //mandatory
    category: "string", //optional
    scheduleid: "string", //optional
    cursor: "string"  //optional
  }
*/
function getSchedule(options) {
  var deferred = q.defer();
  // Initializing promise
  var self = this, err;

  if (options && options.context && options.accountid) {
    // Construct API url
    var url = self.config.DEFAULT_HOSTS.INTEGRATION + self.config.INTEGRATIONS_API_URLS.schedules;
    url = helpers.api.constructAPIUrl(url, { accountId: options.accountid, context: options.context });

    var params = {};
    if(options.cursor) { params.cursor = options.cursor; }
    if(options.category) { params.category = options.category; }
    if(options.scheduleid) { params.scheduleid = options.scheduleid; }

    //Setup request with URL and Params
    var requestAPI = request.get(url).query(params);
    if (self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (error, response) {
      if (error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        deferred.reject(err);
      } else {
        deferred.resolve(response.body);
      }
    });
  } else {
    err = {};
    err.message = err.description = 'Mandatory params - accountid or context not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    deferred.reject(err);
  }

  return deferred.promise;
}


/*
  options = {
    accountid: "string", //mandatory
    context: "string", //mandatory
    scheduleid: "string", //mandatory
    body: {
        "schedule_time" : "",  // optional
        "category": "", //mandatory
        "orgid": "",  // optional
        "actorid": "",  //mandatory
        "userid": "", // optional
        "classid": "",  // optional
        "assigned_path_id": "",  // optional
        "productcode": "",  // optional
        "data": {} // optional
    }
  }
*/
function updateSchedule(options) {
  var deferred = q.defer();
  // Initializing promise
  var self = this, err;

  if (options && options.context && options.accountid && options.scheduleid && options.body &&
     (Object.keys(options.body).length > 0) && options.body.actorid && options.body.category) {
    // Construct API url
    var url = self.config.DEFAULT_HOSTS.INTEGRATION + self.config.INTEGRATIONS_API_URLS.updateSchedule;
    url = helpers.api.constructAPIUrl(url, { accountId: options.accountid, context: options.context, scheduleId: options.scheduleid });

    // Setup request with URL and Params
    var requestAPI = request.put(url)
                            .set('Content-Type', 'application/json')
                            .set('Accept', 'application/json')
                            .send(options.body);

    if (self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (error, response) {
      if (error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        deferred.reject(err);
      } else {
        deferred.resolve(response.body);
      }
    });
  } else {
    err = {};
    err.message = err.description = 'Mandatory param - accountid or context or scheduleid or ' + 
                                    'body(category or actorid) not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    deferred.reject(err);
  }

  return deferred.promise;
}