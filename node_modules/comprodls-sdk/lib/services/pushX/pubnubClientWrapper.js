var pubNub = require("pubnub");
var EventEmitter = require("events").EventEmitter;
var helpers = require('../../helpers');

var PUSHXError = helpers.errors.PUSHXError;

var CHANNEL_DELIMITER = '$';

/**
 * Clientwrapper module.
 * Purpose -  Wrapper around the Saas client SDK (PubNub). Abstracts the provider/vendor (PubNun) specific
 * implementation details - allowing future switch (to a different Saas provider).
 */
module.exports = function () {
    "use strict";

    /** ====== MODULE GLOBALS */
    var _pubnubClient; //SAAS provider client SDK (PubNub).
    var _eventEmitter = new EventEmitter();
    var _userOptions;
    var _globalSubscription = [];
    var _globalSubscriptionStatus = {};
    var bStatusSubscribed = false;

    /** ###### END OF MODULE GLOBALS */

    /** ====== UTILITY FUNCTIONS */


    /**
    * Call this function to make a new client adaptor.
      This adapter exposes functions to send message, update user state etc.
    * @return (object) : client adapter.
    */
    var _constructClientAdaptor = function () {
        //Returning the adaptor (Plain Javascript object)
        return {
            "on": function (channelObj, handler) {
                var pubNubChannel;
                var channelContext = [];

                if((channelObj.orgid || channelObj.userid) || channelObj.accountid ||
                    channelObj.productid || channelObj.classid)
                {
                  if(channelObj.accountid) { channelContext.push('a-' + channelObj.accountid); }
                  else {
                    if(channelObj.orgid) { channelContext.push('o-' + channelObj.orgid); }
                    if(channelObj.userid) { channelContext.push('u-' + channelObj.userid); }
                    if(channelObj.productid) { channelContext.push('p-' + channelObj.productid); }
                    if(channelObj.classid) { channelContext.push('c-' + channelObj.classid); }
                  }
                  pubNubChannel = channelContext.join(CHANNEL_DELIMITER) + CHANNEL_DELIMITER +
                                  channelObj.channel;
                  if(!_globalSubscription.includes(pubNubChannel)) {
                    _globalSubscription.push(pubNubChannel);
                    _globalSubscriptionStatus[pubNubChannel] = {
                        status: 'pending'
                    };
                    _eventEmitter.on(pubNubChannel, handler);
                    _subscribeToPubNubChannels(pubNubChannel);
                  }
                }
                else if(channelObj.channel === 'pushx_status' && ! bStatusSubscribed) {
                    _eventEmitter.on(channelObj.channel, handler);
                    bStatusSubscribed = true;
                }
            },
            "getMySubscriptionStatus": __getMySubscriptionStatus
        };
    };

    var _translatePubnubMessage = function (pubNubEventData) {
        var subscribedChannel = pubNubEventData.subscribedChannel;
        var message = pubNubEventData.message;
        _eventEmitter.emit(subscribedChannel, message);
    };

    var _translatePubnubStatus = function(status) {
        var channels = [], error, successObj;
        switch (status.category) {
            case "PNConnectedCategory":
                if(status.operation === "PNSubscribeOperation") {
                    channels = status.subscribedChannels;
                    for(var i in channels) {
                        if(_globalSubscriptionStatus[channels[i]]) {
                            _globalSubscriptionStatus[channels[i]].status = 'subscribed';
                        }
                    }
                    successObj = {
                        category: 'PUSHX',
                        type: 'CHANNEL_SUBSCRIPTION',
                        status: 'SUCCESS',
                        message: 'Success: Subscribed successfully.',
                        httpcode: 200,
                        data: {
                            payload: {
                                channels: status.subscribedChannels
                            },
                            message: 'Success: Subscribed successfully.'
                        }
                    };
                    _eventEmitter.emit('pushx_status', successObj);
                }
                break;
            case "PNAccessDeniedCategory":
                if(status.operation === "PNSubscribeOperation") {
                    var errorData = {
                        payload: JSON.parse(status.errorData.response.text).payload,
                        message: 'Forbidden: Subscription failed.',
                        errorDetails: {
                            operation: status.operation,
                            category: status.category,
                            statusCode: status.statusCode
                        }
                    };
                    channels = errorData.payload.channels;
                    for(var j in channels) {
                        if(_globalSubscriptionStatus[channels[j]]) {
                            _globalSubscriptionStatus[channels[j]].status = 'error';
                            _globalSubscriptionStatus[channels[j]].error = error;
                        }
                    }
                    error = new PUSHXError(helpers.errors.ERROR_CATEGORY.PUSHX, errorData);
                    _eventEmitter.emit('pushx_status', error);
                }
                break;
            case "PNBadRequestCategory":
            case "PNNetworkDownCategory":
            case "PNNetworkUpCategory":
                error = {
                    message: "PushX Error", status: status.statusCode,
                    pushXError: status
                };
                error = new PUSHXError(helpers.errors.ERROR_CATEGORY.PUSHX, error);
                _eventEmitter.emit('pushx_status', error);
                break;
        }
    };

    var __getMySubscriptionStatus = function() {
        return JSON.parse(JSON.stringify(_globalSubscriptionStatus));
    };

    /**
     * Sets up necessary subscriptions (Pub/Sub) to PUSH channels. To a large extent, subscriptions are
     * driven the student's (instructor's) roster.
     * @param {object} groups - Roster information, provided during initialization, wrapper.setup().
     */
    var _subscribeToPubNubChannels = function (channel) {
        _pubnubClient.subscribe({ // Calling Pubnub SDK
            "channels": [channel]
        });
    };

    /** ###### END OF UTILITY FUNCTIONS ############ */

    /** ====== Client Wrapper Member functions ==> Mapped to Public Methods */

    /**
     * Initializes the library, and established a connection with the Saas/PUSH provider.
     * Setup should be called only once i.e. ONE CONNECTION (on a page/tab) is allowed
     * at a time. If called again, it will throw an error (failure callback).
     *
     * @param {object} userOptions - User auth key and pubnub credentials
     * @returns PROMISE.
     */
    var __setup = function (userOptions) {
        var pubnubConfig = userOptions.pubnub;
        pubnubConfig.uuid = userOptions.userid;

        if (!_pubnubClient && pubnubConfig) {
            _pubnubClient = new pubNub(pubnubConfig); //Connect with PubNub SDK
            processSetup();
        } else {
            return new Error('Already Initialized');
        }

        /**
         * SYNC Function
         */
        function processSetup() {
            _userOptions = userOptions;
            _pubnubClient.addListener({ //Setup Listeners (events will shows up after subscription)
                "message": function (data) {
                    _translatePubnubMessage(data);
                },
                "status": function (status) {
                    _translatePubnubStatus(status);
                }
            });
        }
        return _constructClientAdaptor();
    }; //End of _setup()

    var __cleanup = function () {
        if (_pubnubClient) { //Skip cleanup if setup() was not called.
            _pubnubClient.unsubscribeAll();
            _pubnubClient.stop();
            _globalSubscription = [];
            bStatusSubscribed = false;
            _globalSubscriptionStatus = {};
        }
        _pubnubClient = undefined;
    };

    return { // Return public methods for the wrapper
        "setup": __setup,
        "cleanup": __cleanup
    };

}; //End of Client Wrapper module
