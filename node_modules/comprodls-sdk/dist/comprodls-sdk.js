(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.ComproDLS = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/
/***********************************************************
 * comproDLS SDK Main Module
 * This module provides definition of SDK for Javascript
 ************************************************************/
var token_manager = require('./token');
var helpers = require('./helpers');
var auth = require('./services/auth');
var activity = require('./services/activity');
var analytics = require('./services/analytics');
var collab = require('./services/collab');
var product = require('./services/product');
var xapi = require('./services/xapi');
var attempts = require('./services/attempts');
var push = require('./services/push');
var pushX = require('./services/pushX');
var pub = require('./services/pub');
var sisevents = require('./services/sisevents');
var lrs = require('./services/lrs');
var spaces = require('./services/spaces');
var config = require('./config');
var open_access = require('./open_access');
var superuser = require('./services/superuser');
var invitations = require('./services/invitations');
var workflows = require('./services/workflows');
var integrations = require('./services/integrations');
var validations = require('./token/validations');
var drive = require('./services/drive');
var taxonomy = require('./services/taxonomy');
var rules = require('./services/rules');


/*********************************
 * Setting Up Module Entry Point
 **********************************/
exports.init = init;

//Factory function to create and return a new SDK object/instance
function init(environment, realm, options) {
    return new comproDLS(environment, realm, options);
};

// Constructor for the SDK object
function comproDLS(environment, realm, options) {
    options = options || {};
    environment = environment || 'production';
    realm = realm || 'global';
    /*
     * Instance level parameters, used across all API calls. These are set to null.
     * Either authWithToken or authWithCredentials must be called to set these
     * with valid values.
     */

    /* API Token is a JSON Object with following structure
     *  {
	 *     "access_token" : [String]
     *  }
     */
    this.token = null;

    //Organization Id
    this.orgId = null;
    this.traceid = options.traceid;

    try {
      config.DEFAULT_HOSTS = config.REALM_HOSTS[realm.toUpperCase()][environment.toUpperCase()];
      if(!config.DEFAULT_HOSTS){ throw 'Invalid Environment'; }
    }
    catch (e){
      var realmObj = config.REALM_HOSTS[realm.toUpperCase()];
      var err;

      if(!realmObj) { err = new Error('Invalid Realm: ' + realm); }
      else if(!realmObj[environment.toUpperCase()]) {
        err = new Error('Invalid Environment: ' + environment);
      }
      throw err;
    }

    this.config = config;
    this.environment = environment;

    if(options.orgid && options.token) {
      var err = validations.authWithToken(options.orgid, options.token, {});
      if (err) { throw err; }
      else {
        this.token = options.token;
        this.orgId = options.orgid;
      }
    }
  // This is the case when api requires orgid but not token
    else if(options.orgid) {
      this.orgId = options.orgid;
    }
}

/****************************************
 * Setting Up SDK Public Functions/Objects
 *****************************************/
//Token Management
comproDLS.prototype.authWithCredentials = token_manager.authWithCredentials;
comproDLS.prototype.authWithToken = token_manager.authWithToken;
comproDLS.prototype.authWithExtUser = token_manager.authWithExtUser;

//Open Access SDK Functions
comproDLS.prototype.getClassEnrolmentsStat = open_access.getClassEnrolmentsStat;
comproDLS.prototype.getSingleInvitation = open_access.getSingleInvitation;

//Generic API Caller / Adaptor
comproDLS.prototype.request = helpers.api.genericAPICaller;

//Custom Service Adaptors
comproDLS.prototype.Auth = auth;
comproDLS.prototype.Activity = activity;
comproDLS.prototype.Analytics = analytics;
comproDLS.prototype.Collab = collab;
comproDLS.prototype.Product = product;
comproDLS.prototype.Xapi = xapi;
comproDLS.prototype.Attempts = attempts;
comproDLS.prototype.Push = push;
comproDLS.prototype.Pub = pub;
comproDLS.prototype.SISEvents = sisevents;
comproDLS.prototype.LRS = lrs;
comproDLS.prototype.PushX = pushX;
comproDLS.prototype.Spaces = spaces;
comproDLS.prototype.Superuser = superuser;
comproDLS.prototype.Invitations = invitations;
comproDLS.prototype.Workflows = workflows;
comproDLS.prototype.Integrations = integrations;
comproDLS.prototype.Drive = drive;
comproDLS.prototype.Taxonomy = taxonomy;
comproDLS.prototype.Rules = rules;

},{"./config":2,"./helpers":3,"./open_access":10,"./services/activity":13,"./services/analytics":14,"./services/attempts":15,"./services/auth":16,"./services/collab":17,"./services/drive":18,"./services/integrations":19,"./services/invitations":20,"./services/lrs":21,"./services/product":22,"./services/pub":23,"./services/push":26,"./services/pushX":24,"./services/rules":27,"./services/sisevents":28,"./services/spaces":29,"./services/superuser":30,"./services/taxonomy":31,"./services/workflows":32,"./services/xapi":33,"./token":34,"./token/validations":35}],2:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

/***********************************************************
 * comproDLS SDK Configuration
 * This module provides configuration for comproDLS SDK
 ************************************************************/

/****************************************************
 * Setting up Exports/Public functions and variables
 *****************************************************/

exports.REALM_HOSTS = {
  GLOBAL: {
    PROD1: {
      PUB: 'http://internal-dls-global-prod1-1755536919.us-west-2.elb.amazonaws.com/lb-pub',
      AUTH: 'http://internal-dls-global-prod1-1755536919.us-west-2.elb.amazonaws.com/lb-auth',
      PUSHX: 'http://internal-dls-global-prod1-1755536919.us-west-2.elb.amazonaws.com/lb-pushx',
      XAPI: 'http://internal-dls-global-prod1-1755536919.us-west-2.elb.amazonaws.com/lb-xapi',
      ATTEMPTS: 'http://internal-dls-global-prod1-1755536919.us-west-2.elb.amazonaws.com/lb-attempts',
      PRODUCT: 'http://internal-dls-global-prod1-1755536919.us-west-2.elb.amazonaws.com/lb-product', 
      ANALYTICS: 'http://internal-dls-global-prod1-1755536919.us-west-2.elb.amazonaws.com/lb-analytics',
      INTEGRATION: 'http://internal-dls-global-prod1-1755536919.us-west-2.elb.amazonaws.com/lb-integrations',
      DRIVE: 'http://internal-dls-global-prod1-1755536919.us-west-2.elb.amazonaws.com/lb-drive'
    }
  },
  ASGARD: {
    THOR: {
      PUB: 'http://dls-asgard-thor-1453383019.us-west-2.elb.amazonaws.com/lb-pub',
      AUTH: 'http://dls-asgard-thor-1453383019.us-west-2.elb.amazonaws.com/lb-auth',
      PUSHX: 'http://dls-asgard-thor-1453383019.us-west-2.elb.amazonaws.com/lb-pushx',
      XAPI: 'http://dls-asgard-thor-1453383019.us-west-2.elb.amazonaws.com/lb-xapi',
      ATTEMPTS: 'http://dls-asgard-thor-1453383019.us-west-2.elb.amazonaws.com/lb-attempts',
      PRODUCT: 'http://dls-asgard-thor-1453383019.us-west-2.elb.amazonaws.com/lb-product',
      ANALYTICS: 'http://dls-asgard-thor-1453383019.us-west-2.elb.amazonaws.com/lb-analytics',
      INTEGRATION: 'http://dls-asgard-thor-1453383019.us-west-2.elb.amazonaws.com/lb-integrations',
      DRIVE: 'http://dls-asgard-thor-1453383019.us-west-2.elb.amazonaws.com/lb-drive'
    }
  },
  CUP: {
    ALPHA: {
      PUB: 'http://dls-cup-alpha-2093819659.us-west-2.elb.amazonaws.com/lb-pub',
      AUTH: 'http://dls-cup-alpha-2093819659.us-west-2.elb.amazonaws.com/lb-auth',
      PUSHX: 'http://dls-cup-alpha-2093819659.us-west-2.elb.amazonaws.com/lb-pushx',
      XAPI: 'http://dls-cup-alpha-2093819659.us-west-2.elb.amazonaws.com/lb-xapi',
      ATTEMPTS: 'http://dls-cup-alpha-2093819659.us-west-2.elb.amazonaws.com/lb-attempts',
      PRODUCT: 'http://dls-cup-alpha-2093819659.us-west-2.elb.amazonaws.com/lb-product',
      ANALYTICS: 'http://dls-cup-alpha-2093819659.us-west-2.elb.amazonaws.com/lb-analytics',
      INTEGRATION: 'http://dls-cup-alpha-2093819659.us-west-2.elb.amazonaws.com/lb-integrations',
      DRIVE: 'http://dls-cup-alpha-2093819659.us-west-2.elb.amazonaws.com/lb-drive'
    },
    PROD1: {
      PUB: 'http://internal-dls-cup-prod1-284466545.us-west-2.elb.amazonaws.com/lb-pub',
      AUTH: 'http://internal-dls-cup-prod1-284466545.us-west-2.elb.amazonaws.com/lb-auth',
      PUSHX: 'http://internal-dls-cup-prod1-284466545.us-west-2.elb.amazonaws.com/lb-pushx',
      XAPI: 'http://internal-dls-cup-prod1-284466545.us-west-2.elb.amazonaws.com/lb-xapi',
      ATTEMPTS: 'http://internal-dls-cup-prod1-284466545.us-west-2.elb.amazonaws.com/lb-attempts',
      PRODUCT: 'http://internal-dls-cup-prod1-284466545.us-west-2.elb.amazonaws.com/lb-product',
      ANALYTICS: 'http://internal-dls-cup-prod1-284466545.us-west-2.elb.amazonaws.com/lb-analytics',
      INTEGRATION: 'http://internal-dls-cup-prod1-284466545.us-west-2.elb.amazonaws.com/lb-integrations',
      DRIVE: 'http://internal-dls-cup-prod1-284466545.us-west-2.elb.amazonaws.com/lb-drive'
    },
    QA: {
      PUB: 'http://internal-dls-cup-qa-41690511.us-west-2.elb.amazonaws.com/lb-pub',
      AUTH: 'http://internal-dls-cup-qa-41690511.us-west-2.elb.amazonaws.com/lb-auth',
      PUSHX: 'http://internal-dls-cup-qa-41690511.us-west-2.elb.amazonaws.com/lb-pushx',
      XAPI: 'http://internal-dls-cup-qa-41690511.us-west-2.elb.amazonaws.com/lb-xapi',
      ATTEMPTS: 'http://internal-dls-cup-qa-41690511.us-west-2.elb.amazonaws.com/lb-attempts',
      PRODUCT: 'http://internal-dls-cup-qa-41690511.us-west-2.elb.amazonaws.com/lb-product',
      ANALYTICS: 'http://internal-dls-cup-qa-41690511.us-west-2.elb.amazonaws.com/lb-analytics',
      INTEGRATION: 'http://internal-dls-cup-qa-41690511.us-west-2.elb.amazonaws.com/lb-integrations',
      DRIVE: 'http://internal-dls-cup-qa-41690511.us-west-2.elb.amazonaws.com/lb-drive'
    },
    HFX: {
      PUB: 'http://internal-dls-cup-hfx-908523553.us-west-2.elb.amazonaws.com/lb-pub',
      AUTH: 'http://internal-dls-cup-hfx-908523553.us-west-2.elb.amazonaws.com/lb-auth',
      PUSHX: 'http://internal-dls-cup-hfx-908523553.us-west-2.elb.amazonaws.com/lb-pushx',
      XAPI: 'http://internal-dls-cup-hfx-908523553.us-west-2.elb.amazonaws.com/lb-xapi',
      ATTEMPTS: 'http://internal-dls-cup-hfx-908523553.us-west-2.elb.amazonaws.com/lb-attempts',
      PRODUCT: 'http://internal-dls-cup-hfx-908523553.us-west-2.elb.amazonaws.com/lb-product',
      ANALYTICS: 'http://internal-dls-cup-hfx-908523553.us-west-2.elb.amazonaws.com/lb-analytics',
      INTEGRATION: 'http://internal-dls-cup-hfx-908523553.us-west-2.elb.amazonaws.com/lb-integrations',
      DRIVE: 'http://internal-dls-cup-hfx-908523553.us-west-2.elb.amazonaws.com/lb-drive'
    },
    REL: {
      PUB: 'http://internal-dls-cup-rel-1458752944.us-west-2.elb.amazonaws.com/lb-pub',
      AUTH: 'http://internal-dls-cup-rel-1458752944.us-west-2.elb.amazonaws.com/lb-auth',
      PUSHX: 'http://internal-dls-cup-rel-1458752944.us-west-2.elb.amazonaws.com/lb-pushx',
      XAPI: 'http://internal-dls-cup-rel-1458752944.us-west-2.elb.amazonaws.com/lb-xapi',
      ATTEMPTS: 'http://internal-dls-cup-rel-1458752944.us-west-2.elb.amazonaws.com/lb-attempts',
      PRODUCT: 'http://internal-dls-cup-rel-1458752944.us-west-2.elb.amazonaws.com/lb-product',
      ANALYTICS: 'http://internal-dls-cup-rel-1458752944.us-west-2.elb.amazonaws.com/lb-analytics',
      INTEGRATION: 'http://internal-dls-cup-rel-1458752944.us-west-2.elb.amazonaws.com/lb-integrations',
      DRIVE: 'http://internal-dls-cup-rel-1458752944.us-west-2.elb.amazonaws.com/lb-drive'
    }
  }
};

exports.AUTH_API_URLS = {
    getSettings: '/org/{orgId}/settings',
    getTokenAPI: '/auth/{orgId}/token',
    getExtUserTokenAPI: '/auth/{orgId}/ext-users/token',
    userInfoAPI: '/org/{orgId}/users/{userId}',
    pisImportAPI: '/org/{orgId}/pis_imports',
    getAllUsersAPI: '/org/{orgId}/users/all',
    updateUserRoleAPI: '/org/{orgId}/users/{userId}/update-role',
    getSettingsField: '/org/{orgId}/settings/{field}',
    getClassUsersAPI: '/org/{orgId}/class/{classId}/users',
    getUserClassesAPI: '/org/{orgId}/users/{userId}/classes',
    getAllJobs: '/accounts/{accountId}/ext-users/{extUserId}/jobs',
    getJob: '/accounts/{accountId}/ext-users/{extUserId}/jobs/{jobId}',
    getAllClassesAPI: '/org/{orgId}/classes',
    getParticularClassAPI: '/org/{orgId}/classes/{classId}',
    getParticularShadowClassAPI: '/org/{orgId}/shadow/classes/{extClassId}',
    classProductAssociation: '/org/{orgId}/classes/{classId}/associate-product/{productcode}',
    multiClassProductAssociations: '/org/{orgId}/classes/{classId}/associate-product/multi',
    enrollUsertoClass: '/org/{orgId}/classes/{classId}/enroll-user/{userId}',
    enrollSelftoClass: '/org/{orgId}/classes/{classId}/enroll-self',
    enrollMultiUserstoClass: '/org/{orgId}/classes/{classId}/enroll-user/multi',
    createClass: '/org/{orgId}/classes',
    createMultipleClasses: '/org/{orgId}/classes/multi',
    specificClass: '/org/{orgId}/classes/{classId}',
    cloneClass: '/org/{orgId}/classes/{classId}/clone',

    ClassAppdata: '/org/{orgId}/classes/{classid}/appdata',

    generateClassCode: '/org/{orgId}/classes/{classId}/class-code/generate',

    // spaces related API
    getUserSpaces: '/accounts/{accountid}/ext-users/{extuserid}/spaces',
    validateSpaceCode: '/accounts/{accountid}/space-code/validate',
    validateClassCode: '/accounts/{accountid}/class-code/validate',
    joinInstituteSpace: '/accounts/{accountid}/join-institute-space',
    provisionSpacesToStudent: '/accounts/{accountId}/student/provision-spaces',
    provisionSpacesToTeacher: '/accounts/{accountId}/teacher/provision-spaces',
    shadowProvision: '/org/{orgId}/shadow-provision',
    provisionBulkSpaces: '/org/{orgId}/provision-spaces/bulk',
    entitleUserToProduct: '/accounts/{accountId}/entitle-user',
    microEntitleUserToProduct: '/accounts/{accountId}/entitle-user/micro',
    bulkMicroEntitleProductToUser: '/accounts/{accountId}/entitle-user/micro/bulk',
    enrollUserInClass: '/accounts/{accountId}/enroll-with-classcode',
    getExtProductAPI: '/accounts/{accountId}/products/{extProductId}',
    getSpaceDetails: '/accounts/{accountId}/spaces/{spacekey}',
    updateUserInformation: '/accounts/{accountId}/update-user-information',
    getInvitationsByEmail: '/accounts/{accountid}/invitations-by-email',
    generateSpaceCode: '/accounts/{accountid}/space-code/generate',
    changeSpaceCode: '/accounts/{accountid}/space-code/{spacecode}/change',
    updateInstituteTitle: '/accounts/{accountId}/institute-spaces/{instituteSpaceCode}',

    //Superuser related API
    getAllInstitutions: '/su/accounts/{accountid}/spaces',
    getInstitution: '/su/accounts/{accountid}/spaces/{spacecode}',
    provisionSpacesToSuperAdmin: '/su/accounts/{accountid}/superadmin/provision-spaces',

    //Superuser related API
    sendInvitations: '/org/{orgId}/invitations',
    getMultiInvitations: '/org/{orgId}/invitations',
    getSingleInvitation: '/org/{orgId}/invitations/{invitationId}',
    revokeSingleInvitation: '/org/{orgId}/invitations/{invitationid}/revoke',
    completeSingleInvitation: '/org/{orgId}/invitations/{invitationid}/complete',
    resendSingleInvitation: '/org/{orgId}/invitations/{invitationid}/resend',
    //AssignedPath related API
    createAssignedPath: '/org/{orgId}/classes/{classId}/assigned-paths',
    deleteAssignedPath: '/org/{orgId}/classes/{classId}/assigned-paths/{assignedPathId}',

    //Workflows related APIs
    workflows: '/accounts/{accountid}/workflows',
    getAllWorkflowOfAUser: '/accounts/{accountid}/workflows/workflows-by-user',
    getAWorkflow: '/accounts/{accountid}/workflows/{workflowid}',
    acceptAWorkflow: '/accounts/{accountid}/workflows/{workflowid}/accept',
    processAWorkflow: '/accounts/{accountid}/workflows/{workflowid}/process',
    revokeAWorkflow: '/accounts/{accountid}/workflows/{workflowid}/revoke',
    completeAWorkflow: '/accounts/{accountid}/workflows/{workflowid}/complete',

    //Groups realated APIs
    allGroups: '/org/{orgId}/groups',
    aParticularGroup: '/org/{orgId}/groups/{groupId}',
    getAllMembersOfAGroup: '/org/{orgId}/groups/{groupId}/memberships',
    getAllGroupMembersByPath: '/org/{orgId}/groups/memberships',
    userGroupMembership: '/org/{orgId}/groups/{groupId}/enroll-user/multi',
    getMyAllMemberships: '/org/{orgId}/users/{userId}/groups',
    archiveAParticularGroup: '/org/{orgId}/groups/{groupId}/archive',
    unarchiveAParticularGroup: '/org/{orgId}/groups/{groupId}/unarchive',

    //Showcase related API's
    showcaseItems: '/org/{orgId}/classes/{classId}/showcase/item',

};

exports.ACTIVITY_API_URLS = {
    newAttemptAPI: '/{orgId}/products/{productId}/activities/{activityId}/start',
    activityDetailsAPI: '/{orgId}/products/{productId}/activities/{activityId}',
    existingAttemptAPI: '/{orgId}/products/{productId}/activities/{activityId}/attempts/{attemptId}',
    userResponseAPI: '/{orgId}/products/{productId}/activities/{activityId}/attempts/{attemptId}/response',
    submitAttemptAPI: '/{orgId}/products/{productId}/activities/{activityId}/attempts/{attemptId}/submit'
};

exports.ANALYTICS_API_URLS = {
    archiveUserAnalytics: '/{orgId}/archive/user/product',
    getOrgAnalyticsStat: '/{orgId}/organization/{type}/stat',
    getAnalyticProductItems: '/{orgId}/user/product/progress/items',
    getAnalyticProductSummary: '/{orgId}/user/product/progress/summary',
    getExternalDataForUserAnalyticItem: '/{orgId}/user/product/progress/items/external-data',
    searchUserProductAnalytics: '/{orgId}/user/product/progress/search',
    getAnalyticProductById: '/{orgId}/user/product/userprogress/{userProgressId}',
    getArchivedUserAnalytics: '/{orgId}/archive',
    getClassAnalytics: '/{orgId}/class/{analyticsDataType}/{type}',
    getClassEnrolmentsStat: '/{orgId}/class/enrolments/stat',
    getClassRecord: '/{orgId}/class/product/class-record',
    getClassRecordItemAggregations: '/{orgId}/class/product/item-aggregations',
    getClassProductRecentPendingSubmissions: '/{orgId}/class/product/recent-pending-submissions',
    getStudentsWithEvaluatedOnce: '/{orgId}/class/product/students-with-evaluations',
    getShowcaseRecordOfAClass: '/{orgId}/class/showcase',

    getGroupRecord: '/{orgId}/class/group/product/group-record',
    getClassGroupsRecentPendingSubmissions: '/{orgId}/class/group/product/recent-pending-submissions',
    getGroupsWithEvaluatedOnce: '/{orgId}/class/group/product/groups-with-evaluations',

    getClassRecordUserAggregations: '/{orgId}/class/product/user-aggregations',
    getUserClassRecentSubmissions: '/{orgId}/user/product/class/recent-submissions',
    appState: '/{orgId}/user/product/progress/state',

    //AssignedPaths Related APIs
    getAllAssignedPathsOfClass: '/{orgId}/class/assigned-paths',
    getMyAssignedPathsOfClass: '/{orgId}/user/class/assigned-paths',
    getAssignedPathAnalytics: '/{orgId}/class/assigned-paths/aggregations',

    getTimeseriesAnalytics: '/progress/timeseries'
};

exports.SISEVENTS_API_URLS = {
    postSingleSISEvent: '/{orgId}/events',
    postMultiSISEvent: '/{orgId}/events/multi'
};

exports.COLLAB_API_URLS = {
    postsInClassAPI: '/{orgId}/post/classes/{classId}',
    postsInProductAPI: '/{orgId}/post/products/{productId}',
    getMyFollowers: '/{orgId}/connections/me/followers',
    getUsersFollowedByMe: '/{orgId}/connections/me/following',
    connectionURL: '/{orgId}/connections/me/follow/{userId}'
};

exports.PRODUCT_API_URLS = {
    getProductAPI: '/accounts/{accountId}/products/{productCode}',
    getEntitlementsOfAUser: '/accounts/{accountId}/ext-users/{extUserId}/entitlements',
    getMicroEntitlementsOfAUser: '/accounts/{accountId}/ext-users/{extUserId}/entitlements/micro',
    getAllBundles: '/accounts/{accountId}/bundles',
    getSingleBundle: '/accounts/{accountId}/bundles/{bundleCode}',
    getAllProductFamilies: '/accounts/{accountId}/families',
    getSingleProductFamily: '/accounts/{accountId}/families/{familyCode}'
};

exports.XAPI_API_URLS = {
    postMultiStatements: '/{orgId}/statements/multi',
    postExternalMultiStatements: '/{orgId}/external/statements/multi',
    resetUserProductProgress: '/accounts/{accountId}/progress/user/product/reset'
};

exports.ATTEMPTS_API_URLS = {
  userAttempts: '/org/{orgId}/user/{userId}/activities/{activityId}/attempts',
  getUserAttemptStatsForActivity: '/org/{orgId}/user/{userId}/activities/{activityId}/attempts/stats',
  getUserAttemptForActivity: '/org/{orgId}/user/{userId}/activities/{activityId}/attempts/{attemptId}',
  getUserFirstAttemptForActivity: '/org/{orgId}/user/{userId}/activities/{activityId}/attempts/first',
  getUserLastAttemptForActivity: '/org/{orgId}/user/{userId}/activities/{activityId}/attempts/last'
};

exports.PUB_API_URLS = {
    promoteAPI: '/{orgId}/products/{productcode}/promote',
    registerProductAPI: '/{orgId}/products/register',
    ingestByCodeAPI: '/{orgId}/products/{productcode}/ingest',
    createBundle: '/{orgid}/stage/{stage}/bundles',
    updateBundle: '/{orgid}/stage/{stage}/bundles/{bundleCode}',
    getAllBundles: '/{orgid}/bundles',
    getSingleBundle: '/{orgid}/bundles/{bundleCode}',
    createProductFamily: '/{orgid}/stage/{stage}/families',
    updateProductFamily: '/{orgid}/stage/{stage}/families/{familyCode}',
    getSingleProductFamily: '/{orgid}/families/{familyCode}',
    getAllProductFamilies: '/{orgid}/families'
};

exports.PUSHX_API_URLS = {
    grantByUserOrgId: '/orgs/{orgId}/grants',
    grantByAccountId: '/accounts/{accountId}/grants'
};

exports.INTEGRATIONS_API_URLS = {
  getGetStreamCredentials: '/accounts/{accountId}/getstream/credentials',
  queryDataFromSearch: '/search/indices/{index}',
  auditTrail: '/accounts/{accountId}/audit-trail',
  customEvents: '/accounts/{accountId}/custom-events',
  schedules: '/accounts/{accountId}/context/{context}/schedule',
  updateSchedule: '/accounts/{accountId}/context/{context}/schedule/{scheduleId}'
};

exports.DRIVE_API_URLS = {
  getAParticularDocument: '/accounts/{accountid}/users/{extuserid}/documents/{documentid}',
  getAllDocumentsInAFolder: '/accounts/{accountid}/users/{extuserid}/documents'
};

exports.TAXONOMY_API_URLS = {
  associateTagsWithEntity: '/org/{orgId}/taxonomy/associate-tags-with-entity',
  tags: '/org/{orgId}/context/{context}/taxonomy/{taxonomyId}/tags'
};

exports.RULES_API_URLS = {
  rules: '/org/{orgId}/context/{context}/rule_type/{ruleType}/rules',
  particularRule: '/org/{orgId}/context/{context}/rule_type/{ruleType}/rules/{ruleId}',
  updateRuleDisplay: '/org/{orgId}/context/{context}/rule_type/{ruleType}/rules/{ruleId}/update-rule-display',
  getUserRule: '/org/{orgId}/context/{context}/rule_type/{ruleType}/users/{userId}/rules'
};

},{}],3:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/
/***********************************************************
 * comproDLS SDK Helpers Module
 * This module provides definition of helper functions for SDK.
 ************************************************************/
/****************************************************
 * Setting up Exports/Public functions and variables
 *****************************************************/
exports.api = require('./lib/api');
exports.errors = require('./lib/errors');
exports.utils = require('./lib/utils');
exports.validations = require('./lib/validator');
},{"./lib/api":5,"./lib/errors":7,"./lib/utils":8,"./lib/validator":9}],4:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

 var Errors = require('../errors');
 var DLSError = Errors.DLSError;

/**
 * This function converts user entity to generate SDK response.
 * @param { *data: {userEntityDDB} } options
 */
function __convertUserResponse(options) {
  var userEntity = options.data,
      userRoles = userEntity.roles;

  if(Array.isArray(userRoles)) {

    //convert to SDK response.
    var userRolesInResponse = {};
    for(var roleIndex in userRoles) {
      userRolesInResponse[userRoles[roleIndex]] = [];
    }

    userEntity.roles = userRolesInResponse;
  }

  return userEntity;
}

/**
 * This function converts class entity from DDB to generate SDK response.
 * @param { *data: {classEntityDDB} } options
 */
function __convertClassResponse(options) {
  var classEntity = options.data;

  if (classEntity.hasOwnProperty('pk') === false) {
    // BAAS structure returned, no need to convert response.
    return classEntity;
  }

  var response = {
    uuid: classEntity.classid,
    type: 'group'
  };

  Object.assign(response, classEntity);

  var firstName = classEntity.class.instructor.first_name,
    lastName = classEntity.class.instructor.last_name;

  response.class.instructor.uuid = classEntity.class.instructor.dls_user_id;

  if (firstName || lastName) {
    response.class.instructor.name  = firstName ? firstName : '';

    if (lastName) {
      response.class.instructor.name += firstName ? (' ' + lastName) : lastName;
    }
  }

  return response;
}


/**
 * This function converts enrollment entities to generate SDK response.
 * @param { *data: [enrollmentEntities] } options
 */
 function __convertEnrollmetsResponse(options) {
  var enrollmentEntities = options.data;

  //convert to SDK response.
  for(var enrollmentIdx in enrollmentEntities) {
    var enrollment = enrollmentEntities[enrollmentIdx];
    var firstName = enrollment.first_name,
        lastName = enrollment.last_name;
    if(firstName || lastName) {
      enrollment.name  = firstName ? firstName : '';
  
      if(lastName) {
        enrollment.name += firstName ? (' ' + lastName) : lastName;
      }
    }

    enrollment.uuid = enrollment.dls_user_id;

    if(enrollment.username) {
      enrollment.ext_username = enrollment.username;
    }
    enrollment.username = enrollment.userid + '--ACCOUNT';
  }

  return enrollmentEntities;
}

function __convertElasticsearchErrResponse(options) {
  var err = options.err;
  var type = options.type;
  var error = new DLSError(type, err);
  if (err.response && err.response.body && err.response.body.meta &&
    err.response.body.meta.body) {
    error.message = 'Elasticsearch Error. Please refer data field for more information';
    error.data = err.response.body.meta.body;
  }
  return error;
}

module.exports = {
  convertUserResponse: __convertUserResponse,
  convertClassResponse: __convertClassResponse,
  convertEnrollmetsResponse: __convertEnrollmetsResponse,
  convertElasticsearchErrResponse : __convertElasticsearchErrResponse
};

},{"../errors":7}],5:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/
/***********************************************************
 * comproDLS SDK Generic API Caller
 * This module provides generic function(s) to call any comproDLS API. 
 * The generic approach for calling API(s) require a prior knowledge of 
 * the specific URLs and parameters (as per the API documentation). 
 ************************************************************/
var request = require('superagent');
var q = require('q');
var format = require("string-template");

var config = require('../../../config');
var helpers = require('../../../helpers');
var errors = require('../errors');
var DLSError = errors.DLSError;
var validations = require('./validations');

/*********************************
 * Setting up Exports/Public functions
 **********************************/
exports.genericAPICaller = genericAPICaller;
exports.constructAPIUrl = constructAPIUrl;
exports.setupAPIToken = setupAPIToken;
exports.addClassIdQueryParam = addClassIdQueryParam

/*********************************
 * Public Function definitions
 **********************************/

//Generic comproDLS API caller
function genericAPICaller(apiName, method, url, params) {
    var self = this;
    var dfd = q.defer();

    //Validation
    var err = validations.genericAPICaller(apiName, method, url, params) || helpers.validations.isAuthenticated(self.orgId, self.token);
    if (err) {
        dfd.reject(err);
    } else {

        //Passed all validations, setup API Url and parameters
        var url = config.DEFAULT_HOSTS[apiName.toUpperCase()] + url;

        //Setup Delete method for superagent
        if (method === 'DELETE') {
            method = 'DEL';            
        }
       
        var requestAPI = request(method, url);

        //Setting token in Authorization header
        requestAPI = setupAPIToken(requestAPI, self.token);

        //Setup request parameters
        if (Object.keys(params).length) {
            if (method === 'GET' || method === 'HEAD') {
                requestAPI = requestAPI.query(params);
            } else {
                requestAPI = requestAPI.send(params);
            }
        }

        //Call Specified API
        requestAPI.end(function(err, response) {
            if (err) {
                err = new DLSError(errors.ERROR_TYPES.API_ERROR, err);
                dfd.reject(err);
            } else {
                dfd.resolve(response.body);
            }
        });
    }
    return dfd.promise;
};

/*********************************************************
* This function constructs the url of comproDLS API.
* Options: JSON Object having actual values to replace in API URLs
* Following are valid feilds in options object:
  {
     "orgId" : "",
     "productId" : "",
     "userId" : "",
     "activityId" : "",
     "attemptId" : "",
     "questionId" : ""
  }
*********************************************************/
function constructAPIUrl(url, options) {
    return format(url, options);
};

function addClassIdQueryParam(url, classId) {
    var queryParam = '';
    if(typeof(classId) !== "undefined" && classId !== null)
        queryParam = '?classId=' + classId;
    return url + queryParam;
};

//This function sets up comproDLS API token in request header
function setupAPIToken(request, token) {
    return request.set('Authorization', token.access_token);
};
},{"../../../config":2,"../../../helpers":3,"../errors":7,"./validations":6,"q":90,"string-template":131,"superagent":133}],6:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/
/***********************************************************
 * comproDLS APIS Module Validations
 * This module contains validations for APIS module.
 ************************************************************/
var validate = require('../validator').validate;

/****************************************************
 * Setting up Exports/Public variables 
 *****************************************************/
exports.genericAPICaller = validateGenericAPICaller;

/*********************************
 * Public Function definitions
 **********************************/
function validateGenericAPICaller(apiName, method, url, params) {
    var validate_options = {
        'apiName': apiName,
        'method': method,
        'url': url,
        'params':params
    };

    var validate_constraints = {
        "apiName" : {
            "isString" : true,
            "presence" : true,
            "inclusion": {
                "within" : ["AUTH" , "PRODUCT" , "COLLAB" , "ANALYTICS" , "ACTIVITY" , "XAPI"],
                "message": "^Enter a valid API Name"
            }
        },
        "method" : {
            "isString" : true,
            "presence" : true,
            "inclusion": {
                "within" : ["GET" , "POST" , "PUT" , "DELETE"],
                "message": "^Enter a valid HTTP method"
            }
        },
        "url" : {
            "isString" : true,
            "presence" : true,
            "format": {
                "pattern": "^/.*$",
                "message": "^Url should start with a /"
            }
        },
        "params" : {
            "isObject" : true
        }
    };

    return validate(validate_options, validate_constraints);
};
},{"../validator":9}],7:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/
/***********************************************************
 * comproDLS SDK Error Helper Module
 * This module contains helper functions for Error management
 ************************************************************/

//All possible Error types in SDK
var ERROR_TYPES = {
    "API_ERROR": "API_ERROR",
    "SDK_ERROR": "SDK_ERROR",
    "CHANNEL_SUBSCRIPTION": "CHANNEL_SUBSCRIPTION"
};

var ERROR_CATEGORY = {
    PUSHX: 'PUSHX'
};


var ERROR_STATUS = {
    ERROR: 'ERROR'
};

/****************************************************
 * Setting up Exports/Public functions and variables
 *****************************************************/
exports.DLSError = DLSError;
exports.PUSHXError = PUSHXError;
exports.ERROR_TYPES = ERROR_TYPES;
exports.ERROR_CATEGORY = ERROR_CATEGORY;

/*****************************************
* Constructor for the DLS error object
* Parameters:
*   type: Error Type. Possible values are SDK_ERROR and API_ERROR
*   err: JSON Error object. This can be:
*      1. HTTP Error Object returned by comproDLS APIs (In case of API_ERROR)
*      2. Custom Error Object(SDK_ERROR or Custom API_ERROR) with following structure  
*         {
*            "message":"[String]",
*            "description":"[String]"
*          }
******************************************/
function DLSError(type, err) {
    /* 
     * We assume only two types of errors: SDK_ERROR (default) 
     * or API_ERROR
     */
    this.type = type;
    if (type === ERROR_TYPES.API_ERROR) {
        
        //Depending on type of error (HTTP response or Custom) deal with different formats of the err object
        var msg, desc;
        if(err.response != undefined) {
            msg = err.response.body.message || err.response.body.dbErrorBody || err.response.body.code;
            desc = err.response.body.dbErrorDescription;

            // Add swagger errors
            if(err.response.body.results && err.response.body.results.errors) {
                msg = '';
                for(var idx in err.response.body.results.errors) {
                    msg += err.response.body.results.errors[idx].message + ' ';
                }
            }

            // Add request_id
            if(err.response.body.server) {
                this.server = err.response.body.server;
            }

        } else {
            msg = err.message ? err.message : "";
            desc = err.description ? err.description : "";
        }

        //Set the message and description
        this.message = msg;
        this.description = desc;
    }
    else if(type === ERROR_TYPES.PUSHX_ERROR) {

        //Set the message and description
        this.message = err.message;
        this.data = err;
    }
    else {
        this.message = err.message ? err.message : "";
        this.description = err.description ? err.description : "";
        delete err.message;
        delete err.description;
        this.data = err;
    }
    
    if (type === ERROR_TYPES.API_ERROR || type === ERROR_TYPES.PUSHX_ERROR) {
        this.httpcode = err.status;
    }
};

function PUSHXError(category, error) {

    if (category === ERROR_CATEGORY.PUSHX) {
        this.category = ERROR_CATEGORY.PUSHX;
        this.type = ERROR_TYPES.CHANNEL_SUBSCRIPTION;
        this.status = ERROR_STATUS.ERROR;
        this.message = error.message;
        this.data = error;
        this.httpcode = (error.errorDetails && error.errorDetails.statusCode) ? error.errorDetails.statusCode : 500;
    }
    else {
        this.message = 'PUSHXError called for incorrect category.';
    }
};

},{}],8:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/
/***********************************************************
 * comproDLS SDK Util Module
 * This module provides Utility functions for SDK
 ************************************************************/
exports.isBrowser = typeof window !== "undefined";
},{}],9:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/
/***********************************************************
 * comproDLS SDK Validator Helper Module
 * This module contains validation helper functions for comproDLS SDK
 ************************************************************/
var validator = require("validate.js");
var errors = require('./errors');
var DLSError = errors.DLSError;


/****************************************************
 * Setting up Exports/Public functions
 *****************************************************/
exports.validate = validate;
exports.isAuthenticated = validateIsAuthenticated;

/*********************************
 * Public Function definitions
 **********************************/
function validate(options, constraints) {
    var err = {};
    var validation_errors = validator(options, constraints);
    if (validation_errors) {
        for (var validation_error in validation_errors) {
            err.message = err.description = validation_errors[validation_error][0];
            err = new DLSError(errors.ERROR_TYPES.SDK_ERROR, err);
            return err;
        }
    } else {
        return undefined;
    }
};

function validateIsAuthenticated(orgId, token) {
    var validate_options = {
        'organization': orgId,
        'token': token
    };

    var validate_constraints = {
        "organization": {
            "presence": {
                "message" : "^SDK Instance does not have valid orgid or token. Please authenticate using authWithCredentials or authWithToken method."
            }
        },
        "token": {
            "presence": {
                "message" : "^SDK Instance does not have valid orgid or token. Please authenticate using authWithCredentials or authWithToken method."
            }
        }
    };

    return validate(validate_options, validate_constraints);
};

/*********************************
 * Private Function definitions
 **********************************/
validator.validators.isString = function(value, options) {
    if (!validator.isString(value)) {
        return options.message || "is not a valid string";
    }
};

validator.validators.isObject = function(value, options) {
    if (!validator.isObject(value)) {
        return options.message || "is not a valid object";
    }
};

validator.validators.contains = function(value, options) {
    if (validator.isArray(options)) {
        for (var key in options) {
            if (!value || !value.hasOwnProperty(options[key])) {
                return options.message || "does not contain " + options[key];
            }
        }
    } else if (validator.isString(options)) {
        if (!value || !value.hasOwnProperty(options)) {
            return options.message || "does not contain " + options;
        }
    }
};
},{"./errors":7,"validate.js":141}],10:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/
/***********************************************************
 * comproDLS SDK Open Access Manager Module
 * Provides Open Access functions for the SDK
 ************************************************************/
var q = require('q');
var request = require('superagent');
var helpers = require('../helpers');
var DLSError = helpers.errors.DLSError;

/*************************************
 * Setting up Exports/Public functions
 *************************************/

// These functions need to be moved to the corresponding adapter
// They were created here since these functions requires the orgid but not token, But the initialiation function required both token and orgid to be initialized, Now we have improved the initialization function for orgid.

exports.getClassEnrolmentsStat = getClassEnrolmentsStat;
exports.getSingleInvitation = getSingleInvitation;

/*********************************
 * Public Function definitions
 **********************************/

/**
 * options = {
 *  classid: 'string',
 *  role: 'string
 * }
 **/
function getClassEnrolmentsStat(organizationId, options) {
  var self = this;
  //Initializing promise
  var dfd = q.defer(), err = {};
  //Validations
  if(organizationId && options && options.classid) {
    //Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS['ANALYTICS'] + self.config.ANALYTICS_API_URLS.getClassEnrolmentsStat;
    url = helpers.api.constructAPIUrl(url, { orgId: organizationId });

    //Setup request with URL
    var requestAPI = request.get(url).query(options);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(err, response) {
      if(err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err.message = err.description = 'Mandatory params not found in request body : [orgid, classid]';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/* options =  {
    "context_id": "string", //class id to be invited -required
    "invitationid" : "string", //unique invitation id which is to be fetched -required
    "context" : "string", //context for invitation e.g. class_enrollment -required
  };
*/
function getSingleInvitation(organizationId, options) {
    var self = this;
    var err = {};
    // Initializing promise
    var dfd = q.defer();
    if (organizationId && options && options.context_id && options.context && 
        options.invitationid) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.getSingleInvitation;
      //Contruct path parameters
      url = helpers.api.constructAPIUrl(url, 
            { orgId: organizationId, invitationId: options.invitationid });
      var queryParam = { context: options.context, context_id: options.context_id };
  
      // Setup request with URL and Params
      var requestAPI = request.get(url).query(queryParam);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
  
      requestAPI.end(function (error, response) {
        if (error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else {
          dfd.resolve(response.body);
        }
      });
    }
    else {
      err.message = err.description = 'organizationId or context_id or context '+
                                      'or invitationid not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
    return dfd.promise;
  }


},{"../helpers":3,"q":90,"superagent":133}],11:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

/***********************************************************
 * comproDLS SDK Activity API Adaptor
 * Functions for calling Activity API.
 ************************************************************/
var request = require('superagent');
var q = require('q');

var helpers = require('../../helpers');
var DLSError = helpers.errors.DLSError;
var extend = require('extend');
/*********************************
 * Public Function definitions
 **********************************/
module.exports = Activity;

var attempt = require('./attempt');

function Activity(productId, activityId, classId) {
    //When Activity constructor is called, check for instance type
    //comproDLS.Activity() will give instance type as ComproDLS
    //So the control goes to else
    if (this instanceof Activity) {
        this.productId = productId; //Here this is instance of Activity
        this.activityId = activityId; //Here this is instance of Activity
        this.classId = classId;
        
    } else { //New object of Activity is created and its instance type is Activity
        var act = new Activity(productId, activityId, classId);
        act.token = this.token; //Here this is instance of ComproDLS
        act.orgId = this.orgId; //Here this is instance of ComproDLS
        act.config = this.config;
        return act;
    }
};

Activity.prototype.getDetails = function () {
    var self = this;

    //Initializing promise
    var dfd = q.defer();

    //Validations
        var err = helpers.validations.isAuthenticated(this.orgId, this.token);
        if (err) {
            dfd.reject(err);
        } else {

    //Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS['ACTIVITY'] + self.config.ACTIVITY_API_URLS.activityDetailsAPI;

    url = helpers.api.constructAPIUrl(url, {
            "orgId" : self.orgId,
            "productId" : self.productId,
            "activityId" : self.activityId
        });
    url = helpers.api.addClassIdQueryParam(url, self.classId);

    //Setup request with URL and Params
    var req = request.get(url);

    //Setup token in Authorization header
    req = helpers.api.setupAPIToken(req, self.token);

    // setting up traceid
    if(self.traceid) { req.set('X-Amzn-Trace-Id', self.traceid); }

    //Call GET activity details Api
    req.end(function (err, response) {
        if (err) {
            err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
            dfd.reject(err);
        } else {
            var responseBody = response.body;
            var resObject = new Object();
            resObject.activity = responseBody;
            dfd.resolve(resObject);
        }
    });
    }
    return dfd.promise;
}

Activity.prototype.loadAttempt = function (attemptId) {
    var oldAttempt = new attempt(this.productId, this.activityId, attemptId, null, this.classId, this.config);
    oldAttempt.setAuthCredentials(this.orgId, this.token);
    return oldAttempt.getAttemptInfo();
}

Activity.prototype.getAttempt = function (attemptId) {
    var oldAttempt = new attempt(this.productId, this.activityId, attemptId, null, this.classId, this.config);
    oldAttempt.setAuthCredentials(this.orgId, this.token);
    return oldAttempt;
}

Activity.prototype.newAttempt = function (params) {
    var newAttempt = new attempt(this.productId, this.activityId, null, null, this.classId, this.config);
    newAttempt.setAuthCredentials(this.orgId, this.token);
    return newAttempt.start(params);
}

Activity.prototype.getAllQuestions = function () {
        var self = this;

    //Initializing promise
    var dfd = q.defer();

    //Validations
        var err = helpers.validations.isAuthenticated(this.orgId, this.token);
        if (err) {
            dfd.reject(err);
        } else {

    //Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS['PRODUCT'] + self.config.PRODUCT_API_URLS.activityAPI;
    url = helpers.api.constructAPIUrl(url, {
            "orgId" : self.orgId,
            "productId" : self.productId,
            "activityId" : self.activityId
        });
    url = helpers.api.addClassIdQueryParam(url, self.classId);
    //Setup request with URL and Params
    var req = request.get(url);

    //Setup token in Authorization header
    req = helpers.api.setupAPIToken(req, self.token);

    // Setting trace id
    if(self.traceid) { req.set('X-Amzn-Trace-Id', self.traceid); }

    //Call GET activity details Api
    req.end(function (err, response) {
        if (err) {
            err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
            dfd.reject(err);
        } else {
            var responseBody = response.body;
            var resObject = new Object();
            resObject.questions = responseBody.items;
            dfd.resolve(resObject);
        }
    });
    }
    return dfd.promise;
}

Activity.prototype.getQuestionsCount = function () {
        var self = this;

    //Initializing promise
    var dfd = q.defer();

    //Validations
        var err = helpers.validations.isAuthenticated(this.orgId, this.token);
        if (err) {
            dfd.reject(err);
        } else {

    //Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS['PRODUCT'] + self.config.PRODUCT_API_URLS.activityAPI;
    url = helpers.api.constructAPIUrl(url, {
            "orgId" : self.orgId,
            "productId" : self.productId,
            "activityId" : self.activityId
        });
    url = helpers.api.addClassIdQueryParam(url, self.classId);
    //Setup request with URL and Params
    var req = request.get(url);

    //Setup token in Authorization header
    req = helpers.api.setupAPIToken(req, self.token);

    // Setting trace id
    if(self.traceid) { req.set('X-Amzn-Trace-Id', self.traceid); }

    //Call GET activity details Api
    req.end(function (err, response) {
        if (err) {
            err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
            dfd.reject(err);
        } else {
            var responseBody = {"count": response.body.items.length};
            var resObject = new Object();
            resObject.count = responseBody;
            dfd.resolve(resObject);
        }
    });
    }
    return dfd.promise;
}

},{"../../helpers":3,"./attempt":12,"extend":68,"q":90,"superagent":133}],12:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/
/***********************************************************
 * comproDLS SDK Activity Attempt Manager
 * Functions for calling Activity Attempt APIs.
 ************************************************************/

var request = require('superagent');
var q = require('q');

var helpers = require('../../helpers');
var DLSError = helpers.errors.DLSError;
var extend = require('extend');

module.exports = Attempt;
/*********************************
 * Constructor
 **********************************/

function Attempt(productId, activityId, attemptId, authCredentials, classId, config) {
    this.productId = productId;
    this.activityId = activityId;
    this.attemptId = attemptId;
    this.classId = classId;
    this.config = config;
    
    var authCredentials;
    
    
    function getProperties() {
        return this.authCredentials;
    }

    function setProperties(authCredentials) {
       
        this.authCredentials = authCredentials;
        
    }
    
        //Privilaged Methods
    Attempt.prototype.getAuthCredentials = function () {
        return getProperties();
    };
    
    Attempt.prototype.setAuthCredentials = function (orgid, token) {
        var authCredentials = new Object();
        authCredentials.orgId = orgid;
        authCredentials.token = token;
        
        setProperties(authCredentials);
    };
};

/*********************************
 * Method Implementations
 **********************************/


Attempt.prototype.start = function (params) {
    var self = this;
     
    var orgid = this.getAuthCredentials().orgId;
    var token = this.getAuthCredentials().token;
    //Initializing promise
    var dfd = q.defer();
    //Validations
        var err = helpers.validations.isAuthenticated(orgid, token);
        if (err) {
            dfd.reject(err);
        } else {

    //Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS['ACTIVITY'] + self.config.ACTIVITY_API_URLS.newAttemptAPI;
    url = helpers.api.constructAPIUrl(url, {
            "orgId" : orgid,
            "productId" : self.productId,
            "activityId" : self.activityId
        });
    url = helpers.api.addClassIdQueryParam(url, self.classId);
    
    //Construct parameters
    if(params == undefined || params == null)
        params = {};

    //Setup request with URL and Params
    var req = request.post(url).send(params);

    //Setup token in Authorization header
    req = helpers.api.setupAPIToken(req, token);

    // setting up traceid
    if(self.traceid) { req.set('X-Amzn-Trace-Id', self.traceid); }

    //Call start attempt Api
    req.end(function (err, response) {
        if (err) {
            err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
            dfd.reject(err);
        } else {
            var responseBody = response.body;
            self.attemptId = responseBody.uuid;
            extend(true, self, responseBody);
            var resObject = new Object();
            resObject.attempt = self;
            dfd.resolve(resObject);
        }
    });
    }
    return dfd.promise;

};

Attempt.prototype.getAttemptInfo = function () {
    var orgid = this.getAuthCredentials().orgId;
    var token = this.getAuthCredentials().token;
    var self = this;

    //Initializing promise
    var dfd = q.defer();

    //Validations
        var err = helpers.validations.isAuthenticated(orgid, token);
        if (err) {
            dfd.reject(err);
        } else {

    //Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS['ACTIVITY'] + self.config.ACTIVITY_API_URLS.existingAttemptAPI;
    url = helpers.api.constructAPIUrl(url, {
            "orgId" : orgid,
            "productId" : self.productId,
            "activityId" : self.activityId,
            "attemptId" : self.attemptId
        });
    url = helpers.api.addClassIdQueryParam(url, self.classId);
    //Setup request with URL and Params
    var req = request.get(url);

    //Setup token in Authorization header
    req = helpers.api.setupAPIToken(req, token);

    // setting up traceid
    if(self.traceid) { req.set('X-Amzn-Trace-Id', self.traceid); }

    //Call GET attempt INFO Api
    req.end(function (err, response) {
        if (err) {
            err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
            dfd.reject(err);
        } else {
            var responseBody = response.body;
            self.attemptId = responseBody.uuid;
            extend(true, self, responseBody);
            var resObject = new Object();
            resObject.attempt = self;
            dfd.resolve(resObject);
        }
    });
    }
    return dfd.promise;
};

Attempt.prototype.getState = function () {
    var orgid = this.getAuthCredentials().orgId;
    var token = this.getAuthCredentials().token;
    var self = this;

    //Initializing promise
    var dfd = q.defer();

    //Validations
        var err = helpers.validations.isAuthenticated(orgid, token);
        if (err) {
            dfd.reject(err);
        } else {

    //Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS['ACTIVITY'] + self.config.ACTIVITY_API_URLS.existingAttemptAPI;
    url = helpers.api.constructAPIUrl(url, {
            "orgId" : orgid,
            "productId" : self.productId,
            "activityId" : self.activityId,
            "attemptId" : self.attemptId
        });
    url = helpers.api.addClassIdQueryParam(url, self.classId);
    //Setup request with URL and Params
    var req = request.get(url);

    //Setup token in Authorization header
    req = helpers.api.setupAPIToken(req, token);

    // setting up traceid
    if(self.traceid) { req.set('X-Amzn-Trace-Id', self.traceid); }

    //Call GET saved state Api
    req.end(function (err, response) {
        if (err) {
            err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
            dfd.reject(err);
        } else {
            var responseBody = response.body;
            var resObject = new Object();
            resObject.state = responseBody.data.savedstate.state;
            dfd.resolve(resObject);
        }
    });
    }
    return dfd.promise;
};

Attempt.prototype.saveState = function (state) {
    var orgid = this.getAuthCredentials().orgId;
    var token = this.getAuthCredentials().token;
    var self = this;

    //Initializing promise
    var dfd = q.defer();

    //Validations
        var err = helpers.validations.isAuthenticated(orgid, token);
        if (err) {
            dfd.reject(err);
        } else {

    //Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS['ACTIVITY'] + self.config.ACTIVITY_API_URLS.existingAttemptAPI;
    url = helpers.api.constructAPIUrl(url, {
            "orgId" : orgid,
            "productId" : self.productId,
            "activityId" : self.activityId,
            "attemptId" : self.attemptId
        });
    url = helpers.api.addClassIdQueryParam(url, self.classId);

    //Setup request with URL and Params
    var req = request.put(url).send(state);

    //Setup token in Authorization header
    req = helpers.api.setupAPIToken(req, token);

    // setting up traceid
    if(self.traceid) { req.set('X-Amzn-Trace-Id', self.traceid); }

    //Call PUT saved state Api
    req.end(function (err, response) {
        if (err) {
            err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
            dfd.reject(err);
        } else {
            var responseBody = response.body;
            var resObject = new Object();
            resObject.status = responseBody;
            dfd.resolve(resObject);
        }
    });
    }
    return dfd.promise;
};


Attempt.prototype.getUserResponse = function () {
    var orgid = this.getAuthCredentials().orgId;
    var token = this.getAuthCredentials().token;
    var self = this;

    //Initializing promise
    var dfd = q.defer();

    //Validations
        var err = helpers.validations.isAuthenticated(orgid, token);
        if (err) {
            dfd.reject(err);
        } else {

    //Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS['ACTIVITY'] + self.config.ACTIVITY_API_URLS.userResponseAPI;
    url = helpers.api.constructAPIUrl(url, {
            "orgId" : orgid,
            "productId" : self.productId,
            "activityId" : self.activityId,
            "attemptId" : self.attemptId
        });
    url = helpers.api.addClassIdQueryParam(url, self.classId);

    //Setup request with URL and Params
    var req = request.get(url);

    //Setup token in Authorization header
    req = helpers.api.setupAPIToken(req, token);

    // setting up traceid
    if(self.traceid) { req.set('X-Amzn-Trace-Id', self.traceid); }

    //Call GET Userresponse Api
    req.end(function (err, response) {
        if (err) {
            err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
            dfd.reject(err);
        } else {
            var responseBody = response.body;
            var resObject = new Object();
            resObject.userresponse = responseBody;
            dfd.resolve(resObject);
        }
    });
    }
    return dfd.promise;
};

Attempt.prototype.saveUserResponse = function (userresponse) {
    var orgid = this.getAuthCredentials().orgId;
    var token = this.getAuthCredentials().token;
    var self = this;

    //Initializing promise
    var dfd = q.defer();

    //Validations
        var err = helpers.validations.isAuthenticated(orgid, token);
        if (err) {
            dfd.reject(err);
        } else {

    //Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS['ACTIVITY'] + self.config.ACTIVITY_API_URLS.userResponseAPI;
    url = helpers.api.constructAPIUrl(url, {
            "orgId" : orgid,
            "productId" : self.productId,
            "activityId" : self.activityId,
            "attemptId" : self.attemptId
        });
            
    url = helpers.api.addClassIdQueryParam(url, self.classId);

    //Setup request with URL and Params
    var req = request.put(url).send(userresponse);

    //Setup token in Authorization header
    req = helpers.api.setupAPIToken(req, token);

    // setting up traceid
    if(self.traceid) { req.set('X-Amzn-Trace-Id', self.traceid); }

    //Call PUT Userresponse Api
    req.end(function (err, response) {
        if (err) {
            err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
            dfd.reject(err);
        } else {
            var responseBody = response.body;
            var resObject = new Object();
            resObject.status = responseBody;
            dfd.resolve(resObject);
        }
    });
    }
    return dfd.promise;
};

Attempt.prototype.submit = function (userresponse) {
   
    var orgid = this.getAuthCredentials().orgId;
    var token = this.getAuthCredentials().token;
    var self = this;
    //Initializing promise
    var dfd = q.defer();
    //Validations
        var err = helpers.validations.isAuthenticated(orgid, token);
        if (err) {
            dfd.reject(err);
        } else {

    //Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS['ACTIVITY'] + self.config.ACTIVITY_API_URLS.submitAttemptAPI;
    url = helpers.api.constructAPIUrl(url, {
            "orgId" : orgid,
            "productId" : self.productId,
            "activityId" : self.activityId,
            "attemptId" : self.attemptId
        });
    url = helpers.api.addClassIdQueryParam(url, self.classId);

    //Setup request with URL and Params
    var req;
    if(userresponse == undefined || userresponse == null)
    {
        req = request.post(url).send({});
    }
    else
    {
        req = request.post(url).send(userresponse);
    }

    //Setup token in Authorization header
    req = helpers.api.setupAPIToken(req, token);

    // setting up traceid
    if(self.traceid) { req.set('X-Amzn-Trace-Id', self.traceid); }

    //Call submit attempt Api
    req.end(function (err, response) {
        if (err) {
            err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
            dfd.reject(err);
        } else {
            var responseBody = response.body;
            var resObject = new Object();
            resObject.status = responseBody;
            dfd.resolve(resObject);
        }
    });
    }
    return dfd.promise;
};

},{"../../helpers":3,"extend":68,"q":90,"superagent":133}],13:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/
/***********************************************************
 * comproDLS SDK Activity API Adaptor
 * Functions for calling Activity API.
 ************************************************************/
/*********************************
 * Setting Up Module Entry Point  
 **********************************/

module.exports = require('./activity'); 

},{"./activity":11}],14:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

/***********************************************************
 * comproDLS SDK Analytics API Adaptor
 * Functions for calling Analytics API.
 ************************************************************/

/*********************************
 * Setting Up Module Entry Point  
 **********************************/

var q = require('q');
var request = require('superagent');
var Agent = require('agentkeepalive');

var helpers = require('../../helpers');
var DLSError = helpers.errors.DLSError;

module.exports = analytics;

var keepaliveAgent = new Agent({
  timeout: 60000,
  freeSocketTimeout: 30000
});

/*********************************
 * Public Function definitions
 **********************************/
function analytics() {
  return {
		archiveUserAnalytics: archiveUserAnalytics.bind(this),
    getArchivedUserAnalytics: getArchivedUserAnalytics.bind(this),

    getOrgAnalyticsStat: getOrgAnalyticsStat.bind(this),

    getClassAnalytics: getClassAnalytics.bind(this),
    getClassProductRecentPendingSubmissions: getClassProductRecentPendingSubmissions.bind(this),
    getClassRecordUserAggregations: getClassRecordUserAggregations.bind(this),
    getClassRecord: getClassRecord.bind(this),
    getClassRecordItemAggregations: getClassRecordItemAggregations.bind(this),
    getShowcaseRecordOfAClass: getShowcaseRecordOfAClass.bind(this),

    getGroupRecord: getGroupRecord.bind(this),
    getClassGroupsRecentPendingSubmissions: getClassGroupsRecentPendingSubmissions.bind(this),
    getGroupsWithEvaluatedOnce: getGroupsWithEvaluatedOnce.bind(this),

    getUserProductAnalytics: getUserProductAnalytics.bind(this),
    getUserProductAnalyticById: getUserProductAnalyticById.bind(this),
    getExternalDataForUserAnalyticItem: getExternalDataForUserAnalyticItem.bind(this),
    searchUserProductAnalytics: searchUserProductAnalytics.bind(this),
    getUserClassRecentSubmissions: getUserClassRecentSubmissions.bind(this),
    getStudentsWithEvaluatedOnce: getStudentsWithEvaluatedOnce.bind(this),

    getAppState: getAppState.bind(this),
    updateAppState: updateAppState.bind(this),
    deleteAppState: deleteAppState.bind(this),

    getQuestionProgressByLearningObjective: getQuestionProgressByLearningObjective.bind(this),

    //AssignedPaths Related APIs
    getAllAssignedPathsOfClass: getAllAssignedPathsOfClass.bind(this),
    getMyAssignedPathsOfClass: getMyAssignedPathsOfClass.bind(this),
    getAssignedPathAnalytics: getAssignedPathAnalytics.bind(this),
    getMyParticularAssignedPathOfClass: getMyParticularAssignedPathOfClass.bind(this),
    
    getTimeseriesAnalytics: getTimeseriesAnalytics.bind(this)
  };
}

//options = {
//	type: 'users/classes', // choose any one
//	range: '', //
//	start: '', // time(ms) - start interval
//	end: '', // time(ms) - end interval
//  role: '', // The role of users i.e. student, teacher, etc. No default role (i.e. all users).
//  shadow: <boolean> // if user/class is shadow-provsioined.
//}
function getOrgAnalyticsStat(options) {
	var self = this;

  //Initializing promise
  var dfd = q.defer();
  //Validations
  var err = {};
	if(options && options.type) {
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) { dfd.reject(err); }
    else {
      err = {};
      var allowedAnalyticsDataType = ['users', 'classes'];
			if(allowedAnalyticsDataType.indexOf(options.type) > -1) {
				//Passed all validations, Construct API url
				var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +
                  self.config.ANALYTICS_API_URLS.getOrgAnalyticsStat;
				url = helpers.api.constructAPIUrl(url, {
          orgId: self.orgId, type: options.type
        });

				var params = {};
				if(options) {
					if(options.range) { params.range = options.range; }
					if(options.start) { params.start = options.start; }
					if(options.end) { params.end = options.end; }
					if(options.role) { params.role = options.role; }
					if(options.shadow) { params.shadow = options.shadow; }
				}

				//Setup request with URL and Params
				var requestAPI = request.get(url).query(params);

				//Setup token in Authorization header
				requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

        // setting up traceid
        if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

				//Call Product Timespent Api
				requestAPI.end(function(err, response) {
					if(err) {
						err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
						dfd.reject(err);
					}
          else { dfd.resolve(response.body); }
        });
			} else {
				err.message = err.description = 'Type: ' + options.type + ' is not supported';
				err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
				dfd.reject(err);
			}
		}
	} else {
		err.message = err.description = 'type not found in request options';
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}

	return dfd.promise;
}

//options = {
//  type: 'string',            // [items/summary]
//	userid: 'string',          // user uuid
//	productcode: 'string,        // product code
//	classid: 'string',         // OPTIONAL
//  itemcode: 'string',         // OPTIONAL (only for 'type=items') item-code of the required item
//  metrics: boolean            // OPTIONAL (only for 'type=items') true/false - aggregations on the
//                                 item(s), default - true
//  history: boolean            // If history is true - submission is array else submission is object
//  expiredView: boolean            // If expiredView is true - items from class record matrix will be returned.
//  externalData: boolean       // OPTIONAL(default is 'false' - only works with itemcode) whether to return external 
                                    //secondary evaluation data or not.
//  group: boolean              // If group is true - then it will return group data from P1.
//}
function getUserProductAnalytics(options) {
	var self = this;

  //Initializing promise
  var dfd = q.defer();
  //Validations
  var err = {};
	if(options && options.type && options.userid && options.productcode) {
		err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) { dfd.reject(err); }
    else {
      var supportedType = ['items', 'summary'];
      //Passed all validations, Construct API url
			var url = self.config.DEFAULT_HOSTS['ANALYTICS'];

      if(supportedType.indexOf(options.type) > -1) {
        switch(options.type) {
					case 'items':
						url += self.config.ANALYTICS_API_URLS.getAnalyticProductItems;
						break;
					case 'summary':
						url += self.config.ANALYTICS_API_URLS.getAnalyticProductSummary;
						break;
				}
				url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

				var params = { userid: options.userid, productcode: options.productcode };

				if(options.classid) { params.classid = options.classid; }
        if(options.itemcode) { params.itemcode = options.itemcode; }
        if(options.metrics) { params.metrics = options.metrics; }
        if(options.history) { params.history = options.history; }
        if(options.group) { params.group = options.group; }
        if(options.externalData) { params.externalData = options.externalData; }
        if(options.expiredView && options.type === 'items') { params.expiredView = options.expiredView; }

				//Setup request with URL and Params
				var requestAPI = request.get(url).query(params);

				//Setup token in Authorization header
				requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

        // setting up traceid
        if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

				//Call Product Timespent Api
				requestAPI.end(function(err, response) {
					if(err) {
						err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
						dfd.reject(err);
					}
          else { dfd.resolve(response.body); }
        });
			} else {
				err.message = err.description = options.type + " is not a valid value of option 'type'";
				err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
				dfd.reject(err);
			}
		}
	} else {
		err.message = err.description = "Required parameter 'type' or 'userid' or " +
                                    "'productcode' not found in request options";
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}

	return dfd.promise;
}

//options = {
// userprogressid: 'string' // userprogressid
//}
function getUserProductAnalyticById(options) {
	var self = this;

  //Initializing promise
  var dfd = q.defer();
  //Validations
  var err = {};
	if(options && options.userprogressid) {
		err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) { dfd.reject(err); }
    else {
      //Passed all validations, Construct API url
			var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +
                self.config.ANALYTICS_API_URLS.getAnalyticProductById;
			url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId, userProgressId: options.userprogressid
      });

      //Setup request with URL and Params
			var requestAPI = request.get(url);

			//Setup token in Authorization header
			requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

			//Call Product Timespent Api
			requestAPI.end(function(err, response) {
				if(err) {
					err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
					dfd.reject(err);
				}
        else { dfd.resolve(response.body); }
			});
		}
	} else {
		err.message = err.description = "Required parameter 'userprogressid' not " +
                                    "found in request options";
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}

	return dfd.promise;
}

//options = {
// ext_user_id: <ext_user_id>, // mandatory
// productcode: <productcode>, // mandatory
// itemcode: <itemcode>, // mandatory
// (any one field from 'submission_order' OR 'ext_link_id' is mandatory)
// submission_order: number, // optional
// ext_link_id: <ext_link_id>, // optional
// part: number, // mandatory
// classid: <classid>, // optional
//}
function getExternalDataForUserAnalyticItem(options) {
  var self = this;
  var dfd = q.defer();
  // Validations
  var err = {};
  if(options && options.ext_user_id && options.productcode && options.itemcode &&
      (options.submission_order || options.ext_link_id) && options.part) {
		err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) { dfd.reject(err); }
    else {
      // Passed all validations, Construct API url
			var url = self.config.DEFAULT_HOSTS.ANALYTICS +
                self.config.ANALYTICS_API_URLS.getExternalDataForUserAnalyticItem;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      var params = {
        ext_user_id: options.ext_user_id,
        productcode: options.productcode,
        itemcode: options.itemcode,
        part: options.part
      };

      if(options.submission_order) { params.submission_order = options.submission_order; }
      if(options.ext_link_id) { params.ext_link_id = options.ext_link_id; }
      if(options.classid) { params.classid = options.classid; }

      // Setup request with URL and Params
      var requestAPI = request.get(url).query(params);

      // Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Call Product Timespent Api
      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    }
	} else {
		err.message = err.description = "Required parameters 'ext_user_id' or 'productcode' or 'itemcode'" +
                                      " or (either 'submission_order' OR 'ext_link_id') or 'part'are not found in request options";
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}
	return dfd.promise;
}

//options = {
//	userid: <userid>
//	productid: <productid>,
//	classid: <classid>, // OPTIONAL
//}
function archiveUserAnalytics(options) {
	var self = this, err = {};
  //Initializing promise
  var dfd = q.defer();
	if(options && options.userid && options.productid) {
    //Validations
		err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) { dfd.reject(err); }
    else {
      var params = {};
			//Passed all validations, Construct API url
			var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +
                self.config.ANALYTICS_API_URLS.archiveUserAnalytics;
			url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

			if(options.userid) { params.userid = options.userid; }
			if(options.productid) { params.productid = options.productid; }
			if(options.classid) { params.classid = options.classid; }

      //Setup request with URL and Params
			var requestAPI = request.post(url).query(params)
                       .set('Content-Type', 'application/json');

			//Setup token in Authorization header
			requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

			requestAPI.end(function(err, response) {
				if(err) {
					err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
					dfd.reject(err);
				}
        else { dfd.resolve(response.body); }
      });
		}
	} else {
		err.message = err.description = 'Mandatory parameter [userid, productid] ' +
                                    'not found in request options';
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}

  return dfd.promise;
}

//options = {
//	userid: <userid>, // OPTIONAL
//	productid: <productid>, // OPTIONAL
//	classid: <classid>, // OPTIONAL
//  lookup: 'string', // Search query (',' separated key value pairs), e.g. key1:val1,key2:val2,key3:val3
//  cursor: '', // cursor to next set of documents
//  limit: '' // limit of documents per function call
//}
function searchUserProductAnalytics(options) {
	var self = this, err = {};
  //Initializing promise
  var dfd = q.defer();

	//Validations
	err = helpers.validations.isAuthenticated(self.orgId, self.token);
	if(err) { dfd.reject(err); }
  else {
    var params = {};
		//Passed all validations, Construct API url
		var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +
              self.config.ANALYTICS_API_URLS.searchUserProductAnalytics;
		url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

		if(options.userid) { params.userid = options.userid; }
		if(options.productid) { params.productid = options.productid; }
		if(options.classid) { params.classid = options.classid; }
		if(options.lookup) { params.lookup = options.lookup; }
		if(options.cursor) { params.cursor = options.cursor; }
		if(options.limit) { params.limit = options.limit; }

    //Setup request with URL and Params
		var requestAPI = request.get(url).query(params);

		//Setup token in Authorization header
		requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

    // setting up traceid
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

		requestAPI.end(function(err, response) {
			if(err) {
				err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
				dfd.reject(err);
			}
      else { dfd.resolve(response.body); }
		});
	}

  return dfd.promise;
}

/**
 * This function returns the count and submissions of a user in a class for a product.
 * options = {
 *  userid: string,
 *  classid: string,
 *  productcode: string,
 *  gradingStatus: string,          // optional, type of submissions required.
 *                                     Possible values: ['not-started', 'submitted', 'evaluated']
 * }
 */
function getUserClassRecentSubmissions(options) {
  var self = this;
  var dfd = q.defer(), err = {};

  if(options && options.classid && options.productcode && options.userid) {
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err) { dfd.reject(err); }
    else {
      // Passed all validations, Constructing URL
      var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +
          self.config.ANALYTICS_API_URLS.getUserClassRecentSubmissions;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      // Setup Query Params
      var queryParams = {
        userid: options.userid,
        classid: options.classid,
        productcode: options.productcode
      };

      if(options.gradingStatus) { queryParams.gradingStatus = options.gradingStatus; }

      // Setup Request with url and params
      var requestAPI = request.get(url).query(queryParams);
      // Setup token in Authorization Header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Call GET Class Product Recent Pending Submissions
      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body);
        }
      });
    }
  }
  else {
    err.message = err.description = 'Mandatory parameters ["classid", "productcode", "userid"]' +
      ' not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

//options = {
//  classid: 'string',
//  productcode: 'string',
//}
function getStudentsWithEvaluatedOnce(options) {
	var self = this, err = {};
	//Initializing promise
	var dfd = q.defer();
	if(options && options.classid && options.productcode) {
		//Validations
		err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) { dfd.reject(err); }
		else {
		// Passed all validations, Construct API url
			var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +
				self.config.ANALYTICS_API_URLS.getStudentsWithEvaluatedOnce;
			url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

			// Setup params
			var params = {
				classid: options.classid,
				productcode: options.productcode
			};
			// Setup request with URL and Params
			var requestAPI = request.get(url).query(params);
			// Setup token in Authorization header
			requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

			requestAPI.end(function(error, response) {
				if(error) {
					err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
					dfd.reject(err);
				}
				else { dfd.resolve(response.body); }
			});
		}
	} else {
		err.message = err.description = 'Required parameter classid or ' +
			'productcode not found in request options.';
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}
	return dfd.promise;
}


/*options = {
  userid: <userid>, productcode: <productcode>,
  classid: <classid>, // OPTIONAL
  itemcode: <itemcode> // OPTIONAL
  key: <string> // OPTIONAL
}*/
function getAppState(options) {
  var self = this;
  var dfd = q.defer();
  // Validations
  var err = {};
	if(options && options.userid && options.productcode) {
		err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) { dfd.reject(err); }
    else {
      // Passed all validations, Construct API url
			var url = self.config.DEFAULT_HOSTS.ANALYTICS +
                self.config.ANALYTICS_API_URLS.appState;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      var params = { userid: options.userid, productcode: options.productcode };
      if(options.classid) { params.classid = options.classid; }
      if(options.itemcode) { params.itemcode = options.itemcode; }
      if(options.key) { params.key = options.key; }

      // Setup request with URL and Params
      var requestAPI = request.get(url).query(params);

      // Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Call Product Timespent Api
      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    }
	} else {
		err.message = err.description = "Required parameters 'userid' or " +
                                 "'productcode' are not found in request options";
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}
	return dfd.promise;
}

/*options = {
  userid: <userid>,
  productcode: <productcode>,
  classid: <classid>, // OPTIONAL
  itemcode: <itemcode> // OPTIONAL
  appdata: <object>,
}*/
function updateAppState(options) {
  var self = this;
  var dfd = q.defer();
  // Validations
  var err = {};
	if(options && options.userid && options.productcode && options.appdata) {
		err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) { dfd.reject(err); }
    else {
      // Passed all validations, Construct API url
			var url = self.config.DEFAULT_HOSTS.ANALYTICS +
                self.config.ANALYTICS_API_URLS.appState;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      var params = { userid: options.userid, productcode: options.productcode };
      if(options.classid) { params.classid = options.classid; }
      if(options.itemcode) { params.itemcode = options.itemcode; }

      // Setup request with URL and Params
      var requestAPI = request.put(url).query(params)
                       .set('Content-Type', 'application/json')
                       .set('Accept', 'application/json')
                       .send(options.appdata);

      // Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Call Product Timespent Api
      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    }
	} else {
		err.message = err.description = "Required parameters 'userid' or 'appdata'" +
                              " or 'productcode' are not found in request options";
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}
	return dfd.promise;
}

/*options = {
  userid: <userid>, productcode: <productcode>,
  classid: <classid>, // OPTIONAL
  itemcode: <itemcode> // OPTIONAL
  key: <string> // OPTIONAL
}*/
function deleteAppState(options) {
  var self = this;
  var dfd = q.defer();
  // Validations
  var err = {};
	if(options && options.userid && options.productcode) {
		err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) { dfd.reject(err); }
    else {
      // Passed all validations, Construct API url
			var url = self.config.DEFAULT_HOSTS.ANALYTICS +
                self.config.ANALYTICS_API_URLS.appState;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      var params = { userid: options.userid, productcode: options.productcode };
      if(options.classid) { params.classid = options.classid; }
      if(options.itemcode) { params.itemcode = options.itemcode; }
      if(options.key) { params.key = options.key; }

      // Setup request with URL and Params
      var requestAPI = request.delete(url).query(params);

      // Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Call Product Timespent Api
      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    }
	} else {
		err.message = err.description = "Required parameters 'userid' or " +
                              "'productcode' are not found in request options";
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}
	return dfd.promise;
}


/**
 * This function returns the recent pending submissions in a Class for a Product.
 * options = {
 *  classid: string,
 *  productcode: string,
 *  details: boolean,           // optional, if details of submissions is also required.
 *  limit: number               // optional, number of submissions to be fetched at once (default & max is 100)
 * }
 */
function getClassProductRecentPendingSubmissions(options) {
  var self = this;
  var dfd = q.defer(), err = {};

  if(options && options.classid && options.productcode) {
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err) { dfd.reject(err); }
    else {
      // Passed all validations, Constructing URL
      var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +
          self.config.ANALYTICS_API_URLS.getClassProductRecentPendingSubmissions;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      // Setup Query Params
      var queryParams = {
        classid: options.classid,
        productcode: options.productcode
      };

      if(options.details) { queryParams.details = options.details; }
      if(options.limit) { queryParams.limit = options.limit; }

      // Setup Request with url and params
      var requestAPI = request.get(url).query(queryParams);
      // Setup token in Authorization Header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
      // Call GET Class Product Recent Pending Submissions

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body);
        }
      });
    }
  }
  else {
    err.message = err.description = 'Mandatory parameters ["classid", "productcode"] not found in ' +
      'request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/*options = {
 *  classid: 'string',            // class uuid
 *  productcode: 'string',          // product code
 *  includeContext: 'boolean'     // includse context or heirarchy (optional)
 *}
 */
function getClassRecord(options) {
  var self = this;

  //Initializing DFD
  var dfd = q.defer(), err = {};

  // Validations
  if(options && options.classid && options.productcode) {
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err){ dfd.reject(err); }
    else {
      // Passed all validations, Constructing URL
      var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +  self.config.ANALYTICS_API_URLS.getClassRecord;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      // Setup Query Params
      var queryParams = {
        classid: options.classid,
        productcode: options.productcode,
        includeContext: options.includeContext
      }

      // Setup Request with url and params
      var requestAPI = request.get(url).query(queryParams);
      // Setup token in Authorization Header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Call GET GET CLASS RECORD ITEM
      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body)
        }
      });
    }
  } else {
    err.message = err.description = 'Required parameter classid or ' +
			'productcode not found in request options.';
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
  }
  return dfd.promise;
}

/*options = {
 *  classid: 'string',            // class uuid
 *  productcode: 'string',          // product code
 *  item-code: 'string'                // item-code of item(optional)
 *}
 */
function getClassRecordItemAggregations(options) {
  var self = this;

  //Initializing DFD
  var dfd = q.defer(), err = {};

  // Validations
  if(options && options.classid && options.productcode) {
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err){ dfd.reject(err); }
    else {
      // Passed all validations, Constructing URL
      var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +  self.config.ANALYTICS_API_URLS.getClassRecordItemAggregations;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      // Setup Query Params
      var queryParams = {
        classid: options.classid,
        productcode: options.productcode,
        'item-code': options['item-code']
      }

      // Setup Request with url and params
      var requestAPI = request.get(url).query(queryParams);
      // Setup token in Authorization Header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Call GET GET CLASS RECORD ITEM
      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body)
        }
      });
    }
  } else {
    err.message = err.description = 'Required parameter classid or ' +
			'productcode not found in request options.';
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
  }
  return dfd.promise;
}

/*options = {
 *  classid: 'string',            // class uuid(mandatory)
 *  productcode: 'string',        // product code(optional)
 *  'item-code': 'string',        // itemcode of item(optional)
 *  groupid: 'string',            // groupid of a group(optional)
 *  id: 'string'                  // id of showcase record item(optional)
 *}
 */
function getShowcaseRecordOfAClass(options) {
  var self = this;

  //Initializing DFD
  var dfd = q.defer(), err = {};

  // Validations
  if(options && options.classid) {
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err){ dfd.reject(err); }
    else {
      // Passed all validations, Constructing URL
      var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +  self.config.ANALYTICS_API_URLS.getShowcaseRecordOfAClass;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      // Setup Query Params
      var queryParams = {
        classid: options.classid
      };

      if(options.productcode) { queryParams.productcode = options.productcode; }
      if(options.groupid) { queryParams.groupid = options.groupid; }
      if(options['item-code']) { queryParams['item-code'] = options['item-code']; }
      if(options.id) { queryParams.id = options.id; }

      // Setup Request with url and params
      var requestAPI = request.get(url).query(queryParams);
      // Setup token in Authorization Header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Call GET GET CLASS RECORD ITEM
      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body);
        }
      });
    }
  } else {
    err.message = err.description = 'Required parameter classid not found in request options.';
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
  }
  return dfd.promise;
}

/**
 * options = {
 *  classid: 'string',       // mandatory, class uuid
 *  productcode: 'string',   // mandatory, product code
 *  groupid: 'string',       // mandatory, group id
 *  itemcode: 'string',      // optional, item code of the group LO whose GR is required
 *  history: boolean         // optional, if true give all the submissions else give only the latest submission
 * }
 */
function getGroupRecord(options) {
  var self = this;

  //Initializing DFD
  var dfd = q.defer(), err = {};

  // Validations
  if(options && options.classid && options.productcode && options.groupid) {
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err){ dfd.reject(err); }
    else {
      // Passed all validations, Constructing URL
      var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +  self.config.ANALYTICS_API_URLS.getGroupRecord;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      // Setup Query Params
      var queryParams = {
        classid: options.classid,
        productcode: options.productcode,
        groupid: options.groupid
      }

      if(options.itemcode) { queryParams.itemcode = options.itemcode; }
      if(options.history) { queryParams.history = options.history; }

      // Setup Request with url and params
      var requestAPI = request.get(url).query(queryParams);
      // Setup token in Authorization Header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Call GET GET GROUP RECORD ITEM
      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body)
        }
      });
    }
  } else {
    err.message = err.description = 'Required parameter classid or ' +
			'productcode or groupid not found in request options.';
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
  }
  return dfd.promise;
}

/**
 * This function returns the recent pending submissions of all the groups in a Class for a Product.
 * options = {
 *  classid: string,
 *  productcode: string,
 *  details: boolean,           // optional, if details of submissions is also required.
 *  limit: number               // optional, number of submissions to be fetched at once (default & max is 100)
 * }
 */
function getClassGroupsRecentPendingSubmissions(options) {
  var self = this;
  var dfd = q.defer(), err = {};

  if(options && options.classid && options.productcode) {
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err) { dfd.reject(err); }
    else {
      // Passed all validations, Constructing URL
      var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +
          self.config.ANALYTICS_API_URLS.getClassGroupsRecentPendingSubmissions;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      // Setup Query Params
      var queryParams = {
        classid: options.classid,
        productcode: options.productcode
      };

      if(options.details) { queryParams.details = options.details; }
      if(options.limit) { queryParams.limit = options.limit; }

      // Setup Request with url and params
      var requestAPI = request.get(url).query(queryParams);
      // Setup token in Authorization Header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Call GET Class Product Recent Pending Submissions of all groups
      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body);
        }
      });
    }
  }
  else {
    err.message = err.description = 'Mandatory parameters ["classid", "productcode"] not found in ' +
      'request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/**
 * options = {
  * classid: 'string',  //mandatory
  * productcode: 'string' //mandatory
  *}
  */
function getGroupsWithEvaluatedOnce(options) {
	var self = this, err = {};
	//Initializing promise
	var dfd = q.defer();
	if(options && options.classid && options.productcode) {
		//Validations
		err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) { dfd.reject(err); }
		else {
		// Passed all validations, Construct API url
			var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +
				self.config.ANALYTICS_API_URLS.getGroupsWithEvaluatedOnce;
			url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

			// Setup params
			var params = {
				classid: options.classid,
				productcode: options.productcode
			};
			// Setup request with URL and Params
			var requestAPI = request.get(url).query(params);
			// Setup token in Authorization header
			requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

			requestAPI.end(function(error, response) {
				if(error) {
					err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
					dfd.reject(err);
				}
				else { dfd.resolve(response.body); }
			});
		}
	} else {
		err.message = err.description = 'Required parameter classid or ' +
			'productcode not found in request options.';
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}
	return dfd.promise;
}

//options = {
//  classid: 'string',
//  productcode: 'string',
//  userid: 'string' //optional
//}

function getClassRecordUserAggregations(options) {
	var self = this, err = {};
	//Initializing promise
	var dfd = q.defer();
	if(options && options.classid && options.productcode) {
		//Validations
		err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) { dfd.reject(err); }
		else {
		// Passed all validations, Construct API url
			var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +
				self.config.ANALYTICS_API_URLS.getClassRecordUserAggregations;
			url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

			// Setup params
			var params = {
				classid: options.classid,
				productcode: options.productcode,
        userid: options.userid
			};
			// Setup request with URL and Params
			var requestAPI = request.get(url).query(params);
			// Setup token in Authorization header
			requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

			requestAPI.end(function(error, response) {
				if(error) {
					err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
					dfd.reject(err);
				}
				else { dfd.resolve(response.body); }
			});
		}
	} else {
		err.message = err.description = 'Required parameter classid or ' +
			'productcode not found in request options.';
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}
	return dfd.promise;
}

//options = {
//  type: ['stat' / 'timeseries'],
//  analyticsDataType: ['enrolments' / 'logins']
//  classid: 'string',
//	range: '', // for type - stat // OPTIONAL
//	start: '', // time(ms) - start interval // OPTIONAL
//	end: '' // time(ms) - end interval // OPTIONAL
//  interval: '' The interval at which counters are displayed. Possible values are five_minutes, half_hour, hour, six_day, day, week, and month. Default interval is day. // Only for type - timeseries // OPTIONAL
//}
function getClassAnalytics(options) {
	var self = this;

  //Initializing promise
  var dfd = q.defer();
  //Validations
  var err = {};
	if(options && options.type && options.analyticsDataType && options.classid) {
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) { dfd.reject(err); }
    else {
      err = {};
      if((!options.range && !options.interval) ||
       (options.range && options.type === 'stat') ||
       (options.interval && options.type === 'timeseries'))
      {
        var allowedAnalyticsDataType = ['enrolments', 'logins'];
				if(allowedAnalyticsDataType.indexOf(options.analyticsDataType) > -1) {
          //Passed all validations, Construct API url
					var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +
                    self.config.ANALYTICS_API_URLS.getClassAnalytics;
					url = helpers.api.constructAPIUrl(url, {
						orgId: self.orgId, type: options.type,
						analyticsDataType: options.analyticsDataType
					});

					var params = { classid: options.classid };
					if(options) {
						if(options.range) { params.range = options.range; }
						if(options.start) { params.start = options.start; }
						if(options.end) { params.end = options.end; }
						if(options.interval) { params.interval = options.interval; }
					}

					//Setup request with URL and Params
					var requestAPI = request.get(url).query(params);

					//Setup token in Authorization header
					requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

          // setting up traceid
          if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

					//Call Product Timespent Api
					requestAPI.end(function(err, response) {
						if(err) {
							err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
							dfd.reject(err);
						}
            else { dfd.resolve(response.body); }
					});
				} else {
					err.message = err.description = 'analyticsDataType: ' +
                                          options.analyticsDataType + ' is not supported';
					err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
					dfd.reject(err);
				}
			} else {
				err.message = err.description = 'Range should be defined for type - ' +
                          '"stat" and Interval should be defined for type - "timeseries"';
				err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
				dfd.reject(err);
			}
		}
	} else {
		err.message = err.description = 'Required options ["type", "analyticsDataType",' +
                                                ' "classid"] not found in request options';
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}

	return dfd.promise;
}

//options = {
//	useranalyticid: <userid>,
//  cursor: '', // OPTIONAL cursor to next set of documents
//  limit: '' // OPTIONAL limit of documents per function call (Default is 5)
//}
function getArchivedUserAnalytics(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();
  //Validations
  var err = {};
  if(options && options.useranalyticid) {
		err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) { dfd.reject(err); }
    else {
      //Passed all validations, Construct API url
			var url = self.config.DEFAULT_HOSTS['ANALYTICS'] +
                self.config.ANALYTICS_API_URLS.getArchivedUserAnalytics;
			url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });
			var params = { useranalyticid: options.useranalyticid };
			if(options) {
				if(options.cursor) { params.cursor = options.cursor; }
				if(options.limit) { params.limit = options.limit; }
			}

			//Setup request with URL and Params
			var requestAPI = request.get(url).query(params);

			//Setup token in Authorization header
			requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

			//Call Product Timespent Api
			requestAPI.end(function(err, response) {
				if(err) {
					err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
					dfd.reject(err);
				}
        else { dfd.resolve(response.body); }
			});
		}
	} else {
		err.message = err.description = "Mandatory field 'useranalyticid' not found" +
                                    " in request options";
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}

	return dfd.promise;
}

/*********************************************************
* This function converts the data from questions format to
* Learning Objective Format.
*********************************************************/
function getQuestionProgressByLearningObjective(questionsArray) {
    var learningObjectiveFormat = {};
    for(var i = 0; i < questionsArray.length; i++) {
        var questionLearningObjectives = questionsArray[i]['learning-objectives'];
        for(var j = 0; j < questionLearningObjectives.length; j++) {
            var analytics;
            var correct;
            var questionDataMap;
            if(!learningObjectiveFormat[questionLearningObjectives[j]]) {
                correct = 0;
                analytics = questionsArray[i].__analytics;
                if(analytics.statusEvaluation === 'correct') {
                    correct++;
                }
                var questionsMap = {
                    'status': {
                        'correct': correct,
                        'total': 1
                    },
                    'questions': []
                };
                questionDataMap = {
                    'question-code': questionsArray[i].questionCode,
                    'analytics': analytics
                };
                questionsMap.questions.push(questionDataMap);
                learningObjectiveFormat[questionLearningObjectives[j]] = questionsMap;
            }
            else {
                var savedQuestionsMap = learningObjectiveFormat[questionLearningObjectives[j]];
                analytics = questionsArray[i].__analytics;
                if(analytics.statusEvaluation === 'correct') {
                    correct = savedQuestionsMap.status.correct;
                    savedQuestionsMap.status.correct = correct + 1;
                }                        
                var total = savedQuestionsMap.status.total;
                savedQuestionsMap.status.total = total + 1;
                questionDataMap = {
                    'question-code': questionsArray[i].questionCode,
                    'analytics': analytics
                };                        
                savedQuestionsMap.questions.push(questionDataMap);
                learningObjectiveFormat[questionLearningObjectives[j]] = savedQuestionsMap;
            }
        }
    }
    return learningObjectiveFormat;
}

/* options = {
    "classid": "string", // required
  };
*/
function getAllAssignedPathsOfClass(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.classid) {

      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.ANALYTICS + self.config.ANALYTICS_API_URLS.getAllAssignedPathsOfClass;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      var queryParams = { classid: options.classid };

      // Setup request with URL and Params
      var requestAPI = request.get(url).query(queryParams);

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      requestAPI.end(function (error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory param - classid not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/* options = {
    "classid": "string", // required
    "assignedPathId" : "string", // required
    "productcode" : "string" //required
  };
*/
function getAssignedPathAnalytics(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.classid && options.assignedPathId && options.productcode) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.ANALYTICS + self.config.ANALYTICS_API_URLS.getAssignedPathAnalytics;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      var queryParams = {
        classid: options.classid,
        assignedpathid: options.assignedPathId,
        productcode: options.productcode
      };
      // Setup request with URL and Params
      var requestAPI = request.get(url).query(queryParams);

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      requestAPI.end(function (error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory params - classid or assignedPathId or productcode not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/* options = {
    "classid": "string", // required
    "userid" : "string", // required
    "progress" : "true/false",
    "group" : "true/false"
  };
*/
function getMyAssignedPathsOfClass(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.classid && options.userid ) {

      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.ANALYTICS + self.config.ANALYTICS_API_URLS.getMyAssignedPathsOfClass;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });
      var queryParams = { userid: options.userid, classid: options.classid };
      if(options.progress) { queryParams.progress =  options.progress; }
      if(options.group) { queryParams.group =  options.group; }

      // Setup request with URL and Params
      var requestAPI = request.get(url).query(queryParams);
      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      requestAPI.end(function (error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory params - classid, userid not found in ' +
                                      'request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/* options = {
    "classid": "string", // required
    "userid" : "string", // required
    "assignedPathId" : "string", // required
    "progress" : "true/false",
    "group" : "true/false"
  };
*/
function getMyParticularAssignedPathOfClass(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.classid && options.userid && options.assignedPathId ) {

      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.ANALYTICS + self.config.ANALYTICS_API_URLS.getMyAssignedPathsOfClass;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      var queryParams = {
        assignedpathid: options.assignedPathId, classid: options.classid, userid: options.userid
      };

      if(options.progress) { queryParams.progress =  options.progress; }
      if(options.group) { queryParams.group =  options.group; }

      // Setup request with URL and Params
      var requestAPI = request.get(url).query(queryParams);
      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // setting up traceid
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      requestAPI.end(function (error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory params - classid, userid, assignedPathId not found in ' +
                                      'request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*
  options = {
    query: 'string', //mandatory
    cursor: 'string' //optional
  }
*/
function getTimeseriesAnalytics(options) {
  var self = this;
  var dfd = q.defer();
  var err;

  if(options && options.query) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.ANALYTICS + self.config.ANALYTICS_API_URLS.getTimeseriesAnalytics;

    // Contruct parameters
    var params = {
      query: options.query
    };

    if(options.cursor) { params.cursor =  options.cursor; }
    //Setup request with URL and Params
    var requestAPI = request.get(url).query(params);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI
      .agent(keepaliveAgent)
      .end(function (error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
  }
  else {
    err = {};
    err.message = err.description = 'Mandatory params query not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}
},{"../../helpers":3,"agentkeepalive":37,"q":90,"superagent":133}],15:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

/***********************************************************
 * comproDLS SDK attempts Adaptor
 * Functions for calling attempts.
 ************************************************************/

/*********************************
 * Setting Up Module Entry Point
 **********************************/

var q = require('q');
var request = require('superagent');

var helpers = require('../../helpers');
var DLSError = helpers.errors.DLSError;

module.exports = attempts;

/*********************************
 * Public Function definitions
 **********************************/
function attempts() {
  return {
    getUserAllAttemptsForActivity: getUserAllAttemptsForActivity.bind(this),
    createUserAttemptForActivity: createUserAttemptForActivity.bind(this),
    getUserAttemptStatsForActivity: getUserAttemptStatsForActivity.bind(this),
    getUserAttemptForActivity: getUserAttemptForActivity.bind(this),
    getUserFirstAttemptForActivity: getUserFirstAttemptForActivity.bind(this),
    getUserLastAttemptForActivity: getUserLastAttemptForActivity.bind(this)
  };
}

/*
  options = {
  userid: 'string', //mandatory
  activityid: 'string', //mandatory
  allorgs: boolean, //default = false
  classid: 'string',
  assignmentid: 'string',
  productcode: 'string',
  cursor: 'string',
  limit: 'integer',
  sortOrder: 'string' //'asc' or 'desc'
  }
*/
function getUserAllAttemptsForActivity(options) {
  var self = this;
  var dfd = q.defer();
  var err;

  if(options && options.userid && options.activityid) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.ATTEMPTS + self.config.ATTEMPTS_API_URLS.userAttempts;
    url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, userId: options.userid, activityId: options.activityid });

    // Contruct parameters
    var params = {};
    if(options.allorgs) { params.allorgs = options.allorgs; }
    if(options.classid) { params.classid = options.classid; }
    if(options.assignmentid) { params.assignmentid = options.assignmentid; }
    if(options.productcode) { params.productcode = options.productcode; }
    if(options.cursor) { params.cursor = options.cursor; }
    if(options.limit) { params.limit = options.limit; }
    if(options.sortOrder) { params.sortOrder = options.sortOrder; }

    //Setup request with URL and Params
    var requestAPI = request.get(url).query(params);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if (err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Mandatory params - userid or activityid ' +
      'not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/*
  options = {
  userid: 'string', //mandatory
  activityid: 'string', //mandatory
  "body": {
      "classid": "string",
      "assignmentid": "string",
      "itemcode":"string",
      "productcode": "string",
      "max_allowed":"string"
    }
  }
*/
function createUserAttemptForActivity(options) {
  var self = this;
  var dfd = q.defer();
  var err;

  if(options && options.userid && options.activityid && options.body) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.ATTEMPTS + self.config.ATTEMPTS_API_URLS.userAttempts;
    url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, userId: options.userid, activityId: options.activityid });

    //Setup request with URL and Body
    var requestAPI = request.post(url).send(options.body);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if (err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Mandatory params - userid or activityid or body ' +
      'not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/*
  options = {
  userid: 'string', //mandatory
  activityid: 'string', //mandatory
  classid: 'string', //mandatory with assignmentid
  assignmentid: 'string',
  allorgs: boolean // default = false
  }
*/
function getUserAttemptStatsForActivity(options) {
  var self = this;
  var dfd = q.defer();
  var err;

  if(options && options.userid && options.activityid) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.ATTEMPTS + self.config.ATTEMPTS_API_URLS.getUserAttemptStatsForActivity;
    url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, userId: options.userid, activityId: options.activityid });

    // Contruct parameters
    var params = {};
    if(options.allorgs) { params.allorgs = options.allorgs; }
    if(options.classid) { params.classid = options.classid; }
    if(options.assignmentid) { params.assignmentid = options.assignmentid; }

    //Setup request with URL and Params
    var requestAPI = request.get(url).query(params);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if (err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Mandatory params - userid or activityid ' +
      'not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/*
  options = {
  userid: 'string', //mandatory
  activityid: 'string', //mandatory
  attemptid: 'string', //mandatory
  details: boolean
  }
*/
function getUserAttemptForActivity(options) {
  var self = this;
  var dfd = q.defer();
  var err;

  if(options && options.userid && options.activityid && options.attemptid) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.ATTEMPTS + self.config.ATTEMPTS_API_URLS.getUserAttemptForActivity;
    url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, userId: options.userid, activityId: options.activityid,
                                              attemptId: options.attemptid });

    // Contruct parameters
    var params = {};
    if(options.details) { params.details = options.details; }

    //Setup request with URL and Params
    var requestAPI = request.get(url).query(params);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if (err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Mandatory params - userid or activityid or attemptid ' +
      'not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/*
  options = {
  userid: 'string', //mandatory
  activityid: 'string', //mandatory
  classid: 'string' //mandatory with assignmentid
  assignmentid: 'string'
  details: boolean
  }
*/
function getUserFirstAttemptForActivity(options) {
  var self = this;
  var dfd = q.defer();
  var err;

  if(options && options.userid && options.activityid) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.ATTEMPTS + self.config.ATTEMPTS_API_URLS.getUserFirstAttemptForActivity;
    url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, userId: options.userid, activityId: options.activityid });

    // Contruct parameters
    var params = {};
    if(options.details) { params.details = options.details; }
    if(options.classid) { params.classid = options.classid; }
    if(options.assignmentid) { params.assignmentid = options.assignmentid; }

    //Setup request with URL and Params
    var requestAPI = request.get(url).query(params);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if (err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Mandatory params - userid or activityid ' +
      'not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/*
  options = {
  userid: 'string', //mandatory
  activityid: 'string', //mandatory
  classid: 'string'//mandatory with assignmentid
  assignmentid: 'string'
  details: boolean
  }
*/
function getUserLastAttemptForActivity(options) {
  var self = this;
  var dfd = q.defer();
  var err;

  if(options && options.userid && options.activityid) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.ATTEMPTS + self.config.ATTEMPTS_API_URLS.getUserLastAttemptForActivity;
    url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, userId: options.userid, activityId: options.activityid });

    // Contruct parameters
    var params = {};
    if(options.details) { params.details = options.details; }
    if(options.classid) { params.classid = options.classid; }
    if(options.assignmentid) { params.assignmentid = options.assignmentid; }

    //Setup request with URL and Params
    var requestAPI = request.get(url).query(params);
    console.log(url, params, requestAPI);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if (err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Mandatory params - userid or activityid ' +
      'not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

},{"../../helpers":3,"q":90,"superagent":133}],16:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

/***********************************************************
 * comproDLS SDK AUTH API Adaptor
 * Functions for calling AUTH API.
 ************************************************************/

var q = require('q');
var request = require('superagent');
var Agent = require('agentkeepalive');

var helpers = require('../../helpers');
var converter = require('../../helpers/lib/api/converter');

var DLSError = helpers.errors.DLSError;

/*********************************
 * Setting Up Module Entry Point  
 **********************************/
module.exports = auth;

var keepaliveAgent = new Agent({
  timeout: 60000,
  freeSocketTimeout: 30000
});

//Auth Adaptor Contsructor
function auth() {
  return {
    pisImport: pisImport.bind(this),

    getAllUsers: getAllUsers.bind(this),
    getUserProfile: getUserProfile.bind(this),
    deleteUserProfile: deleteUserProfile.bind(this),
    updateUserRole: updateUserRole.bind(this),
    getUserClasses: getUserClasses.bind(this),
    getClassUsers: getClassUsers.bind(this),
    enrollUsertoClass: enrollUsertoClass.bind(this),
    enrollSelftoClass: enrollSelftoClass.bind(this),
    enrollMultiUserstoClass: enrollMultiUserstoClass.bind(this),
    unEnrollMultiUserstoClass: unEnrollMultiUserstoClass.bind(this),
    unEnrollUsertoClass: unEnrollUsertoClass.bind(this),

    getOrgSettings: getOrgSettings.bind(this),
    updateOrgSettings: updateOrgSettings.bind(this),
    generateClassCode: generateClassCode.bind(this),

    getAllJobs: getAllJobs.bind(this),
    getJob: getJob.bind(this),

    createClass: createClass.bind(this),
    updateClass: updateClass.bind(this),
    createMultipleClasses: createMultipleClasses.bind(this),
    cloneClass: cloneClass.bind(this),
    getAllClasses: getAllClasses.bind(this),
    getParticularClass: getParticularClass.bind(this),
    getParticularShadowClass: getParticularShadowClass.bind(this),
    createClassProductAssociation: createClassProductAssociation.bind(this),
    removeClassProductAssociation: removeClassProductAssociation.bind(this),
    createMultiClassProductAssociations: createMultiClassProductAssociations.bind(this),
    addItemsToShowcaseOfAClass: addItemsToShowcaseOfAClass.bind(this),
    deleteItemsFromShowcaseOfAClass: deleteItemsFromShowcaseOfAClass.bind(this),

    getClassAppdata: getClassAppdata.bind(this),
    putClassAppdata: putClassAppdata.bind(this),
    deleteClassAppdata: deleteClassAppdata.bind(this),

    encodeURLParameter: encodeURLParameter.bind(this),

    createAssignedPath: createAssignedPath.bind(this),
    deleteAssignedPath: deleteAssignedPath.bind(this),
    updateAssignedPath: updateAssignedPath.bind(this),

    //Groups related APIs
    createGroup: createGroup.bind(this),
    getAllGroupsByPath: getAllGroupsByPath.bind(this),
    getAGroup: getAGroup.bind(this),
    updateGroup: updateGroup.bind(this),
    deleteGroup: deleteGroup.bind(this),
    getAllMembersOfAGroup: getAllMembersOfAGroup.bind(this),
    getAllGroupMembersByPath: getAllGroupMembersByPath.bind(this),
    createMultiUserGroupMembership: createMultiUserGroupMembership.bind(this),
    deleteMultiUserGroupMembership: deleteMultiUserGroupMembership.bind(this),
    getMyAllMemberships: getMyAllMemberships.bind(this),
    archiveGroup: archiveGroup.bind(this),
    unarchiveGroup: unarchiveGroup.bind(this)
  };
}

/*********************************
 * Public Function definitions
 **********************************/

//options = {
//    userid: 'uuid or username',  //optional.
//}
function getUserProfile(options) {
  /* Reference to comproDLS SDK object , contains the following properties
   * 1. self.orgId [String] : organization Id
   * 2. self.token [Object] : DLS token. It has following structure
   *    {
   *      "access_token" : [String]
   *    }
   */
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    var userid = 'me';
    if(options) {
      if(options.userid) { userid = options.userid; }
    }
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
              self.config.AUTH_API_URLS.userInfoAPI;
    url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, userId: userid });

    // Contruct parameters
    var params = {};

    // Setup request with URL and Params
    var requestAPI = request.get(url).query(params);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    // Setup token in Authorization header
    requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
    // Call GET USER INFO Api
    requestAPI.end(function(err, response) {
      if(err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else {
        var res = converter.convertUserResponse({data: response.body});
        dfd.resolve(res);
      }
    });
  }
  return dfd.promise;
}

/**
 * options = {
 *     userid : ""    // dls user id, mandatory
 * }
 */

function deleteUserProfile(options) {
  var self = this;
  var dfd = q.defer();

  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if (options.userid) {
      var userid = options.userid;

      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
        self.config.AUTH_API_URLS.userInfoAPI;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, userId: userid });

      // Setup request with URL
      var requestAPI = request.delete(url);
      if (self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // Call DELETE USER API
      requestAPI.end(function (error, response) {
        if (error) {
          error = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(error);
        }
        else { dfd.resolve(response.body); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory parameter userid not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

//options = {
//    search: 'search string',   //optional.
//    lookup: 'string', // Search query (',' separated key value pairs), e.g. key1:val1,key2:val2,key3:val3
//    lookup-operator: 'AND'/'OR', // Operator to use while lookup. Current Possible Value - AND, OR
//    cursor: 'cursor',      //optional, cursor to get next set of groups.
//    limit: number,         //optional, limit the number of Users to fetch at a time.
//    role: 'string'         //optional, to search Users by Role
//    sortField: ['first_name', 'last_name', 'ext_email', 'created', 'roles', ... (other fields of response entity)]
//              Sort the result according to given field. By default is 'last_name’, followed by ‘first_name’ in asc order.
//    sortOrder: ['desc', 'asc']   //optional, By default is 'desc’.
//}
function getAllUsers(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    var queryStr = 'orgid:"' + self.orgId + '"';

    if(options.lookup && options['lookup-operator']) {
      var lookupString = options.lookup;
      lookupString = lookupString.replace(/ext_/ig, '');
      var lookupArray = lookupString.split(',').map(function(item) {
        var lookupItem = item.trim();
        var tempArr = lookupItem.split(':');
        lookupItem = '(' + lookupItem + ' OR ' + tempArr[0] + '.keyword:' + tempArr[1] + ')';
        return lookupItem;
      });
      queryStr = queryStr + ' AND (' + lookupArray.join(' ' + options['lookup-operator'] + ' ') + ')';
    }

    if(options.role) {
      var roleNameString = options.role;
      var roleNameArray = roleNameString.split(',').map(function(item) { return item.trim(); });
      for(var idx in roleNameArray){
        roleNameArray[idx] = 'roles:' + roleNameArray[idx];
      }
      queryStr = queryStr + ' AND (' + roleNameArray.join(' OR ') + ')';
    }

    if(options.search) {
      queryStr = queryStr + ' AND (email:"' + options.search + '" OR first_name:"' + options.search + '" OR last_name:"'
                  + options.search + '" OR username:"' + options.search + '" OR userid:"' + options.search + '")';
    }

    var sortField = options.sortField || '';
    sortField = sortField.replace(/ext_/ig, '').split(',').shift().trim() || 'last_name';
    var sortOrder = options.sortOrder || 'asc';
    if(sortField !== 'created') {
      sortField = sortField + '.keyword';
    }
    var sortObj = {}, sortArr = [];
    sortObj[sortField] = sortOrder;
    sortArr.push(sortObj);

    var queryObj = {
      query: { query_string: { query: queryStr } },
      sort: sortArr
    };

    if(options.cursor) { queryObj.search_after = JSON.parse(options.cursor); }
    if(options.limit) { queryObj.size = options.limit; }
    else { options.limit = 10; } // by default ES returns only 10 elements at max.

    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.INTEGRATION +
              self.config.INTEGRATIONS_API_URLS.queryDataFromSearch;
    url = helpers.api.constructAPIUrl(url, { index: 'users' });

    // Contruct parameters
    var params = {
      query: JSON.stringify(queryObj)
    };

    // Setup request with URL and Params
    var requestAPI = request.get(url).query(params);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    // Setup token in Authorization header
    requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

    // Call GET ALL USER Api
    requestAPI.end(function(err, response) {
      if(err) {
        var esErrOptions = { type: helpers.errors.ERROR_TYPES.API_ERROR, err: err };
        var error = converter.convertElasticsearchErrResponse(esErrOptions);
        dfd.reject(error);
      }
      else {
        var responseObject = { entities: [] };
        responseObject.count = response.body.hits.hits.length;
        if(responseObject.count && (options.limit  === responseObject.count)) {
          var cursor = response.body.hits.hits[response.body.hits.hits.length - 1].sort;
          responseObject.cursor = JSON.stringify(cursor);
        }

        for(var index in response.body.hits.hits) {
          var userEntity = response.body.hits.hits[index]._source;
          var userObj = {
            uuid: userEntity.dls_user_id,
            name: userEntity.first_name + ' ' + userEntity.last_name,
            email: userEntity.email || userEntity.ext_email,
            username: userEntity.userid + '--ACCOUNT',
            created: userEntity.created,
            org: { id: self.orgId }
          };
          if(userEntity.roles) {
            userObj.roles = userEntity.roles;
          }
          if(userEntity.provision_method) {
            userObj.provision_method = userEntity.provision_method;
          }
          if(userEntity.first_name) {
            userObj.first_name = userEntity.first_name;
          }
          if(userEntity.last_name) {
            userObj.last_name = userEntity.last_name;
          }
          if(userEntity.ext_parent_id) {
            userObj.ext_parent_id = userEntity.ext_parent_id;
          }
          if(userEntity.username) {
            userObj.ext_username = userEntity.username;
          }
          if(userEntity.userid) {
            userObj.ext_user_id = userEntity.userid;
          }
          if(userEntity.address) {
            userObj.address = userEntity.address;
          }
          responseObject.entities.push(userObj);
        }
        dfd.resolve(responseObject);
      }
    });
  }
  return dfd.promise;
}

//options = {
//    userid: 'dlsUserId',  //mandatory
//    target_role: 'string', //mandatory
//    ext_data: { email_template_id: string } //optional
//}
function updateUserRole(options) {
  var self = this;

  // Initializing promise
  var dfd = q.defer();
  // Validations
  var error = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(error) { dfd.reject(error); }
  else {
    if(options && options.userid && options.target_role) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                                self.config.AUTH_API_URLS.updateUserRoleAPI;
      url = helpers.api.constructAPIUrl(url, { orgId : self.orgId, userId: options.userid });
      var bodyParams = { ext_data: options.ext_data, target_role: options.target_role };
      // Setup request with URL and Params
      var requestAPI = request.put(url)
                      .set('Content-Type', 'application/json')
                      .set('Accept', 'application/json')
                      .send(bodyParams);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
      // Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        }
        else { dfd.resolve(response); }
      });
    } else {
      var err = {};
      err.message = err.description = 'Mandatory parameter options, userid or target_role, not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }

  return dfd.promise;
}

//options = {
//    userid: 'uuid or username',  //optional.
//    search: 'search string',   //optional.
//    details: true/false,  //optional, includes products & assignments information of class.
//    sortField: ['startdate', 'enddate', 'title']       //optional, By default is 'title’.
//    sortOrder: ['desc', 'asc'] //optional, By default is 'desc’.
//    enrollmentType: ['creator', 'teacher', 'student'] //optional, bydefault send all classes.
//    teacherId: 'string' //optional, get classes of a particular teacher only.
//    cursor: 'cursor'      //optional, cursor to get next set of classes
//    limit: integer      //optional, Number of entities to fetch at once
//    bundleDetails: true/false      //optional
//}
function getUserClasses(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    var userid = 'me';
    if(options) {
      if(options.userid) { userid = options.userid; }
    }
    // Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
              self.config.AUTH_API_URLS.getUserClassesAPI;
    url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, userId: userid });

    // Contruct parameters
    var params = {};
    if(options) {
      if(options.search) { params.search = 'title:' + options.search; }
      if(options.details) { params.details = options.details; }
      if(options.enrollmentType) { params.enrollmentType = options.enrollmentType; }
      if(options.sortField) { params.sortField = options.sortField; }
      if(options.sortOrder) { params.sortOrder = options.sortOrder; }
      if(options.cursor) { params.cursor = options.cursor; }
      if(options.limit) { params.limit = options.limit; }
      if(options.teacherId) { params.lookup = 'class.class.instructor.uuid:' + options.teacherId; }
      if(options.bundleDetails) { params.bundleDetails = options.bundleDetails; }
    }

    // Setup request with URL and Params
    var requestAPI = request.get(url).query(params);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    // Setup token in Authorization header
    requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

    // Call GET ALL USER Api
    requestAPI.end(function(err, response) {
      if(err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  return dfd.promise;
}

/**
 * options = {
 *    classid: 'classid',
 *    search: 'string',         // (optional) Search Query
 *    cursor: 'string',         // (optional) Cursor string to fetch next set of Users
 *    limit: 'integer'          // (optional) Number of users to fetch at a time.
 *    sortField: 'string'       // (optional) Sort the result according to given field. By default is 'email’.
 *    sortOrder: 'string'       // (optional) Sort the result according to given order. By default is 'desc’.
 * }
 */
function getClassUsers(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.classid) {
      // Passed all validations, Construct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.getClassUsersAPI;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId, classId: options.classid
      });

      // Setup params
      var params = {};
      if(options.search) { params.search = options.search; }
      if(options.cursor) { params.cursor = options.cursor; }
      if(options.limit) { params.limit = options.limit; }
      if(options.sortField) { params.sortField = options.sortField; }
      if(options.sortOrder) { params.sortOrder = options.sortOrder; }

      // Setup request with URL and Params
      var requestAPI = request.get(url).query(params);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // Call GET ALL USER Api
      requestAPI
        .agent(keepaliveAgent)
        .end(function(err, response) {
          if(err) {
            err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
            dfd.reject(err);
          }
          else {
            response.body.entities = converter.convertEnrollmetsResponse({data: response.body.entities}) ;
            dfd.resolve(response.body);
          }
        });
    } else {
      err = {};
      err.message = err.description = 'Required parameter classid is not defined.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

//options = {
//    extension: 'csv',
//    import_type: 'users'/'groups'/'user-group-enrollment',
//    upFile: '' // path to csv file to be uploaded
//}
function pisImport(options) {
	var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    // Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
              self.config.AUTH_API_URLS.pisImportAPI;
    url = helpers.api.constructAPIUrl(url, {"orgId" : self.orgId});
    // Contruct parameters
    var params = {};
    var upfile;
    if(options) {
      if(options.extension) { params.extension = options.extension; }
      if(options.import_type) { params.import_type = options.import_type; }
      if(options.upfile) { upfile = options.upfile; }
    }

    // Setup request with URL and Params
    var requestAPI = request.post(url).query(params)
                     .set('Content-Type', 'multipart/form-data')
                     .attach('upfile', upfile);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    // Setup token in Authorization header
    requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

    // Call PIS IMPORT Api
    requestAPI.end(function(err, response) {
      if(err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  return dfd.promise;
}

//options = {
//	field: '' // apps / lti / sis / pis / product[ANY ONE]
//}
function getOrgSettings(options) {
	var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    // Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
              self.config.AUTH_API_URLS.getSettings;
    url = helpers.api.constructAPIUrl(url, {orgId: self.orgId});

    // Contruct parameters
    var params = {};
    if(options && options.field) {
      url = self.config.DEFAULT_HOSTS.AUTH +
            self.config.AUTH_API_URLS.getSettingsField;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId, field: options.field
      });
    }

    // Setup request with URL and Params
    var requestAPI = request.get(url).query(params);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    // Setup token in Authorization header
    requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

    // Call SIS IMPORT Api
    requestAPI.end(function(err, response) {
      if(err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  return dfd.promise;
}

//options = {
//	body: {} // the top level settings field to be updated.
//}
function updateOrgSettings(options) {
	var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    // Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
              self.config.AUTH_API_URLS.getSettings;
    url = helpers.api.constructAPIUrl(url, {orgId: self.orgId});
    // Setup request with URL and Params
    var requestAPI = request.put(url);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    if(options.body) {
      if(options.body.sis && (! options.body.sis.productid)) {
        options.body.sis.productid = [];
      }
      requestAPI.send(options.body);
    }
    // Setup token in Authorization header
    requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

    // Call SIS IMPORT Api
    requestAPI.end(function(err, response) {
      if(err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  return dfd.promise;
}

//options = {
//	classid: "string"
//}
function generateClassCode(options) {
  var self = this, err;
  // Initializing promise
  var dfd = q.defer();
  if(options && options.classid) {
    // Validations
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err) { dfd.reject(err); }
    else {
      // Passed all validations, Construct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                              self.config.AUTH_API_URLS.generateClassCode;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId, classId: options.classid
      });
      // Setup request with URL and Params
      var requestAPI = request.post(url);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // Call Update class settings Api
      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    }
  } else {
    err = {};
    err.message = err.description = 'classid not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/**
 * {
    accountId: 'string'  //mandatory
    extUserId: 'string',  //mandatory
    jobType: 'string'  //optional queryParam, Use this param to get  All Jobs of a particular jobType.
  }
 */
function getAllJobs(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  if(options && options.accountId && options.extUserId) {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.getAllJobs;
    url = helpers.api.constructAPIUrl(url, { accountId : options.accountId, extUserId: options.extUserId });
  
    var params = {};
    if(options.jobType) { params.jobType = options.jobType; }

    // Setup request with URL and Params
    var requestAPI = request.get(url).query(params);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } else {
    var err = {};
    err.message = err.description = 'accountId or extUserId not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/**
 * options = {
    accountId: 'string', //mandatory
    extUserId: 'string', //mandatory
    jobId: 'string', //mandatory
    jobType: 'string' //mandatory
  }
 */
function getJob(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  if(options && options.accountId && options.extUserId && options.jobId && options.jobType) {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.getJob;
    url = helpers.api.constructAPIUrl(url, { accountId : options.accountId, extUserId: options.extUserId,
      jobId: options.jobId });
    var params = { jobType: options.jobType };

    // Setup request with URL and Params
    var requestAPI = request.get(url).query(params);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } else {
    var err = {};
    err.message = err.description = 'accountId or extUserId or jobType or jobId or not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}


/**
 * @param {*} options {
 *  search: 'search string',        // Optional
 *  sortField: ['startdate', 'enddate', 'title', 'created', 'tagname_1'] // Optional
 *                                  // Default: 'created’.
 *  sortOrder: ['desc', 'asc']      // Optional, Default: 'desc’.
 *  cursor: 'cursor'                // Optional, cursor to get next set of groups.
 *  limit: integer,                 // Optional, limit number of Classes in response.
 *  lookup: 'string',               // Optional, Exact query search (',' separated key value pairs).
 *                                  // E.g. key1:val1,key2:val2
 *  lookup-operator: ['OR', 'AND']  // Optional
 * }
 * @returns {entities: [{}, {}, ...], count: <integer>, cursor: <string>}
 */
function getAllClasses(options) {
    var self = this;

    //Initializing promise
    var dfd = q.defer();

    //Validations
    var err = helpers.validations.isAuthenticated(self.orgId, self.token);

    if(err) {
        dfd.reject(err);
    } else {
        var queryStr = 'orgid:"' + self.orgId + '"';

        if (options.lookup && options['lookup-operator']) {
          var lookupString = options.lookup;
          var lookupArray = lookupString.split(',').map(function (item) {
            var lookupItem = item.trim();
            var tempArr = lookupItem.split(':');
            lookupItem = '(' + tempArr[0] + '.keyword:' + tempArr[1] + ')';
            return lookupItem;
          });
          queryStr += ' AND (' + lookupArray.join(' ' + options['lookup-operator'] + ' ') + ')';
        }

        if(options.search) {
          queryStr = queryStr + ' AND (title:"' + options.search + '" OR class.instructor.first_name:"' + options.search +
                      '" OR class.instructor.last_name:"' + options.search + '" OR description:"' + options.search + '")';
        }

        var sortField = options.sortField || '';
        sortField = sortField.replace(/ext_/ig, '').split(',').shift().trim() || 'created';

        if(sortField === 'enddate' || sortField === 'startdate') {
          sortField = 'class.' + sortField;
        }

        if(sortField === 'title') {
          sortField = sortField + '.keyword';
        }

        if (sortField === 'tagname_1') {
          sortField = sortField + '.keyword';
        }

        var sortOrder = options.sortOrder || 'desc';
        var sortObj = {}, sortArr = [];
        sortObj[sortField] = sortOrder;
        sortArr.push(sortObj);

        var queryObj = {
          query: { query_string: { query: queryStr } },
          sort: sortArr
        };

        if(options.cursor) { queryObj.search_after = JSON.parse(options.cursor); }
        if(options.limit) { queryObj.size = options.limit; }
        else { options.limit = 10; } // by default ES returns only 10 elements at max.

        //Passed all validations, Construct API url
        var url = self.config.DEFAULT_HOSTS.INTEGRATION +
                  self.config.INTEGRATIONS_API_URLS.queryDataFromSearch;
        url = helpers.api.constructAPIUrl(url, { index: 'classes' });

        // Contruct parameters
        var params = {
          query: JSON.stringify(queryObj)
        };

        //Setup request with URL and Params
        var requestAPI = request.get(url).query(params);
        if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

        //Setup token in Authorization header
        requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

        //Call GET ALL USER Api
        requestAPI.end(function(err, response) {
            if(err) {
              var esErrOptions = { type: helpers.errors.ERROR_TYPES.API_ERROR, err: err };
              var error = converter.convertElasticsearchErrResponse(esErrOptions);
              dfd.reject(error);
            } else {
              var responseObject = { entities: [] };
              responseObject.count = response.body.hits.hits.length;
              if(responseObject.count && (options.limit  === responseObject.count)) {
                var cursor = response.body.hits.hits[response.body.hits.hits.length - 1].sort;
                responseObject.cursor = JSON.stringify(cursor);
              }
              for(var index in response.body.hits.hits) {
                var classEntity = response.body.hits.hits[index]._source;
                var classObj = {
                  uuid: classEntity.classid,
                  created: classEntity.created,
                  modified: classEntity.modified,
                  path: classEntity.path,
                  category: classEntity.category,
                  class: {
                    enddate: classEntity.class.enddate,
                    instructor: {
                      name: classEntity.class.instructor.first_name + ' ' + classEntity.class.instructor.last_name,
                      last_name: classEntity.class.instructor.last_name,
                      first_name: classEntity.class.instructor.first_name,
                      uuid: classEntity.class.instructor.dls_user_id,
                      email: classEntity.class.instructor.email,
                      username: classEntity.class.instructor.userid + '--ACCOUNT'
                    },
                    startdate: classEntity.class.startdate
                  },
                  'class.settings.active': classEntity['class.settings.active'],
                  class_code: classEntity.class_code,
                  class_ownership: classEntity.class_ownership || { owner_status: 'ENROLLED', model: 'STRICT' },
                  description: classEntity.description,
                  provision_method: classEntity.class.provision_method,
                  title: classEntity.title,
                  analyticsharingmodel: classEntity.analyticsharingmodel,
                  studentCount: classEntity.studentCount,
                  teacherCount: classEntity.teacherCount
                };

                /**
                 * Add class-tag association specific fields
                 */
                if (classEntity.tagid_1) {
                  classObj.tagid_1 = classEntity.tagid_1;
                  classObj.tagname_1 = classEntity.tagname_1;
                  classObj.taglookup_1 = classEntity.taglookup_1;
                }

                if (classEntity.tagid_2) {
                  classObj.tagid_2 = classEntity.tagid_2;
                  classObj.tagname_2 = classEntity.tagname_2;
                  classObj.taglookup_2 = classEntity.taglookup_2;
                }

                if (classEntity.tagid_3) {
                  classObj.tagid_3 = classEntity.tagid_3;
                  classObj.tagname_3 = classEntity.tagname_3;
                  classObj.taglookup_3 = classEntity.taglookup_3;
                }

                responseObject.entities.push(classObj);
              }
              dfd.resolve(responseObject);
            }
        });
    }
    return dfd.promise;
}


//options = {
//    classId: 'class uuid'
//}
function getParticularClass(options) {
    var self = this;

    //Initializing promise
    var dfd = q.defer();

    //Validations
    var err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err) {
        dfd.reject(err);
    } else {
        if(options && options.classId) {
            //Passed all validations, Contruct API url
            var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.getParticularClassAPI;
            url = helpers.api.constructAPIUrl(url,  { orgId: self.orgId, classId: options.classId } );

            var requestAPI = request.get(url);
            if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

            //Setup token in Authorization header
            requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

            requestAPI
              .agent(keepaliveAgent)
              .end(function(err, response) {
                  if(err) {
                      err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
                      dfd.reject(err);
                  } else {
                    dfd.resolve(response.body);
                  }
              });
        } else {
            err = {};
            err.message = err.description = 'classId not found in request options.';
            err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
            dfd.reject(err);
        }
    }
    return dfd.promise;
}

//options = {
//  ext_classid: 'ext classid' //mandatory
//}
function getParticularShadowClass(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();

  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) {
    dfd.reject(err);
  }
  else {
    if(options && options.ext_classid) {
      //Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.getParticularShadowClassAPI;
      url = helpers.api.constructAPIUrl(url,  { orgId: self.orgId, extClassId: options.ext_classid } );

      var requestAPI = request.get(url);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        } 
        else {
          dfd.resolve(response.body);
        }
      });
    } else {
      err = {};
      err.message = err.description = 'ext_classid not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

//options = {
//    classId: 'class uuid',
//    productcode: 'productcode'
//}
function createClassProductAssociation(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.classId && options.productcode) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.classProductAssociation;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId, classId: options.classId, productcode: options.productcode
      });

      // Setup request with URL and Params
      var requestAPI = request.post(url)
                       .set('Content-Type', 'application/json')
                       .set('Accept', 'application/json');
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    } else {
      err = {};
      err.message = err.description = 'classId or productcode not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

//options = {
//    classId: 'class uuid',
//    productcode: 'product code'
//}
function removeClassProductAssociation(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.classId && options.productcode) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.classProductAssociation;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId, classId: options.classId, productcode: options.productcode
      });

      // Contruct parameters
      var params = {};

      // Setup request with URL and Params
      var requestAPI = request.delete(url).query(params);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    } else {
      err = {};
      err.message = err.description = 'classId or productcode not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/**
 * This function creates multiple class-product associations.
 * @param options {
 *  *classId      : <string>,
 *  *productcodes : [<string>] // Min: 1, Max: 50
 * }
 * Note: Fields marked with '*' are mandatory.
 */
function createMultiClassProductAssociations(options) {
  var deferred = q.defer();
  var self = this;
  var error = helpers.validations.isAuthenticated(self.orgId, self.token);

  if (error) {
    deferred.reject(error);
  } else if (options && options.classId && options.productcodes) {
    // Passed all validations, Contruct API url
    var defaultHostPath = self.config.DEFAULT_HOSTS.AUTH;
    var bulkCPAssociationAPIPath = self.config.AUTH_API_URLS.multiClassProductAssociations;

    var url = defaultHostPath + bulkCPAssociationAPIPath;
    var bodyParams = { productcodes: options.productcodes };

    url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, classId: options.classId });

    // Setup request with URL and Params
    var requestAPI = request.post(url)
                      .set('Content-Type', 'application/json')
                      .set('Accept', 'application/json')
                      .send(bodyParams);

    if (self.traceid) {
      requestAPI.set('X-Amzn-Trace-Id', self.traceid);
    }

    // Setup token in Authorization header
    requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

    requestAPI.end(function(err, response) {
      if (err) {
        error = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        deferred.reject(error);
      } else {
        deferred.resolve(response.body);
      }
    });
  } else {
    error = {};
    error.message = error.description = 'Missing mandaotry fields \'classId\' or \'productcodes\' in request.';
    error = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, error);
    deferred.reject(error);
  }

  return deferred.promise;
}

/*options = {
  classid: 'string'
}*/
function getClassAppdata(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.classid) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.ClassAppdata;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId, classid: options.classid
      });
      //Setup request with URL
		var requestAPI = request.get(url);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

		//Setup token in Authorization header
		requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

		//Call Class Appdata Api
		requestAPI.end(function(err, response) {
			if(err) {
				err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
				dfd.reject(err);
			} else {
				dfd.resolve(response.body);
			}
		});
    } else {
      err = {};
      err.message = err.description = 'classid  not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*options = {
  classid: 'string',
  appdata: {}
}*/

function putClassAppdata(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.classid && options.appdata) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.ClassAppdata;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId, classid: options.classid
      });

      // Setup request with URL and Params
      var requestAPI = request.put(url)
                       .set('Content-Type', 'application/json')
                       .set('Accept', 'application/json')
                       .send(options.appdata);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    } else {
      err = {};
      err.message = err.description = 'classid or appdata not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*options = {
  classid: 'string'
}*/

function deleteClassAppdata(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.classid) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.ClassAppdata;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId, classid: options.classid
      });

      // Setup request with URL and Params
      var requestAPI = request.delete(url);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      // Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    } else {
      err = {};
      err.message = err.description = 'classid not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

//options = {
//    classid: '', //Class Id
//    userid: '', //User Id
//};
function enrollUsertoClass(options) {
    var self = this;
	var err = {};
    //Initializing promise
    var dfd = q.defer();
	if(options && options.classid && options.userid) {
		//Validations
		err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) {
			dfd.reject(err);
		} else {
			//Passed all validations, Construct API url
			var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.enrollUsertoClass;
			url = helpers.api.constructAPIUrl(url, {
				orgId: self.orgId,
				classId: options.classid,
                userId: options.userid
			});

			//Contruct parameters
			var params = {};

      //Setup request with URL and Params
      var requestAPI = request.post(url)
                              .set('Content-Type', 'application/json')
                              .set('Accept', 'application/json')
                              .query(params);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

			//Setup token in Authorization header
			requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

			//Call GET Product by it's code Api
			requestAPI.end(function(err, response) {
				if(err) {
					err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
					dfd.reject(err);
				} else {
					dfd.resolve(response.body);
				}
			});
		}
	} else {
		err.message = err.description = 'Mandatory parameter classid or userid not found in request options';
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}
    return dfd.promise;
}

//options = {
//    classid: '', //Class Id
//    classrole: ''
//};
function enrollSelftoClass(options) {
  var self = this;
  var err = {};
  //Initializing promise
  var dfd = q.defer();
  if(options && options.classid) {
    //Validations
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err) {
      dfd.reject(err);
    } else {
      //Passed all validations, Construct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.enrollSelftoClass;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        classId: options.classid
      });

      var params = { classrole: options.classrole };
      //Setup request with URL and Params
      var requestAPI = request.post(url)
                              .set('Content-Type', 'application/json')
                              .set('Accept', 'application/json')
                              .send(params);

      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      //Call GET Product by it's code Api
      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body);
        }
      });
    }
  }
  else {
    err.message = err.description = 'Mandatory parameter classid not found in request options';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

//options = {
//    classid: '', //Class Id
//    users: ['dls-userid1', 'dls-userid-2'] //Users Id
//};
function enrollMultiUserstoClass(options) {
  var self = this;
  var err = {};
  //Initializing promise
  var dfd = q.defer();
  if(options && options.classid && options.users) {
    //Validations
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err) {
      dfd.reject(err);
    } else {
      //Passed all validations, Construct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.enrollMultiUserstoClass;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        classId: options.classid
      });

      //Contruct parameters
      var params = {
        users: options.users
      };
      //Setup request with URL and Params
      var requestAPI = request.post(url)
                              .set('Content-Type', 'application/json')
                              .set('Accept', 'application/json')
                              .send(params);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      //Call GET Product by it's code Api
      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body);
        }
      });
    }
  } else {
    err.message = err.description = 'Mandatory parameter classid or users ' +
        'array not found in request options';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

//options = {
//    classid: '', //Class Id
//    users: ['dls-userid1', 'dls-userid-2'] //Users Id
//};
function unEnrollMultiUserstoClass(options) {
  var self = this;
  var err = {};
  //Initializing promise
  var dfd = q.defer();
  if(options && options.classid && options.users) {
    //Validations
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err) {
      dfd.reject(err);
    } else {
      //Passed all validations, Construct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.enrollMultiUserstoClass;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        classId: options.classid
      });

      //Contruct parameters
      var params = {
        users: options.users
      };
      //Setup request with URL and Params
      var requestAPI = request.delete(url)
                              .set('Content-Type', 'application/json')
                              .set('Accept', 'application/json')
                              .send(params);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      //Call GET Product by it's code Api
      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body);
        }
      });
    }
  } else {
    err.message = err.description = 'Mandatory parameter classid or users ' +
        'array not found in request options';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

//options = {
//    classid: '', //Class Id
//    userid: '', //User Id
//};
function unEnrollUsertoClass(options) {
    var self = this;
	var err = {};
    //Initializing promise
    var dfd = q.defer();
	if(options && options.classid && options.userid) {
		//Validations
		err = helpers.validations.isAuthenticated(self.orgId, self.token);
		if(err) {
			dfd.reject(err);
		} else {
			//Passed all validations, Construct API url
			var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.enrollUsertoClass;
			url = helpers.api.constructAPIUrl(url, {
				orgId: self.orgId,
				classId: options.classid,
                userId: options.userid
			});

			//Contruct parameters
			var params = {};

      //Setup request with URL and Params
      var requestAPI = request.delete(url).query(params);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

			//Setup token in Authorization header
			requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

			//Call GET Product by it's code Api
			requestAPI.end(function(err, response) {
				if(err) {
					err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
					dfd.reject(err);
				} else {
					dfd.resolve(response.body);
				}
			});
		}
	} else {
		err.message = err.description = 'Mandatory parameter classid or userid not found in request options';
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}
    return dfd.promise;
}

//options = ['parameter1', 'parameter2']
function encodeURLParameter(options) {
  var response = {};
  for(var param in options) {
    response[options[param]] = encodeURIComponent(options[param]);
  }
  return response;
}

/**
 * options = {
 * title: 'class title',
 * startdate: 'Epoch(Unix) timestamp in milliseconds',
 * enddate: 'Epoch(Unix) timestamp in milliseconds',
 * description: '',                          // Optional field
 * class_ownership: 'STRICT' / 'NO_OWNER',   // Default - STRICT, Optional field
 * ext_data: {}                              // Optional
 * analyticsharingmodel: ''                  // Optional - Valid values: ['NOINHERIT_SYNCBACK']
 * }
 */
function createClass(options) {
    var self = this;

    //Initializing promise
    var dfd = q.defer();

    //Validations
    var err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err) {
        dfd.reject(err);
    } else {
        if(options && options.title && options.startdate && options.enddate) {
            //Passed all validations, Contruct API url
            var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.createClass;
            url = helpers.api.constructAPIUrl(url,  { orgId: self.orgId });

            //Contruct parameters
            var params = {
              title: options.title,
              startdate: options.startdate,
              enddate: options.enddate
            };

            if(options.description){ params.description = options.description; }
            if(options.class_ownership){ params.class_ownership = options.class_ownership; }
            if(options.ext_data){ params.ext_data = options.ext_data; }
            if(options.analyticsharingmodel){ params.analyticsharingmodel = options.analyticsharingmodel; }

            //Setup request with URL and Params
            var requestAPI = request.post(url).send(params);
            if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

            //Setup token in Authorization header
            requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

            requestAPI.end(function(err, response) {
                if(err) {
                    err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
                    dfd.reject(err);
                } else {
                  var res = converter.convertClassResponse({data: response.body}) ;
                  dfd.resolve(res);
                }
            });
        } else {
            err = {};
            err.message = err.description = 'title or startdate or enddate not found in request options.';
            err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
            dfd.reject(err);
        }
    }
    return dfd.promise;
}

//options = {
//    classid: 'class id',
//    title: 'class title', //Optional field
//    startdate: 'Epoch(Unix) timestamp in milliseconds', //Optional field
//    enddate: 'Epoch(Unix) timestamp in milliseconds', //Optional field
//    description: '',    //Optional field
//    ext_data: ''        //Optional field
//}
function updateClass(options) {
    var self = this;

    //Initializing promise
    var dfd = q.defer();

    //Validations
    var err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err) {
        dfd.reject(err);
    } else {
        if(options && options.classid)
        {
            //Passed all validations, Contruct API url
            var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.specificClass;
            url = helpers.api.constructAPIUrl(url,  { orgId: self.orgId, classId: options.classid });

            //Setup request with URL and Params
            var requestAPI = request.put(url).send(options);
            if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

            //Setup token in Authorization header
            requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

            requestAPI.end(function(err, response) {
                if(err) {
                    err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
                    dfd.reject(err);
                } else {
                    dfd.resolve(response.body);
                }
            });
        } else {
            err = {};
            err.message = err.description = 'Mandatory parameter \'classid\' is not found in request options.';
            err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
            dfd.reject(err);
        }
    }
    return dfd.promise;
}

/** options =
 *{
  "space_title": "string",
  "classes": [
    {
      "title": "class tiltle",
      "startdate": 'Epoch(Unix) timestamp in milliseconds',
      "enddate": 'Epoch(Unix) timestamp in milliseconds',
      "rowId": 'string with max limit 3 characters,
      "description": "string",
      "ext_data": {},                    // optional
      "model": "STRICT",
      "analyticsharingmodel":"NOINHERIT_SYNCBACK"  // optional
      "owner": {
        "userid": "string" //Mandatory if model is 'STRICT'
      },
      "teachers": [
        {
          "userid": "string",
          "email": "string"
          "first_name": "string"
          "last_name": "string"
          "userid": "string"             // optional
          "ext_user_id": "string"        // optional
          "dls_org_status": "string"     // optional
          "ext_account_status": "string" // optional
      ],
      "products": [                      // optional
        {
          "productcode": "string",       //mandatory
          "title": ""
        },
        {
          "productcode": "string",       //mandatory
          "title": ""
        }
      ]
    }
  ],
  "clone_classes": [
    {
      "title": "string",
      "startdate": 0,
      "enddate": 0,
      "instructor": "string",
      "rowId": "string",
      "classid": "string",
      "clone_settings": {
        "students": true,
        "teachers": true,
        "products": true,
        "groups": true,
        "assigned_paths": true,
        "tags": true,
        "analyticsharingmodel": true,
        "ext_data": true,
        "advanced": {
          "students": [ { "ext_user_id": "string" } ],
          "teachers": [ { "ext_user_id": "string" } ],
          "groups": [ { "groupid": "string" } ],
          "assigned_paths": [
            {
              "assigned_path_id": "string",
              "startdate": 0,
              "duedate": 0
            }
          ],
          "products": [ { "productcode": "string" } ]
        }
      }
    }
  ]
}
 */
function createMultipleClasses(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();

  //Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if (err) { dfd.reject(err); }
  else {
    if ((options.classes && options.classes.length > 0) ||
      (options.clone_classes && options.clone_classes.length > 0)) {

      //Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.createMultipleClasses;
      url = helpers.api.constructAPIUrl(url, {
          orgId: self.orgId
      });

      //Setup request with URL and Params and Query
      var requestAPI = request.post(url).send(options);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (err, response) {
        if (err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory parameters - [classes, clone_classes], ' +
                                      'not found in request options';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*
options = {
  "classid": "classid", //mandatory
  "data": {
    "title": "assigned path title", //mandatory
    "duedate": "epoch due date", //mandatory
    "startdate": "epoch start date", //optional
    "shared_progress": true, //optional, default=true
    "path_type": ‘flat’, //optional, default=flat , ['flat', 'hierarchical']
    "rules": {}, //optional
    "items": [  //mandatory
      {
        "item-code": "required_item-code",  //mandatory
        "item_type": "required_item-type",  //mandatory, ['dls-internal','external']
        "dls_product_code": "product_code" //mandatory only if item_type is 'dls-internal'
      }
    ],
    "context": {
       "bundle-code": "string",
       "space_key": "string"
     }
  }
}
*/
function createAssignedPath(options) {
  var self = this;
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.classid && options.data && options.data.title &&
        options.data.duedate && options.data.items && options.data.items.length > 0) {

      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.createAssignedPath;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, classId: options.classid });

      // Setup request with URL and Params
      var requestAPI = request.post(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .send(options.data);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory params - title or classid or duedate or items ' +
                                      'not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*
  options = {
  classid: 'string' //mandatory
  assignedpathid: 'string' //mandatory
  }
*/
function deleteAssignedPath(options) {
  var self = this;
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.classid && options.assignedpathid) {

      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.deleteAssignedPath;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, classId: options.classid, assignedPathId: options.assignedpathid });

      // Setup request with URL and Params
      var requestAPI = request.delete(url);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory params - classid or assignedpathid ' +
                                      'not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*
  options = {
    classid: 'string' //mandatory
    assignedpathid: 'string' //mandatory
    data: 
      { 
        title: 'string' //optional
        startdate: 'string' //optional
        duedate: 'string' //optional
      }
  }
*/
function updateAssignedPath(options) {
  var self = this;
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.classid && options.assignedpathid) {

      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.deleteAssignedPath;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, classId: options.classid, assignedPathId: options.assignedpathid });

      // Setup request with URL and Params
      var requestAPI = request.put(url);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
		  if(options.data) { requestAPI.send(options.data); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory params - classid or assignedpathid ' +
                                      'not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/**
 * options={
  "title": "string", //mandatory
  "startdate": 0, //mandatory
  "enddate": 0, //mandatory
  "path": "string"
}
 */
function createGroup(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    // Validations

    if(options && options.title && options.startdate && options.enddate) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.allGroups;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      // Setup request with URL and Params
      var requestAPI = request.post(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .send(options);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'title or startdate or enddate not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/* options = {
    "path": "string" //mandatory, Path of the group(this path group will also be returned,
    "cursor": "string"
  };
*/
function getAllGroupsByPath(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.path) {

      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.allGroups;
      url = helpers.api.constructAPIUrl(url,{ orgId: self.orgId });

      var queryParams = { path: options.path };
      if(options.cursor) { queryParams.cursor = options.cursor; }

      // Setup request with URL and Params
      var requestAPI = request.get(url).query(queryParams);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory params - path not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/* options = {
    "groupId": "string" //mandatory
  };
*/
function getAGroup(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.groupId) {

      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.aParticularGroup;
      url = helpers.api.constructAPIUrl(url,{ orgId: self.orgId, groupId: options.groupId });

      // Setup request with URL and Params
      var requestAPI = request.get(url);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory params - groupId not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/* options = {
    "groupId": "string" //mandatory
    "body": {
      "title": "string"
      "startdate": "string",
      "enddate":"string"
    }
  };
*/
function updateGroup(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.groupId) {

      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.aParticularGroup;
      url = helpers.api.constructAPIUrl(url,{ orgId: self.orgId, groupId: options.groupId });

      // Setup request with URL and Params
      var requestAPI = request.put(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .send(options.body);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory params - groupId not found in ' +
                                      'request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/* options = {
    "groupId": "string" //mandatory
  };
*/
function deleteGroup(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.groupId) {

      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.aParticularGroup;
      url = helpers.api.constructAPIUrl(url,{ orgId: self.orgId, groupId: options.groupId });

      // Setup request with URL and Params
      var requestAPI = request.delete(url);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory params - groupId not found in ' +
                                      'request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*
  options = {
    groupId: "string", //mandatory
    cursor: "cursor"
  }
*/
function getAllMembersOfAGroup(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer(), params = {};
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  // Validations
  else{
    if(options && options.groupId) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.getAllMembersOfAGroup;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        groupId: options.groupId
      });
  
      // Setup request with URL and Param
      if(options.cursor){ params.cursor = options.cursor };
  
      var requestAPI = request.get(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .send(params);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
  
      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory param - groupId not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*
  options = {
    path: "string", //mandatory
    cursor: "string"
  }
*/
function getAllGroupMembersByPath(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer(), params = {};
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  // Validations
  else {
    if(options && options.path) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.getAllGroupMembersByPath;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId
      });
  
      // Setup request with URL and Params
      params.path = options.path;
      if(options.cursor){ params.cursor = options.cursor };
  
      var requestAPI = request.get(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .query(params);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
  
      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory param - path not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*
  options = {

    groupId: "string", //mandatory
    body: {
      users: [
        {
          id: "string", // User’s external id - mandatory
          dls_user_id: "string", // User’s dls id - mandatory
          email: "string", //mandatory
          first_name: "string", //mandatory
          last_name: "string", //mandatory
          name: "string", //mandatory
          role: "string" //mandatory
        }
      ]
    }
  }
*/
function createMultiUserGroupMembership(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer(), params = {};
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  // Validations

  else {
    if(options && options.groupId && options.body && options.body.users && (options.body.users.length > 0)) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.userGroupMembership;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, groupId: options.groupId });
  
      // Setup request with URL and Params
      params = options.body;
  
      var requestAPI = request.post(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .send(params);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
  
      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory param - groupId or body or body.users(min. 1 user) ' +
                                      'not found in request options.'
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*
  options = {
    "groupId": "string", //mandatory
    "body": {            //mandatory
      users: [           //mandatory
        {
          id: "string" // User’s external id - mandatory
        }
      ]
  }
*/
function deleteMultiUserGroupMembership(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer(), params = {};
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  // Validations
  else {
    if(options && options.groupId && options.body && options.body.users && (options.body.users.length > 0)) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.userGroupMembership;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        groupId: options.groupId
      });
  
      // Setup request with URL and Params
      params = options.body;
      var requestAPI = request.delete(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .send(params);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory param - groupId or body or body.users(min. 1 user) ' +
                                      'not found in request options.'
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/* options= {
   "groupId": "string", //mandatory
  };
*/
function archiveGroup(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if (options && options.groupId) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.archiveAParticularGroup;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        groupId: options.groupId
      });

      // Setup request with URL and Params
      var requestAPI = request.put(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .send({});
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (error, response) {
        if (error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body);
        }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory param - groupId not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/* options= {
   "groupId": "string", //mandatory
  };
*/
function unarchiveGroup(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if (options && options.groupId) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.unarchiveAParticularGroup;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        groupId: options.groupId
      });

      // Setup request with URL and Params
      var requestAPI = request.put(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .send({});
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (error, response) {
        if (error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body);
        }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory param - groupId not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*
  options = {
    userId: "string", //mandatory
    path: "string", //mandatory
    cursor: "string", // optional
  }
*/
function getMyAllMemberships(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer(), params = {};
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  // Validations
  else {
    if(options && options.userId && options.path) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.getMyAllMemberships;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        userId: options.userId
      });
  
      // Setup request with URL and Params
      params.path = options.path;
      if(options.cursor){ params.cursor = options.cursor };
  
      var requestAPI = request.get(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .query(params);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
  
      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory param - userId or path not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*
  options = {
    classId: "string", //mandatory
    body : {
      items :         //mandatory, Min: 1, Max: 200
      [{
        "productcode": "string",
        "item-code": "string",
        "link-statementid": "string",
        "groupid": "string",
        “type”: “dls-internal”, //mandatory
        "data": { ... }
       }]
    }
  }
*/
function addItemsToShowcaseOfAClass(options){
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  // Validations
  else {
    if(options && options.classId && options.body) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.showcaseItems;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, classId: options.classId });

      // Setup request with URL and Params
      var requestAPI = request.post(url);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
      requestAPI.send(options.body);

      // Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // Call Add items to showcase API
      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory param - classId or body not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*
  options = {
    classId: "string", //mandatory
    body : {
      items : [ "id1", "id2", "id3", ... ] //mandatory
    }
  }
*/
function deleteItemsFromShowcaseOfAClass(options){
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  // Validations
  else {
    if(options && options.classId && options.body) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
                self.config.AUTH_API_URLS.showcaseItems;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, classId: options.classId });

      // Setup request with URL and Params
      var requestAPI = request.delete(url);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
      requestAPI.send(options.body);

      // Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      // Call delete items from showcase API
      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory param - classId or body not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/**
 * options = {
 * classid: 'class id of the class',
 * title: 'title of clone class',
 * startdate: 'Epoch(Unix) timestamp in milliseconds',
 * enddate: 'Epoch(Unix) timestamp in milliseconds',
 * instructor: 'user who clones the class',
 * clone_setting: {},                          // Optional field
 * }
 */
function cloneClass(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();

  //Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) {
    dfd.reject(err);
  } else {
    if(options && options.title && options.startdate && options.enddate
      && options.instructor && options.classid) {
      //Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.cloneClass;
      url = helpers.api.constructAPIUrl(url,  { orgId: self.orgId, classId: options.classid });

      //Setup request with URL and Params
      var requestAPI = request.post(url).send(options);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function(err, response) {
        if(err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body);
        }
      });
    } else {
      err = {};
      err.message = err.description = 'title or startdate or enddate or instructor or classid not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

},{"../../helpers":3,"../../helpers/lib/api/converter":4,"agentkeepalive":37,"q":90,"superagent":133}],17:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/
/***********************************************************
 * comproDLS SDK Collab API Adaptor
 * Functions for calling Collab API.
 ************************************************************/
var request = require('superagent');
var q = require('q');

var helpers = require('../../helpers');
var DLSError = helpers.errors.DLSError;

/*********************************
 * Setting Up Module Entry Point  
 **********************************/
module.exports = collab;

function collab() {
    return {
        "getPostsInClass": getPostsInClass.bind(this),
        "createPostInClass": createPostInClass.bind(this),
        "getPostsInProduct": getPostsInProduct.bind(this),
        "createPostInProduct": createPostInProduct.bind(this),
        "getMyFollowers": getMyFollowers.bind(this),
        "getUsersFollowedByMe": getUsersFollowedByMe.bind(this),
        "followUser": followUser.bind(this),
        "unfollowUser": unfollowUser.bind(this)
    }
};

/*********************************
 * Public Function definitions
 **********************************/

//options = {
//    classid: "class uuid",
//    cursor: "string",     //(optional) cursor to get next set of activities.
//    limit: integer        //(optional) number of activities to be returned (default 10).
//}
function getPostsInClass(options) {
    var self = this;
    //Initializing promise
    var dfd = q.defer();
    var err = {};
    //Validations
    if(options && options.classid) {
        err = helpers.validations.isAuthenticated(self.orgId, self.token);
        if(err) {
            dfd.reject(err);
        } else {
            //Passed all validations, Construct API url
            var url = self.config.DEFAULT_HOSTS['COLLAB'] + self.config.COLLAB_API_URLS.postsInClassAPI;
            url = helpers.api.constructAPIUrl(url, {
                "orgId": self.orgId,
                "classId": options.classid
            });

            //Contruct parameters
            var params = {};
            if(options.cursor) {
                params.cursor = options.cursor;
            }
            if(options.limit) {
                params.limit = options.limit;
            }

            //Setup request with URL and Params
            var requestAPI = request.get(url).query(params);
            if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

            //Setup token in Authorization header
            requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

            //Call GET CLASS ALL POSTS Api
            requestAPI.end(function(error, response){
                if(error) {
                    err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
                    dfd.reject(err);
                } else {
                    dfd.resolve(response.body);
                }
            });
        }
    } else {
        err.message = err.description = 'Mandatory parameter "classid" not found in request options';
        err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
        dfd.reject(err);
    }
    return dfd.promise;
}

//options = {
//    classid: "class uuid",
//    verb: "verb",
//    post: "post",         // (optional)
//    name: "name",         // (optional)
//    email: "email",       // (optional)
//    userid: "userid"      // (optional)
//}
function createPostInClass(options) {
    var self = this;
    //Initializing promise
    var dfd = q.defer();
    var err = {};
    //Validations
    if(options && options.verb && options.classid) {
        err = helpers.validations.isAuthenticated(self.orgId, self.token);
        if(err) {
            dfd.reject(err);
        } else {
            //Passed all validations, Construct API url
            var url = self.config.DEFAULT_HOSTS['COLLAB'] + self.config.COLLAB_API_URLS.postsInClassAPI;
            url = helpers.api.constructAPIUrl(url, {
                "orgId": self.orgId,
                "classId": options.classid
            });
            //Construct parameters
            var params = {
                verb: options.verb
            };
            if(options.post) {
                params.post = options.post;
            }
            if(options.name) {
                params.name = options.name;
            }
            if(options.email) {
                params.email = options.email;
            }
            if(options.userid) {
                params.userid = options.userid;
            }
            //Setup request with url and params
            var requestAPI = request.post(url).send(params);
            if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

            //Setup token in Authorization Header
            requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
            //Call POST 'POST in CLASS'
            requestAPI.end(function(error, response) {
                if(error) {
                    err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
                    dfd.reject(err);
                } else {
                    dfd.resolve(response.body);
                }
            })
        }
    } else {
        err.message = err.description = 'Mandatory parameter "verb" or "classid" not found in request options';
        err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
        dfd.reject(err);
    }
    return dfd.promise;
}

//options = {
//    productid: "product uuid",
//    cursor: "string",           //(optional) cursor to get next set of activities
//    limit: integer              //(optional) number of activities to be returned(default 10)
//}
function getPostsInProduct(options) {
    var self = this;
    //Initializing promise
    var dfd = q.defer();
    var err = {};
    //Validations
    if(options && options.productid) {
        err = helpers.validations.isAuthenticated(self.orgId, self.token);
        if(err) {
            dfd.reject(err);
        } else {
            //Passed all validations, Construct API url
            var url = self.config.DEFAULT_HOSTS['COLLAB'] + self.config.COLLAB_API_URLS.postsInProductAPI;
            url = helpers.api.constructAPIUrl(url, {
                "orgId": self.orgId,
                "productId": options.productid
            });
            //Contruct parameters
            var params = {};
            if(options.cursor) {
                params.cursor = options.cursor;
            }
            if(options.limit) {
                params.limit = options.limit;
            }
            //Setup request with URL and Params
            var requestAPI = request.get(url).query(params);
            if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

            //Setup token in Authorization header
            requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
            //Call GET CLASS ALL POSTS Api
            requestAPI.end(function(error, response) {
                if(error) {
                    err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
                    dfd.reject(err);
                } else {
                    dfd.resolve(response.body);
                }
            });
        }
    } else {
        err.message = err.description = 'Mandatory parameter "productid" not found in request options';
        err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
        dfd.reject(err);
    }
    return dfd.promise;
}

//options = {
//    productid: "product uuid",
//    verb: "string",       // Possible value is 'post'
//    post: "post",         // (optional)
//    name: "name",         // (optional)
//    email: "email",       // (optional)
//    userid: "userid"      // (optional)
//}
function createPostInProduct(options) {
    var self = this;
    //Initializing promise
    var dfd = q.defer();
    var err = {};
    if(options && options.verb && options.productid) {
        //Validations
        err = helpers.validations.isAuthenticated(self.orgId, self.token);
        if(err) {
            dfd.reject(err);
        } else {
            //Passed all validations, Construct API url
            var url = self.config.DEFAULT_HOSTS['COLLAB'] + self.config.COLLAB_API_URLS.postsInProductAPI;
            url = helpers.api.constructAPIUrl(url, {
                "orgId": self.orgId,
                "productId": options.productid
            });
            //Contruct params
            var params = {
                verb: options.verb
            };
            if(options.post) {
                params.post = options.post;
            }
            if(options.name) {
                params.name = options.name;
            }
            if(options.email) {
                params.email = options.email;
            }
            if(options.userid) {
                params.userid = options.userid;
            }
            //Setup request with url and params
            var requestAPI = request.post(url).send(params);
            if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

            //Setup token in Authorization Header
            requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
            //Call POST 'POST in PRODUCT'
            requestAPI.end(function(error, response) {
                if(error) {
                    err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
                    dfd.reject(err);
                } else {
                    dfd.resolve(response.body);
                }
            })
        }
    } else {
        err.message = err.description = 'Mandatory parameter "verb" or "productid" not found in request options';
        err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
        dfd.reject(err);
    }
    return dfd.promise;
}

/*options = {
 *  cursor: 'string'            // (optional) cursor string to fetch next set of followers
 *  limit: number               // (optional) limits the number of followers to fetch at at time
 *}
 */
function getMyFollowers(options) {
    var self = this;

    //Initializing Promise
    var dfd = q.defer();
    var err = {};

    //Validations
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err) {
        dfd.reject(err);
    } else {
        //Passed all Validations, constructing url
        var url = self.config.DEFAULT_HOSTS['COLLAB'] + self.config.COLLAB_API_URLS.getMyFollowers;

        url = helpers.api.constructAPIUrl(url, {
            orgId: self.orgId
        })
        //Attaching Query Params
        var queryParams = {};

        if(options.cursor) { queryParams.cursor = options.cursor; }
        if(options.limit) { queryParams.limit = options.limit; }

        //Setup request with url and params
        var requestAPI = request.get(url).query(queryParams);
        if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

        //Setup token in Authorization Header
        requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
        //Call GET 'getFollower'
        requestAPI.end(function(error, response) {
           if(error) {
                err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
                dfd.reject(err);
            } else {
                dfd.resolve(response.body);
            }
        });
    }

    return dfd.promise;
}

/*options = {
 *  cursor: 'string'            // (optional) cursor string to fetch next set of following users
 *  limit: number               // (optional) limits the number of following users, to fetch at at time
 *}
 */
function getUsersFollowedByMe(options) {
    var self = this;

    //Initializing Promise
    var dfd = q.defer();
    var err = {};

    //Validations
    err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err) {
        dfd.reject(err);
    } else {
        //Passed all Validations, constructing url
        var url = self.config.DEFAULT_HOSTS['COLLAB'] + self.config.COLLAB_API_URLS.getUsersFollowedByMe;

        url = helpers.api.constructAPIUrl(url, {
            orgId: self.orgId
        })
        //Attaching Query Params
        var queryParams = {};

        if(options.cursor) { queryParams.cursor = options.cursor; }
        if(options.limit) { queryParams.limit = options.limit; }

        //Setup request with url and params
        var requestAPI = request.get(url).query(queryParams);
        if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

        //Setup token in Authorization Header
        requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
        //Call GET 'getFollower'
        requestAPI.end(function(error, response) {
           if(error) {
                err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
                dfd.reject(err);
            } else {
                dfd.resolve(response.body);
            }
        });
    }

    return dfd.promise;
}

/*options = {
 *  userid: 'string'                // user uuid
 *}
 */
function followUser(options) {
    //Initializing Promise
    var dfd = q.defer();

    //calling function to 'create' connection (follow user)
    updateConnectionForUser(this.orgId, this.token, this.config, options, 'create')
    .then(function(response) { dfd.resolve(response); })
    .catch(function(error) { dfd.reject(error); })
    .done();

    return dfd.promise;
}

/*options = {
 *  userid: 'string'                // user uuid
 *}
 */
function unfollowUser(options) {
    //Initializing Promise
    var dfd = q.defer();

    //calling function to 'delete' connection (unfollow user)
    updateConnectionForUser(this.orgId, this.token, this.config, options, 'delete')
    .then(function(response) { dfd.resolve(response); })
    .catch(function(error) { dfd.reject(error); })
    .done();

    return dfd.promise;
}

function updateConnectionForUser(orgid, token, config, options, action) {
    //Initializing Promise
    var dfd = q.defer();
    var err = {};

    //Validations
    if(options && options.userid) {
        //Validating Auth Token
        err = helpers.validations.isAuthenticated(orgid, token);
        if(err) {
            dfd.reject(err);
        } else {
            //Passed all Validations, constructing url
            var url = config.DEFAULT_HOSTS['COLLAB'] + config.COLLAB_API_URLS.connectionURL;
            url = helpers.api.constructAPIUrl(url, {
                orgId: orgid,
                userId: options.userid
            });
            var requestAPI;
            //Setup request with url and params
            if(action === 'create') {
                requestAPI = request.post(url).set('Content-Type', 'application/json');
            } else if(action === 'delete') {
                requestAPI = request.delete(url).set('Content-Type', 'application/json');
            }
            //Setup token in Authorization Header
            requestAPI = helpers.api.setupAPIToken(requestAPI, token);
            //Call POST/DELETE 'updateConnectionForUser'
            requestAPI.end(function(error, response) {
                if(error) {
                    err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
                    dfd.reject(err);
                } else {
                    dfd.resolve(response.body);
                }
            });
        }
    } else {
        err.message = err.description = 'Mandatory parameter "userid" not found in request options';
        err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
        dfd.reject(err);
    }
    return dfd.promise;
}

},{"../../helpers":3,"q":90,"superagent":133}],18:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

/***********************************************************
 * comproDLS SDK drive Adaptor
 * Functions for calling Drive-service API.
 ************************************************************/

/*********************************
 * Setting Up Module Entry Point
 **********************************/

var q = require('q');
var request = require('superagent');

var helpers = require('../../helpers');
var DLSError = helpers.errors.DLSError;

module.exports = documents;

/*********************************
 * Public Function definitions
 **********************************/
function documents() {
  return {
    getAParticularDocument: getAParticularDocument.bind(this),
    getAllDocumentsInAFolder: getAllDocumentsInAFolder.bind(this)
  };
}

/*
  options = {
    accountid : 'string', //mandatory
    extuserid : 'string', //mandatory
    documentid : 'string', //mandatory
    folderid: 'string',  //mandatory
  }
*/
function getAParticularDocument(options) {
  var self = this;
  var dfd = q.defer();

  if (options && options.accountid && options.extuserid && options.documentid && options.folderid) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.DRIVE + self.config.DRIVE_API_URLS.getAParticularDocument;
    var urlOptions = {
      accountid: options.accountid, extuserid: options.extuserid,
      documentid: options.documentid
    };
    url = helpers.api.constructAPIUrl(url, urlOptions);

    var params = { folderid: options.folderid };
    //Setup request with URL and Params
    var requestAPI = request.get(url).query(params);

    if (self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if (err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    var error = {};
    error.message = error.description = 'Mandatory params - accountid or extuserid or ' +
      'documentid or folderid not found in request options.';
    error = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, error);
    dfd.reject(error);
  }
  return dfd.promise;
}

/*
  options = {
    accountid: 'string', //mandatory
    extuserid: 'string', //mandatory
    folderid: 'string',  //mandatory
    classid: 'string',
    productcode: 'string',
    assigned_path_id: 'string',
    item-code: 'string',
    cursor: 'string'
  }
*/
function getAllDocumentsInAFolder(options) {
  var self = this;
  var dfd = q.defer();

  if (options && options.accountid && options.extuserid && options.folderid) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.DRIVE + self.config.DRIVE_API_URLS.getAllDocumentsInAFolder;
    url = helpers.api.constructAPIUrl(url,
      { accountid: options.accountid, extuserid: options.extuserid });

    // Contruct parameters
    var params = { folderid: options.folderid };
    if (options.classid) { params.classid = options.classid; }
    if (options.productcode) { params.productcode = options.productcode; }
    if (options.assigned_path_id) { params.assigned_path_id = options.assigned_path_id; }
    if (options['item-code']) { params['item-code'] = options['item-code']; }
    if (options.cursor) { params.cursor = options.cursor; }

    //Setup request with URL and Params
    var requestAPI = request.get(url).query(params);

    if (self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if (err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    var error = {};
    error.message = error.description = 'Mandatory params - accountid or extuserid or folderid ' +
      'not found in request options.';
    error = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, error);
    dfd.reject(error);
  }
  return dfd.promise;
}

},{"../../helpers":3,"q":90,"superagent":133}],19:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

/***********************************************************
 * comproDLS SDK AUTH API Adaptor
 * Functions for calling AUTH API.
 ************************************************************/

var q = require('q');
var request = require('superagent');

var helpers = require('../../helpers');
var converter = require('../../helpers/lib/api/converter');

var DLSError = helpers.errors.DLSError;

/*********************************
 * Setting Up Module Entry Point
 **********************************/
module.exports = integrations;

//Integrations Adaptor Constructor
function integrations(accountId) {
    this.accountId = accountId;
  return {
      getGetStreamCredentials: getGetStreamCredentials.bind(this),
      queryDataFromSearch: queryDataFromSearch.bind(this),
      getAuditTrailForAttempts: getAuditTrailForAttempts.bind(this),
      getAuditTrailForEntitlements: getAuditTrailForEntitlements.bind(this),
      getAuditTrailForMicroEntitlements: getAuditTrailForMicroEntitlements.bind(this),
      publishCustomEvents: publishCustomEvents.bind(this),
      createSchedule: createSchedule.bind(this),
      getSchedule: getSchedule.bind(this),
      updateSchedule: updateSchedule.bind(this)
  };
}

//params: NONE
function getGetStreamCredentials() {
  var self = this;
  var dfd = q.defer(), err;

  var url = self.config.DEFAULT_HOSTS.INTEGRATION +
            self.config.INTEGRATIONS_API_URLS.getGetStreamCredentials;
  url = helpers.api.constructAPIUrl(url, { accountId: self.accountId });

  // Setup request with URL and Params
  var requestAPI = request.post(url)
  .set('Content-Type', 'application/json')
  .set('Accept', 'application/json')
  .send();
  if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

  requestAPI.end(function (error, response) {
    if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
    }
    else {  dfd.resolve(response); }
  });
  return dfd.promise;
}

/*
  options = {
  index: 'string', //mandatory
  query: 'string' //mandatory
  }
*/
function queryDataFromSearch(options) {
  var self = this;
  var dfd = q.defer();
  var err;

  if(options && options.index && options.query) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.INTEGRATION +
            self.config.INTEGRATIONS_API_URLS.queryDataFromSearch;
    url = helpers.api.constructAPIUrl(url, { index: options.index });

    // Contruct parameters
    var params = {
      query: options.query
    };

    //Setup request with URL and Params
    var requestAPI = request.get(url).query(params);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if (err) {
        var esErrOptions = { type: helpers.errors.ERROR_TYPES.API_ERROR, err: err };
        var error = converter.convertElasticsearchErrResponse(esErrOptions);
        dfd.reject(error);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Mandatory params - index, type or query ' +
      'not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/*
options = {
  accountid: 'string',
  action: 'string',
  userid: 'string',
  productcode: 'string',
  item-code: 'string',
  sortOrder: 'asc/desc', // optional
  cursor: 'string'
}
*/
function getAuditTrailForAttempts(options) {
  var self = this;
  var dfd = q.defer();
  var err;

  if (options && options.accountid && options.action &&
    options.userid && options.productcode && options['item-code']) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.INTEGRATION +
      self.config.INTEGRATIONS_API_URLS.auditTrail;
    url = helpers.api.constructAPIUrl(url, { accountId: options.accountid });

    // Contruct parameters
    var params = {
      audit_context: 'ATTEMPT-' + options.accountid + '#' + options.userid,
      target_context: 'PRODUCT-' + options.productcode + '#' + options['item-code'],
      action: options.action
    };
    if(options.cursor) { params.cursor = options.cursor; }
    if(options.sortOrder) { params.sortOrder = options.sortOrder; }

    //Setup request with URL and Params
    var requestAPI = request.get(url).query(params);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if(err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Mandatory params - accountid, action,  userid, ' +
      'productcode or item-code not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/*
options = {
  accountid: 'string',
  action: 'string',
  userid: 'string',
  productcode: 'string',
  sortOrder: 'asc/desc', // optional
  cursor: 'string'
}
*/
function getAuditTrailForEntitlements(options) {
  var self = this;
  var dfd = q.defer();
  var err;

  if(options && options.accountid && options.action &&
    options.userid && options.productcode) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.INTEGRATION +
      self.config.INTEGRATIONS_API_URLS.auditTrail;
    url = helpers.api.constructAPIUrl(url, { accountId: options.accountid });

    // Contruct parameters
    var params = {
      audit_context: 'ENTITLEMENT-' + options.accountid + '#' + options.userid,
      target_context: 'PRODUCT-' + options.productcode,
      type: 'entitlement',
      action: options.action
    };
    if(options.cursor) { params.cursor = options.cursor; }
    if(options.sortOrder) { params.sortOrder = options.sortOrder; }

    //Setup request with URL and Params
    var requestAPI = request.get(url).query(params);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if(err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Mandatory params - accountid, userid or productcode ' +
      'not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/*
options = {
  accountid: 'string',
  action: 'string',
  userid: 'string',
  productcode: 'string',
  sortOrder: 'asc/desc', // optional
  context: 'string',
  cursor: 'string'
}
*/
function getAuditTrailForMicroEntitlements(options) {
  var self = this;
  var dfd = q.defer();
  var err;

  if(options && options.accountid && options.action &&
    options.userid && options.productcode && options.context) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.INTEGRATION +
      self.config.INTEGRATIONS_API_URLS.auditTrail;
    url = helpers.api.constructAPIUrl(url, { accountId: options.accountid });

    // Contruct parameters
    var params = {
      audit_context: 'ENTITLEMENT-' + options.accountid + '#' + options.userid,
      target_context: 'PRODUCT-' + options.productcode + '#' + options.context,
      type: 'micro-entitlement',
      action: options.action
    };
    if(options.cursor) { params.cursor = options.cursor; }
    if(options.sortOrder) { params.sortOrder = options.sortOrder; }

    //Setup request with URL and Params
    var requestAPI = request.get(url).query(params);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if(err){
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Mandatory params - accountid, action, userid, productcode ' +
      'or context not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/**
 * Publish custom events and send push notifications
 * @param {
 *   *events: [{
 *     *ext_actor_id: 'string',
 *     *category: "string",
 *     *action: 'string',
 *     *data: {...},
 *     push: <boolean, default: false
 *     ref_id: 'string'
 *   }, ...]
 * } options
 */
function publishCustomEvents(options) {
  var deferred = q.defer();
  var self = this, err;

  if (options && options.events) {
    // Construct API url
    var url = self.config.DEFAULT_HOSTS.INTEGRATION + self.config.INTEGRATIONS_API_URLS.customEvents;
    url = helpers.api.constructAPIUrl(url, { accountId: self.accountId });

    // Setup request with URL and Params
    var requestAPI = request.post(url)
                            .set('Content-Type', 'application/json')
                            .set('Accept', 'application/json')
                            .send(options);

    if (self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (error, response) {
      if (error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        deferred.reject(err);
      } else {
        deferred.resolve(response.body);
      }
    });
  } else {
    err = {};
    err.message = err.description = 'Mandatory params - events not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    deferred.reject(err);
  }

  return deferred.promise;
}

/*
  options = {
    accountid: "string", //mandatory
    context: "string", //mandatory
    body: {
        "scheduleid": "",  //mandatory
        "orgid": "",  // optional
        "actorid": "",  //mandatory
        "classid": "",  // optional
        "assigned_path_id": "",  // optional
        "productcode": "",  // optional
        "userid": "", // optional
        "category": "", //mandatory
        "data": {}, // optional
        "schedule_time" : ""  //mandatory
    }
  }
*/
function createSchedule(options) {
  var deferred = q.defer();
  // Initializing promise
  var self = this, err;

  if (options && options.context && options.accountid && options.body && (Object.keys(options.body).length > 0) &&
  options.body.scheduleid && options.body.actorid && options.body.category && options.body.schedule_time) {
    // Construct API url
    var url = self.config.DEFAULT_HOSTS.INTEGRATION + self.config.INTEGRATIONS_API_URLS.schedules;
    url = helpers.api.constructAPIUrl(url, { accountId: options.accountid, context: options.context });

    // Setup request with URL and Params
    var requestAPI = request.post(url)
                            .set('Content-Type', 'application/json')
                            .set('Accept', 'application/json')
                            .send(options.body);

    if (self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (error, response) {
      if (error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        deferred.reject(err);
      } else {
        deferred.resolve(response.body);
      }
    });
  } else {
    err = {};
    err.message = err.description = 'Mandatory param - accountid or context or body(scheduleid or actorid or '+
                                    'category or schedule_time) not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    deferred.reject(err);
  }

  return deferred.promise;
}

/*
  options = {
    accountid: "string", //mandatory
    context: "string", //mandatory
    category: "string", //optional
    scheduleid: "string", //optional
    cursor: "string"  //optional
  }
*/
function getSchedule(options) {
  var deferred = q.defer();
  // Initializing promise
  var self = this, err;

  if (options && options.context && options.accountid) {
    // Construct API url
    var url = self.config.DEFAULT_HOSTS.INTEGRATION + self.config.INTEGRATIONS_API_URLS.schedules;
    url = helpers.api.constructAPIUrl(url, { accountId: options.accountid, context: options.context });

    var params = {};
    if(options.cursor) { params.cursor = options.cursor; }
    if(options.category) { params.category = options.category; }
    if(options.scheduleid) { params.scheduleid = options.scheduleid; }

    //Setup request with URL and Params
    var requestAPI = request.get(url).query(params);
    if (self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (error, response) {
      if (error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        deferred.reject(err);
      } else {
        deferred.resolve(response.body);
      }
    });
  } else {
    err = {};
    err.message = err.description = 'Mandatory params - accountid or context not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    deferred.reject(err);
  }

  return deferred.promise;
}


/*
  options = {
    accountid: "string", //mandatory
    context: "string", //mandatory
    scheduleid: "string", //mandatory
    body: {
        "schedule_time" : "",  // optional
        "category": "", //mandatory
        "orgid": "",  // optional
        "actorid": "",  //mandatory
        "userid": "", // optional
        "classid": "",  // optional
        "assigned_path_id": "",  // optional
        "productcode": "",  // optional
        "data": {} // optional
    }
  }
*/
function updateSchedule(options) {
  var deferred = q.defer();
  // Initializing promise
  var self = this, err;

  if (options && options.context && options.accountid && options.scheduleid && options.body &&
     (Object.keys(options.body).length > 0) && options.body.actorid && options.body.category) {
    // Construct API url
    var url = self.config.DEFAULT_HOSTS.INTEGRATION + self.config.INTEGRATIONS_API_URLS.updateSchedule;
    url = helpers.api.constructAPIUrl(url, { accountId: options.accountid, context: options.context, scheduleId: options.scheduleid });

    // Setup request with URL and Params
    var requestAPI = request.put(url)
                            .set('Content-Type', 'application/json')
                            .set('Accept', 'application/json')
                            .send(options.body);

    if (self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (error, response) {
      if (error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        deferred.reject(err);
      } else {
        deferred.resolve(response.body);
      }
    });
  } else {
    err = {};
    err.message = err.description = 'Mandatory param - accountid or context or scheduleid or ' + 
                                    'body(category or actorid) not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    deferred.reject(err);
  }

  return deferred.promise;
}
},{"../../helpers":3,"../../helpers/lib/api/converter":4,"q":90,"superagent":133}],20:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

/***********************************************************
 * comproDLS SDK AUTH API Adaptor
 * Functions for calling AUTH API.
 ************************************************************/

var q = require('q');
var request = require('superagent');

var helpers = require('../../helpers');

var DLSError = helpers.errors.DLSError;

/*********************************
 * Setting Up Module Entry Point
 **********************************/
module.exports = invitations;

//Invitations Adaptor Constructor
function invitations() {

  return {
    sendInvitations: sendInvitations.bind(this),
    getMultiInvitations: getMultiInvitations.bind(this),
    revokeSingleInvitation: revokeSingleInvitation.bind(this),
    completeSingleInvitation: completeSingleInvitation.bind(this),
    resendSingleInvitation: resendSingleInvitation.bind(this)
  };
}

/*options = {
    context: 'string',  // required
    created: 'string',  // required
    space_title: 'string',
    class_enrollment: {
      classid: 'string',       // required. Correlated with context
      class_role: 'string',    // optional
      inviter_email: 'string'  // optional
    },
    invitation_data: [
      {
        class_enrollment  : {       // optional, will override the outer context
          classid: 'string'         // required. Correlated with context
          class_role: 'string',     // optional
          inviter_email: 'string'   // optional
        },
        email: 'string',   // required
        dls_account_status: 'string',
        ext_account_status: 'string',
        userid: 'string',
        ext_user_id: 'string',
        first_name: 'string',  // required
        last_name: 'string',   // required
        ext_data: {},
        rowId: 'string',       // required
        role: 'string'        /// required
      },...
    ]
  }*/
function sendInvitations(options) {
  var self = this;
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if (options && options.context && options.created && options['invitation_data']) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.sendInvitations;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });
      // Setup request with URL and Params
      var requestAPI = request.post(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .send(options);

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      requestAPI.end(function (error, response) {
        if (error) {
          err = {};
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else {
          dfd.resolve(response.body);
        }
      });
    }
    else {
      err = {};
      err.message = err.description = 'One or more required field(s) missing: context, created or '+
      'invitation_data';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/* options = {
   "context_id": "string", // required
    "context" : "string", //context for invitation e.g. class_enrollment -required
    "status" : "string", // ['pending','complete','revoke'] -required
    "cursor" : "string", // optional
  };
*/
function getMultiInvitations(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if (options && options.context_id) {

      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.getMultiInvitations;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      var queryParam = { context_id: options.context_id };
      if (options.context) { queryParam.context =  options.context; }
      if (options.status) { queryParam.status = options.status; }
      if (options.cursor) { queryParam.cursor = options.cursor; }

      // Setup request with URL and Params
      var requestAPI = request.get(url).query(queryParam);

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      requestAPI.end(function (error, response) {
        if (error) {
          err = {};
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else {
          dfd.resolve(response.body);
        }
      });
    }
    else {
      err = {};
      err.message = err.description = 'context_id not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/* options = {
    "context_id": "string", //class id to be to be revoked invitation -required
    "invitationid" : "string", //unique invitation id which is to be fetched -required
    "context" : "string", //context for revoking invitation e.g. class_enrollment -required
  };
*/
function revokeSingleInvitation(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if (options && options.context_id && options.invitationid && options.context) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.revokeSingleInvitation;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, invitationid: options.invitationid });

      var queryParam = { context: options.context, context_id: options.context_id };

      // Setup request with URL and Params
      var requestAPI = request.delete(url).query(queryParam);

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      requestAPI.end(function (error, response) {
        if (error) {
          err = {};
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else {
          dfd.resolve(response.body);
        }
      });
    }
    else {
      err = {};
      err.message = err.description = 'context_id or context or invitationid not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/* options= {
   "context_id": "string", //class id tocomplete an invitation -required
    "invitationid" : "string", //unique invitation id which is to be fetched -required
    "context" : "string", //context of the invitation to be completed e.g. class_enrollment -required
  };
*/
function completeSingleInvitation(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if (options && options.context_id && options.invitationid && options.context) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.completeSingleInvitation;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, invitationid: options.invitationid });

      var queryParam = { context: options.context, context_id: options.context_id };
      // Setup request with URL and Params
      var requestAPI = request.put(url).query(queryParam)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .send({});

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      requestAPI.end(function (error, response) {
        if (error) {
          err = {};
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else {
          dfd.resolve(response.body);
        }
      });
    }
    else {
      err = {};
      err.message = err.description = 'context_id or context or invitationid not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/* options =  {
    "context_id": "string", //class id to be resent invition -required
    "invitationid" : "string", //unique invitation id which is to be fetched -required
    "context" : "string", //context for the invitation to be resent e.g. class_enrollment -required
    "space_title" : "string" //optional
  };
*/
function resendSingleInvitation(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if (options && options.invitationid && options.context && options.context_id) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.resendSingleInvitation;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId, invitationid: options.invitationid });
      var queryParam = { context: options.context, context_id: options.context_id };
      var body = {};
      if(options.space_title) { body.space_title = options.space_title; }

      // Setup request with URL and Params
      var requestAPI = request.put(url).query(queryParam)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .send(body);

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      requestAPI.end(function (error, response) {
        if (error) {
          err = {};
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'context_id or context or invitationid not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

},{"../../helpers":3,"q":90,"superagent":133}],21:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/
/***********************************************************
 * comproDLS SDK Product API Adaptor
 * Functions for calling Product API.
 ************************************************************/
var TinCan = require('tincanjs');
var q = require('q');

var helpers = require('../../helpers');
var DLSError = helpers.errors.DLSError;

/*********************************
 * Setting Up Module Entry Point
 **********************************/
module.exports = lrs;

function lrs() {
    var error = {};
    //Initializing promise
    try {
        this.lrs = new TinCan.LRS({
            endpoint: this.config.DEFAULT_HOSTS.XAPI + '/' + this.orgId + '/tapi',
            auth: this.token.access_token,
            allowFail: false
        });

        this.tincan = new TinCan({
            recordStores: [this.lrs]
        });
    } catch (err) {
        err.description = 'Error while initializing lrs.';
        err.message = err.description;
        error = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
        return err;
    }
    return {
        "getStatement": getStatement.bind(this),
        "createStatement": createStatement.bind(this)
        /*"setState": setState.bind(this),
        "getState": getState.bind(this),
        "deleteState": deleteState.bind(this)*/
    };
}

/*********************************
 * Public Function definitions
 **********************************/

//options = {
//	verb: {object} - (Optional) Verb / Action performed by the acting person.
//  actor: {object} - (Optional) The acting person.
//	since: {String} - (Optional) <ISO-8601> date time,
//	until: {String} - (Optional) <ISO-8601> date time,
//  limit: {Number} - (Optional) limit of documents per function call
//  registration: {String} - (Optional) product to which the actor is entitled.
//  moreUrl: {String} - (Optional) Endpoint to get the next set of statements.
//}
function getStatement(options) {
    var self = this;

    //Initializing promise
    var dfd = q.defer(), params = {}, bMoreUrl = false;
    /*var supportedVerbs = ['attempted', 'scored', 'started', 'launched',
                        'answered', 'closed', 'terminated'];*/
    if(options) {
        params = {
            limit: options.limit || 10,
            since: options.since || null,
            until: options.until || null
        };
        if(options.actor) { params.agent = new TinCan.Agent(options.actor); }
        if(options.verb) { params.verb = new TinCan.Verb(options.verb); }
        if(options.moreUrl) { bMoreUrl = true; }
        if(options.registration) { params.registration = options.registration; }
    }

    if(bMoreUrl) {
        self.lrs.moreStatements({
            url: options.moreUrl,
            callback: function (err, sr) {
                if (err !== null) {
                    var error = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
                    dfd.reject(error);
                } else {
                    var statementsArray = [];
                    for(var i in sr.statements) {
                        statementsArray.push(JSON.parse(sr.statements[i].originalJSON));
                    }
                    sr.statements = statementsArray;
                    dfd.resolve(sr);
                }
            }
        });
    } else {
        self.lrs.queryStatements({
            params: params,
            callback: function (err, sr) {
                if (err !== null) {
                    var error = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
                    dfd.reject(error);
                } else {
                    var statementsArray = [];
                    for(var i in sr.statements) {
                        statementsArray.push(JSON.parse(sr.statements[i].originalJSON));
                    }
                    sr.statements = statementsArray;
                    dfd.resolve(sr);
                }
            }
        });
    }

    return dfd.promise;
}


//options = [{
//	verb: {object} - (Required) Verb / Action performed by the acting person.
//  actor: {object} - (Required) The acting person.
//  object: {object} - (Required) The activity on which the statement is performed. Ref - http://rusticisoftware.github.io/TinCanJS/doc/api/latest/classes/TinCan.Activity.html
//  registration: {String} - (Required) Product the actor is entitled to.
//  timestamp: {ISO8601 Date/time value} - (Optional) Time string
//  result: {TinCAN Result} - http://rusticisoftware.github.io/TinCanJS/doc/api/latest/classes/TinCan.Result.html
//}]
function createStatement(options) {
    var self = this;
    //Initializing promise
    var dfd = q.defer(), error;
    var createStatementObject = {}, createStatementsArray = [];
    if(Array.isArray(options)) {
        for(var i in options) {
            if (!(options[i].actor && options[i].verb && options[i].object &&
                options[i].registration))
            {
                error = {};
                error.message = error.description = 'Mandatory parameter options' +
                    ' not found in request options';
                error = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, error);
            } else {
                createStatementObject = {
                    verb: new TinCan.Verb(options[i].verb), actor: new TinCan.Agent(options[i].actor),
                    object: new TinCan.Activity(options[i].object), context: { registration: options[i].registration }
                };
                if(options[i].timestamp) {
                    createStatementObject.timestamp = options[i].timestamp;
                }
                if(options[i].result) {
                    createStatementObject.result = options[i].result;
                }
                createStatementsArray.push(createStatementObject);
            }
        }
    } else {
        error = {};
        error.message = error.description = 'Mandatory parameter options' +
            ' not found in request options';
        error = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, error);
    }
    if(error) {
        dfd.reject(error);
    } else {
        self.tincan.sendStatements(
            createStatementsArray,
            function (err) {
                for(var i in err) {
                    if(err[i].err !== null) {
                        var errObj = {
                            message: err[i].xhr.statusText,
                            description: JSON.parse(err[i].xhr.response),
                            status: err[i].xhr.status
                        };
                        if(errObj) {
                            error = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, errObj);
                            dfd.reject(error);
                            break;
                        }
                    }
                }

                if (!error) { dfd.resolve(); }
            }
        );
    }

    return dfd.promise;
}


//options = {
//  email: {String} - (Required) Email address of acting person,
//  verb: {String} - (Required) Verb / Action performed by the acting person. Supported verbs are
//                   ['attempted', 'scored', 'started', 'launched', 'answered', 'closed', 'terminated'],
//  itemcode: {String} - (Required) - Item code of the item that the user is acting on.
//  productid: {String} - (Required) - Product to which the acting user is entitled.
//  classid: {String} - (Optional) - Class in which the acting user is enrolled.
//}

/*function createStatement1(options) {
    var self = this;

    //Initializing promise
    var dfd = q.defer(), error;

    if (options && options.email && options.verb && options.itemcode &&
        options.productid) {
        var createStatementObject = {};
        var supportedVerbs = ['attempted', 'scored', 'started', 'launched',
                            'answered', 'closed', 'terminated'];
        for (var field in options) {
            if (options[field]) {
                switch (field) {
                    case 'email':
                        createStatementObject.actor = { mbox: 'mailto:' + options[field] };
                        break;
                    case 'verb':
                        if (supportedVerbs.indexOf(options[field]) > -1) {
                            createStatementObject.verb = {
                                id: 'http://adlnet.gov/expapi/verbs/' + options[field]
                            };
                        } else {
                            error = {};
                            error.message = 'Verb: ' + options[field] + ' is not supported.';
                            error.description = error.message;
                            error = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, error);
                            dfd.reject(error);
                        }
                        break;
                    case 'itemcode':
                        createStatementObject.target = {
                            id: self.config.DEFAULT_HOSTS.PRODUCT + '/product/' +
                                options.productid + '/' + encodeURIComponent(options[field])
                        };
                        break;
                    case 'productid':
                        createStatementObject.context = { productid: options[field] };
                        break;
                }
                if(error) { break; }
            }
        }

        createStatementObject = new TinCan.Statement(createStatementObject);

        if(!error) {
            self.tincan.sendStatements(
                [createStatementObject],
                function (err) {
                    err = err[0];
                    if (err.err !== null) {
                        error = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
				                dfd.reject(error);
                    } else {
                        dfd.resolve();
                    }
                }
            );
        }
    } else {
        error = {};
        error.message = error.description = 'Mandatory parameter options' +
            ' not found in request options';
        error = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, error);
        dfd.reject(error);
    }
    return dfd.promise;
}*/

//options = {
//	verb: {object} - (Optional) Verb / Action performed by the acting person. Supported verbs are
//                   ['attempted', 'scored', 'started', 'launched', 'answered', 'closed', 'terminated'],
//	since: {String} - (Optional) <ISO-8601> date time,
//	until: {String} - (Optional) <ISO-8601> date time,
//  cursor: {String} - (Optional) cursor to next set of documents
//  limit: {String} - (Optional) limit of documents per function call
//}

/*function getStatement1(options) {
    var self = this;

    //Initializing promise
    var dfd = q.defer(), error, params = {};
    var supportedVerbs = ['attempted', 'scored', 'started', 'launched',
                        'answered', 'closed', 'terminated'];
    if(options) {
        params = {
            limit: options.limit || 10,
            since: options.since || null,
            until: options.until || null
        };
        if(options.actor) {

        }
        if(options.verb) {
            params.verb = options.verb;
          if (supportedVerbs.indexOf(options.verb) > -1) {
                params.verb = new TinCan.Verb({
                    id: 'http://adlnet.gov/expapi/verbs/' + options.verb
                });
            } else {
                error= {};
                error.message = 'Verb: ' + options.verb + ' is not supported.';
                error.description = error.message;
                error = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, error);
                dfd.reject(error);
            }
        }
    }

    if(!error) {
        self.lrs.queryStatements({
            params: params,
            callback: function (err, sr) {
                if (err !== null) {
                    error = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
                    dfd.reject(error);
                } else {
                    dfd.resolve(sr);
                }
            }
        });
    }
    return dfd.promise;
}*/


//options = {
//  key: {string} - (Required)
//  email: {String} - (Required) Email address of acting person,
//  itemcode: {String} - (Required) - Item code of the item that the user is acting on.
//  productid: {String} - (Required) - Product to which acting user is entitled.
/*function getState(options) {
    var self = this;

    //Initializing promise
    var dfd = q.defer(), error;

    if (options && options.email && options.verb && options.itemcode &&
        options.productid)
    {
        var agent = new TinCan.Agent({ mbox: 'mailto:' + options.email });
        var activity = new TinCan.Activity({
            id: self.config.DEFAULT_HOSTS.PRODUCT + '/product/' + options.productid +
                '/' + encodeURIComponent(options.itemcode)
        });

        if(!error) {
            self.tincan.getState (options.key, {
                agent: agent,
                activity: activity,
                callback: function (err, sr) {
                    if (err !== null) {
                        error = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
                        dfd.reject(error);
                    } else {
                        dfd.resolve(sr);
                    }
                }
            });
        }
    } else {
        error = {};
        error.message = error.description = 'Mandatory parameter options' +
            ' not found in request options';
        error = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, error);
        dfd.reject(error);
    }

    return dfd.promise;
}*/

//options = {
//  key: {string}
//  email: {String} - (Required) Email address of acting person,
//  itemcode: {String} - (Required) - Item code of the item that the user is acting on.
//  productid: {String} - (Required) - Product to which the acting user is entitled.

/*function setState(options) {
    var self = this;

    //Initializing promise
    var dfd = q.defer(), error;

    if (options && options.email && options.itemcode && options.productid) {
        self.tincan.setState(options.key, options.value, {
            agent: new TinCan.Agent({ mbox: options.email }),
            activity: new TinCan.Agent({
                id: self.config.DEFAULT_HOSTS.PRODUCT + '/product/' +
                    options.productid + '/' +
                    encodeURIComponent(options.itemcode)
            }),
            function (err) {
                err = err[0];
                if (err.err !== null) {
                    error = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
                    dfd.reject(error);
                } else {
                    dfd.resolve();
                }
            }
        });
    } else {
        error.message = error.description = 'Mandatory parameter options,' +
            '  email, itemcode, productidnot found in request options';
        error = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, error);
        dfd.reject(error);
    }
    return dfd.promise;
}*/

//options = {
//  key: {string}
//  email: {String} - (Required) Email address of acting person,
//  itemcode: {String} - (Required) - Item code of the item that the user is acting on.
//}

/*function deleteState (options) {

    var self = this;

    //Initializing promise
    var dfd = q.defer(), error;
    var agent = new TinCan.Agent({ mbox: options.email });
    var activity = new TinCan.Agent({ id: options.itemcode });

    if(!error) {
        self.tincan.deleteState(options.key, {
            agent: agent,
            activity: activity,
            callback: function (err, sr) {
                if (err !== null) {
                    error = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
                    dfd.reject(error);
                } else {
                    dfd.resolve(sr);
                }
            }
        });
    }
    return dfd.promise;
}*/


},{"../../helpers":3,"q":90,"tincanjs":135}],22:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/
/***********************************************************
 * comproDLS SDK Product API Adaptor
 * Functions for calling Product API.
 ************************************************************/
var request = require('superagent');
var q = require('q');

var helpers = require('../../helpers');
var DLSError = helpers.errors.DLSError;

/*********************************
 * Setting Up Module Entry Point
 **********************************/
module.exports = product;

function product(accountId) {
    this.accountId = accountId;
    return {
        getProduct: getProduct.bind(this),
        getGlobalEntitlementsForAUser: getGlobalEntitlementsForAUser.bind(this),
        getMicroEntitlementsForAUser: getMicroEntitlementsForAUser.bind(this),

        getAllBundles: getAllBundles.bind(this),
        getSingleBundle: getSingleBundle.bind(this),

        getSingleProductFamily: getSingleProductFamily.bind(this),
        getAllProductFamilies: getAllProductFamilies.bind(this)
    };
}

/*********************************
 * Public Function definitions
 **********************************/

//options = {
//	productcode: '', //productcode of product
//	details: boolean, // (optional)
//  stage: string // (optional, ['1', '2', 'final']), default - final
//}
function getProduct(options) {
    var dfd = q.defer();
	var self = this;
    var err = {};

	if(options && options.productcode) {
        //Passed all validations, Construct API url
        var url = self.config.DEFAULT_HOSTS['PRODUCT'] +
            self.config.PRODUCT_API_URLS.getProductAPI;
        url = helpers.api.constructAPIUrl(url, {
            accountId: self.accountId,
            productCode: options.productcode
        });

        //Construct parameters
        var params = {};
        if(options.details) {
            params.details = options.details;
        }
        if(options.stage) {
            params.stage = options.stage;
        }
        //Setup request with URL and Params
        var requestAPI = request.get(url).query(params);
        if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

        //Call GET All Products Source Api
        requestAPI.end(function(err, response) {
            if (err) {
                err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
                dfd.reject(err);
            } else {
                dfd.resolve(response.body);
            }
        });
    }
    else {
		err.message = err.description = 'productcode not found in request options';
		err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
		dfd.reject(err);
	}

    return dfd.promise;
}

// options : { extUserId, productDetails, bundleDetails }
function getGlobalEntitlementsForAUser(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();

  if(options && options.extUserId) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.PRODUCT +
                                    self.config.PRODUCT_API_URLS.getEntitlementsOfAUser;
    url = helpers.api.constructAPIUrl(url,
                        { accountId : self.accountId, extUserId : options.extUserId });

    //Contruct parameters
    var query = {};
    if(options.productDetails) { query.productDetails = options.productDetails; }
    if(options.bundleDetails) { query.bundleDetails = options.bundleDetails; }

    //Setup request with URL and Params
    var requestAPI = request.get(url).query(query);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    //Call GET ALL USER Api
    requestAPI.end(function(err, response) {
      if (err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    var err = {};
    err.message = err.description = 'Mandatory parameter extUserId not found in request options';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;

}

/*options : {
    extuserid,    //mandatory
    productcode,  //mandatory
    context,      //optional
    feature_key,  //optional
    cursor        //optional
  }
*/
function getMicroEntitlementsForAUser(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();

  if(options && options.extuserid && options.productcode ) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS.PRODUCT +
                                    self.config.PRODUCT_API_URLS.getMicroEntitlementsOfAUser;
    url = helpers.api.constructAPIUrl(url,
                        { accountId : self.accountId, extUserId : options.extuserid });

    //Contruct parameters
    var query = {};
    query.productcode = options.productcode;
    if (options.context) { query.context = options.context; }
    if (options.feature_key) { query.feature_key = options.feature_key; }
    if (options.cursor) { query.cursor = options.cursor; }

    //Setup request with URL and Params
    var requestAPI = request.get(url).query(query);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    //Call Get All User Micro Entitlements Api
    requestAPI.end(function(err, response) {
      if (err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    var err = {};
    err.message = err.description = 'Mandatory parameter extuserid or productcode' +
                                    'not found in request options';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;

}

// options= {
//  stage: "",          //stage number or version
// }
function getAllBundles(options) {
    var self = this;
    var dfd = q.defer();

  //Passed all validations, Construct API url
  var url = self.config.DEFAULT_HOSTS.PRODUCT + self.config.PRODUCT_API_URLS.getAllBundles;

  url = helpers.api.constructAPIUrl(url, { accountId : self.accountId });
  //Contruct parameters
  var params = {};
  if(options && options.stage) { params.stage = options.stage; }

  //Setup request with URL and Post data
  var requestAPI = request.get(url).query(params);
  if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

  requestAPI.end(function (err, response) {
    if(err) {
      err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
      dfd.reject(err);
    } else {
      dfd.resolve(response.body);
    }
  });

  return dfd.promise;
}

// options = {
//   'bundle-code': "",   //bundle identifier
//   stage: "",           //stage number/version
// }
function getSingleBundle(options) {
  var self = this;
  var dfd = q.defer();
  var err;


  if(options && options['bundle-code']) {

    var url = self.config.DEFAULT_HOSTS.PRODUCT + self.config.PRODUCT_API_URLS.getSingleBundle;

    url = helpers.api.constructAPIUrl(url, { accountId : self.accountId, bundleCode: options['bundle-code'] });
    //Contruct parameters
    var params = {};
    if(options.stage) { params.stage = options.stage; }
    //Setup request with URL and Post data

    var requestAPI = request.get(url).query(params);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if(err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      } else {
        dfd.resolve(response.body);
      }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Required parameter bundle-code not found in request options';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }


  return dfd.promise;
}

// options= {
//  stage: "",          //stage number
// }
function getAllProductFamilies(options) {
  var self = this;
  var dfd = q.defer();

  //Passed all validations, Construct API url
  var url = self.config.DEFAULT_HOSTS.PRODUCT + self.config.PRODUCT_API_URLS.getAllProductFamilies;

  url = helpers.api.constructAPIUrl(url, { accountId: self.accountId });
  //Contruct parameters
  var params = {};
  if (options && options.stage) { params.stage = options.stage; }

  //Setup request with URL and Post data
  var requestAPI = request.get(url).query(params);
  if (self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

  requestAPI.end(function (err, response) {
    if (err) {
      err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
      dfd.reject(err);
    } else {
      dfd.resolve(response.body);
    }
  });

  return dfd.promise;
}

// options = {
//   'family-code': "",   //product-family identifier
//    stage: "",          //stage number
// }
function getSingleProductFamily(options) {
  var self = this;
  var dfd = q.defer();
  var err;

  if (options && options['family-code']) {

    var url = self.config.DEFAULT_HOSTS.PRODUCT +
      self.config.PRODUCT_API_URLS.getSingleProductFamily;

    url = helpers.api.constructAPIUrl(url, {
      accountId: self.accountId, familyCode: options['family-code']
    });

    //Contruct parameters
    var params = {};
    if (options.stage) { params.stage = options.stage; }

    //Setup request with URL and Post data
    var requestAPI = request.get(url).query(params);
    if (self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if (err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      } else {
        dfd.resolve(response.body);
      }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Required parameter family-code not found in request options';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

},{"../../helpers":3,"q":90,"superagent":133}],23:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/
/***********************************************************
 * comproDLS SDK Pub Adaptor
 * Functions for calling Pub.
 ************************************************************/

var request = require('superagent');
var q = require('q');

var helpers = require('../../helpers');
var DLSError = helpers.errors.DLSError;

/*********************************
 * Setting Up Module Entry Point
 **********************************/
module.exports = pub;

function pub() {
  return {
    "promoteProduct": promoteProduct.bind(this),
    "registerProduct": registerProduct.bind(this),
    "ingestProduct": ingestProduct.bind(this),
    "createBundle": createBundle.bind(this),
    "updateBundle": updateBundle.bind(this),
    "getAllBundles": getAllBundles.bind(this),
    "getSingleBundle": getSingleBundle.bind(this),
    "createProductFamily": createProductFamily.bind(this),
    "updateProductFamily": updateProductFamily.bind(this),
    "getSingleProductFamily": getSingleProductFamily.bind(this),
    "getAllProductFamilies": getAllProductFamilies.bind(this)
  };
}

/*********************************
 * Public Function definitions
 **********************************/

/**
 * {
    "source": {
      "stage": "1" //["1", "2"]
    },
    "target": {
      "org": <target_org> //optional, mandatory for sourceStage-1 + targetStage-2
      "stage": "2" //["2", "final"]
    },
    "externalrefid": <externalID>,
    "productcode": "string"
    }
 */
function promoteProduct(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();

  //Construct API url
  var url = self.config.DEFAULT_HOSTS['PUB'] + self.config.PUB_API_URLS.promoteAPI;
  url = helpers.api.constructAPIUrl(url, {
    "orgId": self.orgId, "productcode": options.productcode
  });
  //Contruct parameters
  var params = {
    source: {},
    target: {}
  };
  if (options) {
    if (options.source && options.source.stage) {
      params.source.stage = options.source.stage;
    }
    if (options.target) {
      if(options.target.org) {
        params.target.org = options.target.org;
      }
      if(options.target.stage) {
        params.target.stage = options.target.stage;
      }
    }
    if(options.externalrefid) {
      params.externalrefid = options.externalrefid;
    }
  }

  //Setup request with URL and Post data
  var requestAPI = request.post(url).send(params);

  if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
  requestAPI.end(function (err, response) {
    if (err) {
      err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
      dfd.reject(err);
    } else {
      dfd.resolve(response);
    }
  });
  return dfd.promise;
}

//options = {
//    targetorg: 'dev',
//    repositorytype: 'github', //mandatory
//    productcode: 'Product code', //mandatory
//    title: 'Product title', //mandatory
//    producttype: 'Product type',  //mandatory e.g., etextbook, imgbook, courseware.
//    bundle-codes: ['bundle-code of the bundle']  //optional: Product register request, related to a Bundle, currently only one buldle-code in Array
//    externalrefid: <externalID>
//
// /* Note: Register via github is no more supported from v2.5. */
//    github: {
//        repository: 'Github repository',
//        token: 'Github Auth token'
//    }
//}
function registerProduct(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();

  //Construct API url
  var url = self.config.DEFAULT_HOSTS['PUB'] + self.config.PUB_API_URLS.registerProductAPI;
  url = helpers.api.constructAPIUrl(url, { "orgId" : self.orgId });
  
  //Contruct parameters
  var params = {};
  if(options) {
    if(options.targetorg) {
      params.targetorgid = options.targetorg;
    }
    if(options.repositorytype) {
      params.repositorytype = options.repositorytype;
    }
    if(options.producttitle) {
      params.producttitle = options.producttitle;
    }
    if(options.producttype) {
      params.producttype = options.producttype;
    }
    if(options.productcode) {
      params.productcode = options.productcode;
    }
    if(options.github) {
      params.github = options.github;
    }
    if(options.s3) {
      params.s3 = options.s3;
    }
    if(options.externalrefid) {
      params.externalrefid = options.externalrefid;
    }
    if(options['bundle-codes']) {
      params['bundle-codes'] = options['bundle-codes'];
    }
  }

  //Setup request with URL and Post data
  var requestAPI = request.post(url).send(params);

  if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
  requestAPI.end(function(err, response) {
    if (err) {
      err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
      dfd.reject(err);
    } else { 
      dfd.resolve(response);
    }
  });
  return dfd.promise;
}

//options = {
//    productcode: "string",
//    branchref: 'Github branch name or s3 folder path', //mandatory, ingestion via Github no more supported from v2.5.
//    "externalrefid": <externalID>,
//    "bundle-codes": ['bundle-code of the bundle'] //optional: Product register request, related to a Bundle
//}
function ingestProduct(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();

  var productCode;
  if(options && options.productcode) {
    productCode = options.productcode;
  }

  //Construct API url
  var url = self.config.DEFAULT_HOSTS['PUB'] + self.config.PUB_API_URLS.ingestByCodeAPI;
  url = helpers.api.constructAPIUrl(url, {
    "orgId" : self.orgId,
    "productcode" : productCode
  });
  //Contruct parameters
  var params = {};
  if(options) {
    if(options.branchref) {
      params.branchref = options.branchref;
    }
    if(options.externalrefid) {
      params.externalrefid = options.externalrefid;
    }
    if(options['bundle-codes']) {
      params['bundle-codes'] = options['bundle-codes'];
    }
  }

  //Setup request with URL and Post data
  var requestAPI = request.post(url).send(params);

  if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
  requestAPI.end(function(err, response) {
    if (err) {
      err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
      dfd.reject(err);
    } else {
      dfd.resolve(response);
    }
  });
  return dfd.promise;
}

// options = {
// 	stage: "",		      //stage number or version
// 	"bundle-code": "",	//bundle identifier
// 	body: {
// 		title: "",		    //bundle title
// 		products: []	    //products array of objects containing following keys:
                        //mandatory fields:  ext-product, dls-product, meta, activation, analytics, classes,
                        //optional fields: groups, segment, results-display, assignability, learning-path, activity
// 	}
// }
function createBundle(options) {
  var self = this;
  //Initializing promise
  var dfd = q.defer();
  var err;
  //Validations
  if(options && options.stage && options['bundle-code'] && options.body && options.body.title &&
      options.body.products)
  {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS['PUB'] + self.config.PUB_API_URLS.createBundle;
    url = helpers.api.constructAPIUrl(url, { orgid: self.orgId, stage: options.stage });

    //Contruct parameters
    options.body['bundle-code'] = options['bundle-code'];
    //Setup request with URL and Post data
    var requestAPI = request.post(url).send(options.body);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if(err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      } else {
        dfd.resolve(response.body);
      }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Required parameter stage or bundle-code or title or ' +
                                      'products not found in request options';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

// options = {
// 	stage: "",					//stage number or version
// 	"bundle-code": "",	//bundle identifier
// 	body: {
// 		title: "",				//bundle title (optional)
// 		products: []			//products array of objects containing following keys:
                        //mandatory fields:  ext-product, dls-product, meta, activation, analytics, classes,
                        //optional fields: groups, segment, results-display, assignability, learning-path, activity
// 	}
// }
function updateBundle(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();
  var err;

  //Validations
    if(options && options.stage && options['bundle-code'] && options.body && options.body.products) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS['PUB'] + self.config.PUB_API_URLS.updateBundle;
    url = helpers.api.constructAPIUrl(url, {
      orgid: self.orgId, stage: options.stage, bundleCode: options['bundle-code']
    });

    //Setup request with URL and Post data
    var requestAPI = request.put(url).send(options.body);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
    requestAPI.end(function (err, response) {
      if(err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      } else {
        dfd.resolve(response.body);
      }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Required parameter stage or bundle-code or ' +
                                      'products not found in request options';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

// options= {
//  stage: "",          //stage number or version
// }

function getAllBundles(options) {
  var self = this;
  //Initializing promise
  var dfd = q.defer();

  //Construct API url
  var url = self.config.DEFAULT_HOSTS['PUB'] + self.config.PUB_API_URLS.getAllBundles;

  url = helpers.api.constructAPIUrl(url, { orgid: self.orgId, });
  //Contruct parameters
  var params = {};
  if(options && options.stage) { params.stage = options.stage; }

  //Setup request with URL and Post data
  var requestAPI = request.get(url).query(params);

  if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
  requestAPI.end(function (err, response) {
    if(err) {
      err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
      dfd.reject(err);
    } else {
      dfd.resolve(response.body);
    }
  });
  return dfd.promise;
}

// options = {
//   'bundle-code': "",   //bundle identifier
//   stage: "",           //stage number/version
// }
function getSingleBundle(options) {
  var self = this;
  var dfd = q.defer();

  //Validations
  var err;
  if(options && options['bundle-code']) {

    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS['PUB'] + self.config.PUB_API_URLS.getSingleBundle;

    url = helpers.api.constructAPIUrl(url, { orgid: self.orgId, bundleCode: options['bundle-code'] });
    //Contruct parameters
    var params = {};
    if(options && options.stage) { params.stage = options.stage; }
    //Setup request with URL and Post data

    var requestAPI = request.get(url).query(params);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
    requestAPI.end(function (err, response) {
      if(err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      } else {
        dfd.resolve(response.body);
      }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Required parameter bundle-code not found in request options';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

// options = {
//   "stage": <>,                 // Mandatory
//   "body": {
//     "family-code": "string",   // Mandatory
//     "ext_user_id": "string",   // Optional
//     "assets": {                // Optional
//       "branchref": "string",   // Optional
//       "bucket": "string"       // Optional
//       "source": {              // Optional
//         "branchref": "string", // Mandatory
//         "bucket": "string"     // Mandatory
//       }
//     },
//     "externalrefid": "string", // Optional
//     "data": {... }             // Optional
//   }
// }
function createProductFamily(options) {
  var self = this;
  //Initializing promise
  var dfd = q.defer();
  var err;
  //Validations
  if (options && options.stage && options.body && options.body['family-code'])
  {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS['PUB'] + self.config.PUB_API_URLS.createProductFamily;
    url = helpers.api.constructAPIUrl(url, { orgid: self.orgId, stage: options.stage });

    //Setup request with URL and Post data
    var requestAPI = request.post(url).send(options.body);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if(err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      } else {
        dfd.resolve(response.body);
      }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Required parameter stage or family-code ' +
                                    'not found in request options';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

// options = {
//   "stage": <>,                 // Mandatory
//   "family-code": <>,           // Mandatory
//   "body": {
//     "ext_user_id": "string",   // Optional
//     "assets": {                // Optional
//       "branchref": "string",   // Optional
//       "bucket": "string"       // Optional
//       "source": {              // Optional
//         "branchref": "string", // Mandatory
//         "bucket": "string"     // Mandatory
//       }
//     },
//     "externalrefid": "string", // Optional
//     "data": {... }             // Optional
//   }
// }
function updateProductFamily(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();
  var err;

  //Validations
    if (options && options.stage && options['family-code']) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS['PUB'] + self.config.PUB_API_URLS.updateProductFamily;
    url = helpers.api.constructAPIUrl(url, {
      orgid: self.orgId, stage: options.stage, familyCode: options['family-code']
    });

    //Setup request with URL and Post data
    var requestAPI = request.put(url).send(options.body);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
    requestAPI.end(function (err, response) {
      if(err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      } else {
        dfd.resolve(response.body);
      }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Required parameter stage or family-code ' +
                                    'not found in request options';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/**
 * options = {
 *   "family-code": "",   //product family identifier, Mandatory
 *   "stage"      : "",   //stage number
 * }
 */
function getSingleProductFamily(options) {
  var self = this;
  var dfd = q.defer();

  //Validations
  var err;
  if(options && options['family-code']) {
    //Passed all validations, Construct API url
    var url = self.config.DEFAULT_HOSTS['PUB'] + self.config.PUB_API_URLS.getSingleProductFamily;
    url = helpers.api.constructAPIUrl(url, {
      orgid: self.orgId, familyCode: options['family-code']
    });

    //Contruct parameters
    var params = {};
    if(options.stage) { params.stage = options.stage; }

    //Setup request with URL and Post data
    var requestAPI = request.get(url).query(params);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if(err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      } else {
        dfd.resolve(response.body);
      }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Required parameter family-code not found in request options';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/**
 * options = {
 *   "stage": <>,   // Optional
 *  }
 */
function getAllProductFamilies(options) {
  var self = this;
  //Initializing promise
  var dfd = q.defer();

  //Construct API url
  var url = self.config.DEFAULT_HOSTS['PUB'] + self.config.PUB_API_URLS.getAllProductFamilies;

  url = helpers.api.constructAPIUrl(url, { orgid: self.orgId, });
  //Contruct parameters
  var params = {};
  if(options && options.stage) { params.stage = options.stage; }

  //Setup request with URL and Post data
  var requestAPI = request.get(url).query(params);

  if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
  requestAPI.end(function (err, response) {
    if(err) {
      err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
      dfd.reject(err);
    } else {
      dfd.resolve(response.body);
    }
  });
  return dfd.promise;
}

},{"../../helpers":3,"q":90,"superagent":133}],24:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

/***********************************************************
 * comproDLS SDK PUSHX Adaptor
 * Functions for calling PUSHX.
 ************************************************************/


var q = require('q');
var request = require('superagent');

var helpers = require('../../helpers');
var pubnubClientWrapper = require('./pubnubClientWrapper');
var DLSError = helpers.errors.DLSError;

/*********************************
 * Setting Up Module Entry Point
 **********************************/
module.exports = pushX;

/*********************************
 * Public Function definitions
 **********************************/
function pushX() {
    var _pubnubClientWrapper = pubnubClientWrapper();
    return {
        "connect": _connect.bind(this, _pubnubClientWrapper),
        "cleanup": _cleanup.bind(this, _pubnubClientWrapper),
        "grantByUserOrgId": grantByUserOrgId.bind(this),
        "grantByAccountId": grantByAccountId.bind(this),
        "grantByAccountIdOnExtUserId": grantByAccountIdOnExtUserId.bind(this)
    };
}

/*********************************
 * Public Function definitions
 **********************************/

function _connect(pubnubCW, options) {
    if (!options.userid) {
        var err = {};
        err.message = err.description = 'Mandatory parameter userid not found in request options.';
        err = new DLSError(helpers.errors.ERROR_TYPES.PUSHX_ERROR, err);
        throw err;
    }

    // Adding SSL flag
    return pubnubCW.setup({
      'userid': options.userid,
      'pubnub': {
        'publishKey': options.publishKey,
        'subscribeKey': options.subscribeKey,
        'authKey': options.authKey,
        'ssl': true
      }
    });
}

function _cleanup(pubnubCW) { pubnubCW.cleanup(); }

/*options = {
  authKey: <authKey>
}*/
function grantByUserOrgId(options) {
    var self = this;
    var dfd = q.defer();  // Initializing promise
    // Validations
    var err = helpers.validations.isAuthenticated(self.orgId, self.token);
    if(err) { dfd.reject(err); }
    else {
        // Passed all validations, Construct API url
        var url = self.config.DEFAULT_HOSTS.PUSHX + self.config.PUSHX_API_URLS.grantByUserOrgId;
        url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });
        // Setup request with URL and Params
        var requestAPI = request.post(url)
                         .set('Content-Type', 'application/json')
                         .set('Accept', 'application/json');

        var body = {};
        if(options.authKey) { body.authKey = options.authKey; }

        requestAPI.send(body);

        //Setup token in Authorization header
        requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
        if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

        // Call Change Password Api
        requestAPI.end(function(err, response) {
            if(err) {
                err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
                dfd.reject(err);
            }
            else { dfd.resolve(response.body); }
        });
    }
    return dfd.promise;
}

/*options = {
    accountId: <accountid>,
    refId: <extRefId>,
    authKey: <authKey>
}*/
function grantByAccountId(options) {
	var self = this, err ={};
    var dfd = q.defer();  // Initializing promise

    if(options.accountId && options.refId) {
        // Passed all validations, Construct API url
        var url = self.config.DEFAULT_HOSTS.PUSHX + self.config.PUSHX_API_URLS.grantByAccountId;
        url = helpers.api.constructAPIUrl(url, { accountId: options.accountId });
        // Setup request with URL and Params
        var requestAPI = request.post(url)
                         .set('Content-Type', 'application/json')
                         .set('Accept', 'application/json');
        if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

        var body = { refId: options.refId };
        if(options.authKey) { body.authKey = options.authKey; }

        requestAPI.send(body);
        requestAPI.end(function(err, response) {
            if(err) {
                err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
                dfd.reject(err);
            }
            else { dfd.resolve(response.body); }
        });
    }
    else {
        err.message = err.description = "Required parameter ['accountId', 'refId'] " +
                                        "not found in request options";
        err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
        dfd.reject(err);
    }
    return dfd.promise;
}

/*options = {
    accountId: <accountid>,
    extUserId: <extUserId>, //mandatory
    authKey: <authKey>
}*/
function grantByAccountIdOnExtUserId(options) {
	var self = this, err ={};
    var dfd = q.defer();  // Initializing promise

    if(options.accountId && options.extUserId) {
        // Passed all validations, Construct API url
        var url = self.config.DEFAULT_HOSTS.PUSHX + self.config.PUSHX_API_URLS.grantByAccountId;
        url = helpers.api.constructAPIUrl(url, { accountId: options.accountId });
        // Setup request with URL and Params
        var requestAPI = request.post(url)
                         .set('Content-Type', 'application/json')
                         .set('Accept', 'application/json');
        if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

        var body = { extUserId: options.extUserId };
        if(options.authKey) { body.authKey = options.authKey; }

        requestAPI.send(body);
        requestAPI.end(function(err, response) {
            if(err) {
                err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
                dfd.reject(err);
            }
            else { dfd.resolve(response.body); }
        });
    }
    else {
        err.message = err.description = "Required parameter ['accountId', 'extUserId'] " +
                                        "not found in request options";
        err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
        dfd.reject(err);
    }
    return dfd.promise;
}


},{"../../helpers":3,"./pubnubClientWrapper":25,"q":90,"superagent":133}],25:[function(require,module,exports){
var pubNub = require("pubnub");
var EventEmitter = require("events").EventEmitter;
var helpers = require('../../helpers');

var PUSHXError = helpers.errors.PUSHXError;

var CHANNEL_DELIMITER = '$';

/**
 * Clientwrapper module.
 * Purpose -  Wrapper around the Saas client SDK (PubNub). Abstracts the provider/vendor (PubNun) specific
 * implementation details - allowing future switch (to a different Saas provider).
 */
module.exports = function () {
    "use strict";

    /** ====== MODULE GLOBALS */
    var _pubnubClient; //SAAS provider client SDK (PubNub).
    var _eventEmitter = new EventEmitter();
    var _userOptions;
    var _globalSubscription = [];
    var _globalSubscriptionStatus = {};
    var bStatusSubscribed = false;

    /** ###### END OF MODULE GLOBALS */

    /** ====== UTILITY FUNCTIONS */


    /**
    * Call this function to make a new client adaptor.
      This adapter exposes functions to send message, update user state etc.
    * @return (object) : client adapter.
    */
    var _constructClientAdaptor = function () {
        //Returning the adaptor (Plain Javascript object)
        return {
            "on": function (channelObj, handler) {
                var pubNubChannel;
                var channelContext = [];

                if((channelObj.orgid || channelObj.userid) || channelObj.accountid ||
                    channelObj.productid || channelObj.classid)
                {
                  if(channelObj.accountid) { channelContext.push('a-' + channelObj.accountid); }
                  else {
                    if(channelObj.orgid) { channelContext.push('o-' + channelObj.orgid); }
                    if(channelObj.userid) { channelContext.push('u-' + channelObj.userid); }
                    if(channelObj.productid) { channelContext.push('p-' + channelObj.productid); }
                    if(channelObj.classid) { channelContext.push('c-' + channelObj.classid); }
                  }
                  pubNubChannel = channelContext.join(CHANNEL_DELIMITER) + CHANNEL_DELIMITER +
                                  channelObj.channel;
                  if(!_globalSubscription.includes(pubNubChannel)) {
                    _globalSubscription.push(pubNubChannel);
                    _globalSubscriptionStatus[pubNubChannel] = {
                        status: 'pending'
                    };
                    _eventEmitter.on(pubNubChannel, handler);
                    _subscribeToPubNubChannels(pubNubChannel);
                  }
                }
                else if(channelObj.channel === 'pushx_status' && ! bStatusSubscribed) {
                    _eventEmitter.on(channelObj.channel, handler);
                    bStatusSubscribed = true;
                }
            },
            "getMySubscriptionStatus": __getMySubscriptionStatus
        };
    };

    var _translatePubnubMessage = function (pubNubEventData) {
        var subscribedChannel = pubNubEventData.subscribedChannel;
        var message = pubNubEventData.message;
        _eventEmitter.emit(subscribedChannel, message);
    };

    var _translatePubnubStatus = function(status) {
        var channels = [], error, successObj;
        switch (status.category) {
            case "PNConnectedCategory":
                if(status.operation === "PNSubscribeOperation") {
                    channels = status.subscribedChannels;
                    for(var i in channels) {
                        if(_globalSubscriptionStatus[channels[i]]) {
                            _globalSubscriptionStatus[channels[i]].status = 'subscribed';
                        }
                    }
                    successObj = {
                        category: 'PUSHX',
                        type: 'CHANNEL_SUBSCRIPTION',
                        status: 'SUCCESS',
                        message: 'Success: Subscribed successfully.',
                        httpcode: 200,
                        data: {
                            payload: {
                                channels: status.subscribedChannels
                            },
                            message: 'Success: Subscribed successfully.'
                        }
                    };
                    _eventEmitter.emit('pushx_status', successObj);
                }
                break;
            case "PNAccessDeniedCategory":
                if(status.operation === "PNSubscribeOperation") {
                    var errorData = {
                        payload: JSON.parse(status.errorData.response.text).payload,
                        message: 'Forbidden: Subscription failed.',
                        errorDetails: {
                            operation: status.operation,
                            category: status.category,
                            statusCode: status.statusCode
                        }
                    };
                    channels = errorData.payload.channels;
                    for(var j in channels) {
                        if(_globalSubscriptionStatus[channels[j]]) {
                            _globalSubscriptionStatus[channels[j]].status = 'error';
                            _globalSubscriptionStatus[channels[j]].error = error;
                        }
                    }
                    error = new PUSHXError(helpers.errors.ERROR_CATEGORY.PUSHX, errorData);
                    _eventEmitter.emit('pushx_status', error);
                }
                break;
            case "PNBadRequestCategory":
            case "PNNetworkDownCategory":
            case "PNNetworkUpCategory":
                error = {
                    message: "PushX Error", status: status.statusCode,
                    pushXError: status
                };
                error = new PUSHXError(helpers.errors.ERROR_CATEGORY.PUSHX, error);
                _eventEmitter.emit('pushx_status', error);
                break;
        }
    };

    var __getMySubscriptionStatus = function() {
        return JSON.parse(JSON.stringify(_globalSubscriptionStatus));
    };

    /**
     * Sets up necessary subscriptions (Pub/Sub) to PUSH channels. To a large extent, subscriptions are
     * driven the student's (instructor's) roster.
     * @param {object} groups - Roster information, provided during initialization, wrapper.setup().
     */
    var _subscribeToPubNubChannels = function (channel) {
        _pubnubClient.subscribe({ // Calling Pubnub SDK
            "channels": [channel]
        });
    };

    /** ###### END OF UTILITY FUNCTIONS ############ */

    /** ====== Client Wrapper Member functions ==> Mapped to Public Methods */

    /**
     * Initializes the library, and established a connection with the Saas/PUSH provider.
     * Setup should be called only once i.e. ONE CONNECTION (on a page/tab) is allowed
     * at a time. If called again, it will throw an error (failure callback).
     *
     * @param {object} userOptions - User auth key and pubnub credentials
     * @returns PROMISE.
     */
    var __setup = function (userOptions) {
        var pubnubConfig = userOptions.pubnub;
        pubnubConfig.uuid = userOptions.userid;

        if (!_pubnubClient && pubnubConfig) {
            _pubnubClient = new pubNub(pubnubConfig); //Connect with PubNub SDK
            processSetup();
        } else {
            return new Error('Already Initialized');
        }

        /**
         * SYNC Function
         */
        function processSetup() {
            _userOptions = userOptions;
            _pubnubClient.addListener({ //Setup Listeners (events will shows up after subscription)
                "message": function (data) {
                    _translatePubnubMessage(data);
                },
                "status": function (status) {
                    _translatePubnubStatus(status);
                }
            });
        }
        return _constructClientAdaptor();
    }; //End of _setup()

    var __cleanup = function () {
        if (_pubnubClient) { //Skip cleanup if setup() was not called.
            _pubnubClient.unsubscribeAll();
            _pubnubClient.stop();
            _globalSubscription = [];
            bStatusSubscribed = false;
            _globalSubscriptionStatus = {};
        }
        _pubnubClient = undefined;
    };

    return { // Return public methods for the wrapper
        "setup": __setup,
        "cleanup": __cleanup
    };

}; //End of Client Wrapper module

},{"../../helpers":3,"events":67,"pubnub":88}],26:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

/***********************************************************
 * comproDLS SDK PUSH Adaptor
 * Functions for calling PUSH.
 ************************************************************/
 
var EventEmitter = require("events").EventEmitter;
var io = require('socket.io-client');
var q = require('q');

var helpers = require('../../helpers');
var DLSError = helpers.errors.DLSError;
 
/*********************************
 * Setting Up Module Entry Point  
 **********************************/
module.exports = push;

/*********************************
 * Public Function definitions
 **********************************/
function push() {
    return {
        "connect": _connect.bind(this)
    };
}

/*********************************
 * Public Function definitions
 **********************************/
function _connect(orgId, userId) {
    //Reference to comproDLS SDK object, containing the token
    var self = this;

    //Initializing promise
    var dfd = q.defer();

    //Notification Event Constants
    var EVENTS = {
        //Events to listen
        "CONNECT": "push_connect", // Connection established
        "CONNECT_ERROR": "push_error", // Connection established
        "USER_NEW": "presence", // First time presence (all online users)
        "USER_CHANGED": "presenceupdate", //Presense update (changes only)
        "COLLAB_EVENT": "collab", //Collaboration event (Message / Post / Announcement)
        "ACTIVITY_EVENT": "activity", //Assessment / Test / Activity event (Timeout)
		"JOB_EVENT": "job", //Job status
        "SYSTEM_EVENT": "systemevents", // comproDLS System Events
        "ERROR": "error", // Custom Error of Push-Service

        //Events to emit
        "ACTIVEROOM": "activeroom"

    };
    
    //Setup connection URL based on AUTH style (token or userid) 
    var pushConnectionURL;
    
    if(userId && orgId) {
        //All the namespaces on push service should be in lowercase
        orgId = orgId.toLowerCase();

        //Directly apply the userid passed to us
        pushConnectionURL = self.config.DEFAULT_HOSTS['PUSH'] + '/' + orgId + '?orgid=' + orgId + '&userid=' + userId;
    } else {
        //Validate the we have a valid AUTH credentials         
        var err = helpers.validations.isAuthenticated(self.orgId, self.token);
        if (err) {
            dfd.reject(err);
        } else {
            pushConnectionURL = self.config.DEFAULT_HOSTS['PUSH'] + '/' + self.orgId.toLowerCase() + '?orgid=' + self.orgId.toLowerCase() + '&token=' + self.token.access_token;
        }
    }
    
    if(pushConnectionURL) {    
       
        var socket = io.connect(pushConnectionURL);
        
        //Setup notifications handler, and return to the caller.
        var notifications = new EventEmitter();

        //----------- Handle events to be emitted to Push-Service
        notifications.on(EVENTS.ACTIVEROOM, function(activeroomid) {
            socket.emit(EVENTS.ACTIVEROOM, activeroomid);
        });

        dfd.resolve(notifications);
        
        socket.on('connect', function(){
            //Successfully connected to PUSH service, notify caller, via "notifications" Emiter
            var eventContext = {};
            notifications.emit(EVENTS.CONNECT, eventContext);
        });
        
        //----------- Handle Connection errors and notify caller, via "notifications" Emiter
        socket.on('connect_error', function(errObj){
           
            var eventContext = {};
            eventContext.error = {}
            eventContext.error.message ="connect_error"
            eventContext.error.description = "Connection Error to PUSH API, URL: " + pushConnectionURL + ", " + JSON.stringify(errObj);
            
            notifications.emit(EVENTS.CONNECT_ERROR, eventContext)
        });
        
        socket.on('connect_timeout', function(errObj){
            
            var eventContext = {};
            eventContext.error = {}
            eventContext.error.message ="connect_timeout"
            eventContext.error.description = "Timeout error to PUSH API, URL: " + pushConnectionURL + ", " + JSON.stringify(errObj);
            
            notifications.emit(EVENTS.CONNECT_ERROR, eventContext)
        });
        
        //----------- Handle comproDLS Push Notifications, send them to the caller via "notifications" Emiter
        socket.on('presence', function (presenceMessage) {
            var eventContext = presenceMessage; 
            notifications.emit(EVENTS.USER_NEW, eventContext);
        });
        socket.on('presenceupdate', function (presenceUpdateMessage) {
            var eventContext = presenceUpdateMessage; 
            notifications.emit(EVENTS.USER_CHANGED, eventContext);
        });
        socket.on('collab', function (collabMessage) {
            var eventContext = collabMessage; 
            notifications.emit(EVENTS.COLLAB_EVENT, eventContext);
        });
        socket.on('activity', function (activityMessage) {
            var eventContext = activityMessage; 
            notifications.emit(EVENTS.ACTIVITY_EVENT, eventContext);
        });
		socket.on('job', function (jobMessage) {
            var eventContext = jobMessage;
            notifications.emit(EVENTS.JOB_EVENT, eventContext);
        });
        socket.on('systemevents', function (systemEventMessage) {
            var eventContext = systemEventMessage;
            notifications.emit(EVENTS.SYSTEM_EVENT, eventContext);
        });
        socket.on('error', function(err) {
            var eventContext;
			try {
				eventContext = JSON.parse(err);
			} catch(Ex) {
				eventContext = new Error(err);
			}
			socket.disconnect();
			notifications.emit(EVENTS.ERROR, eventContext);
        });
    } 
    
    return dfd.promise;
}

//for reference only
function _setup(orgId, userId) {
    var dfd = q.defer();

    pubnubClientWrapper.setup({
        orgId: orgId, userId: userId,
        pubnub: this.config.DEFAULT_PUBNUB_CREDENTIALS
    })
    .then(function(pushAdapter) { dfd.resolve(pushAdapter); })
    .catch(function(error) { dfd.reject(error); });

    return dfd.promise;
}

},{"../../helpers":3,"events":67,"q":90,"socket.io-client":109}],27:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

/***********************************************************
 * comproDLS SDK Rules API Adaptor
 * Functions for calling Rules API.
 ************************************************************/

var q = require('q');
var request = require('superagent');
var helpers = require('../../helpers');

var DLSError = helpers.errors.DLSError;

/*********************************
 * Setting Up Module Entry Point
 **********************************/
module.exports = rules;
//Rules Adaptor Contsructor
function rules() {
  return {
    getRules: getRules.bind(this),
    getParticularRule: getParticularRule.bind(this),
    getUserRule: getUserRule.bind(this),
    updateRuleDisplay: updateRuleDisplay.bind(this),
    createRule: createRule.bind(this),
    updateRule: updateRule.bind(this),
    deleteRule: deleteRule.bind(this)
  };
}

/*********************************
 * Public Function definitions
 **********************************/

/**
 * options = {
 *   context: '',   // Mandatory
 *   ruleType: '',  // Mandatory
 *   cursor: ''     // Optional
 * }
 */
function getRules(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();

  //Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if (err) {
    dfd.reject(err);
  } else {
    if (options && options.context && options.ruleType) {
      //Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.RULES_API_URLS.rules;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        context: encodeURIComponent(options.context),
        ruleType: options.ruleType
      });

      //Setup request with URL and Params
      var queryParam = { cursor: options.cursor };

      var requestAPI = request.get(url)
        .set('Content-Type', 'application/json')
        .set('Accept', 'application/json')
        .query(queryParam);

      if (self.traceid) {
        requestAPI.set('X-Amzn-Trace-Id', self.traceid);
      }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (err, response) {
        if (err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body);
        }
      });
    } else {
      err = {};
      err.message = err.description = 'context or ruleType not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/**
 * options = {
 *   context: '',   // Mandatory
 *   ruleType: '',  // Mandatory
 *   ruleId: ''     // Mandatory
 * }
 */
function getParticularRule(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();

  //Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if (err) {
    dfd.reject(err);
  } else {
    if (options && options.context && options.ruleType && options.ruleId) {
      //Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.RULES_API_URLS.particularRule;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        context: encodeURIComponent(options.context),
        ruleType: options.ruleType,
        ruleId: options.ruleId
      });

      //Setup request with URL and Params
      var requestAPI = request.get(url);

      if (self.traceid) {
        requestAPI.set('X-Amzn-Trace-Id', self.traceid);
      }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (err, response) {
        if (err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body);
        }
      });
    } else {
      err = {};
      err.message = err.description = 'context or ruleType or ruleId not found' +
        ' in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/**
 * options = {
 *   orgId: '',          // Mandatory
 *   context: '',        // Mandatory
 *   ruleType: '',       // Mandatory
 *   userId: '',         // Mandatory
 *   mergeGlobalRules:'' // Optional
 * }
 */
function getUserRule(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();

  if (options && options.orgId && options.context && options.ruleType && options.userId) {
    //Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH + self.config.RULES_API_URLS.getUserRule;
    url = helpers.api.constructAPIUrl(url, {
      orgId: self.orgId,
      context: encodeURIComponent(options.context),
      ruleType: options.ruleType,
      userId: options.userId
    });

    //Setup request with URL and Params
    var queryParam = { mergeGlobalRules: options.mergeGlobalRules };

    var requestAPI = request.get(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .query(queryParam);

    if (self.traceid) {
      requestAPI.set('X-Amzn-Trace-Id', self.traceid);
    }

    //Setup token in Authorization header
    requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

    requestAPI.end(function (err, response) {
      if (err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      } else {
        dfd.resolve(response.body);
      }
    });
  } else {
    var err = {};
    err.message = err.description = 'Mandatory params - orgId or context or ruleType or userId ' +
      'not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/**
 * options = {
 *   context: '',        // Mandatory
 *   ruleType: '',       // Mandatory
 *   ruleId: '',         // Mandatory
 *   body: {
 *     rule_display: ''  // Mandatory
 *   }
 *  }
 */
function updateRuleDisplay(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if (err) { dfd.reject(err); }
  else {
    if (options && options.context && options.ruleType && options.ruleId &&
      options.body && options.body.rule_display) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.RULES_API_URLS.updateRuleDisplay;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        context: encodeURIComponent(options.context),
        ruleType: options.ruleType,
        ruleId: options.ruleId
      });

      // Setup request with URL and Params
      var requestAPI = request.put(url)
        .set('Content-Type', 'application/json')
        .set('Accept', 'application/json')
        .send(options.body);
      if (self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (error, response) {
        if (error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory params - context or ruleType or ruleId ' +
        'or body.rule_display not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/**
 * options = {
 *   context: '',   // Mandatory
 *   ruleType: '',  // Mandatory
 *   body: {
 *     ruleid: '',  // Mandatory
 *     scope: '',   // Mandatory
 *     entities: [  // Min. length 1
 *       {
 *         id:'',   // eg. item code
 *         type:''  // eg. item/folder/product
 *       },
 *       ...],
 *     user: ['extuserid1','extuserid2', ...],
 *     rule_data_individual: {},
 *     rule_data_common: {},
 *     rule_display: {}
 *   }
 * }
 */
function createRule(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if (err) { dfd.reject(err); }
  else {
    if (options && options.context && options.ruleType && options.body) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.RULES_API_URLS.rules;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        context: encodeURIComponent(options.context),
        ruleType: options.ruleType
      });

      // Setup request with URL and Params
      var requestAPI = request.post(url)
        .set('Content-Type', 'application/json')
        .set('Accept', 'application/json')
        .send(options.body);
      if (self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (error, response) {
        if (error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory params - context or ruleType or body' +
        ' not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/**
 * options = {
 *   context: '',   // Mandatory
 *   ruleType: '',  // Mandatory
 *   ruleId: '',     // Mandatory
 *   body: {
 *     scope: '',   // Mandatory
 *     entities: [  // Min. length 1
 *       {
 *         id:'',   // eg. item code
 *         type:''  // eg. item/folder/product
 *       },
 *       ...],
 *     user: ['extuserid1','extuserid2', ...],
 *     rule_data_individual: {}, // Optional
 *     rule_data_common: {}      // Optional
 *   }
 * }
 */
function updateRule(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if (err) { dfd.reject(err); }
  else {
    if (options && options.context && options.ruleType && options.ruleId && options.body) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.RULES_API_URLS.particularRule;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        context: encodeURIComponent(options.context),
        ruleType: options.ruleType,
        ruleId: options.ruleId
      });

      // Setup request with URL and Params
      var requestAPI = request.put(url)
        .set('Content-Type', 'application/json')
        .set('Accept', 'application/json')
        .send(options.body);
      if (self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (error, response) {
        if (error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory params - context or ruleType or ruleId or body ' +
        'not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/**
 * options = {
 *   context: '',   // Mandatory
 *   ruleType: '',  // Mandatory
 *   ruleId: ''     // Mandatory
 * }
 */
function deleteRule(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if (err) { dfd.reject(err); }
  else {
    if (options && options.context && options.ruleType && options.ruleId) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.RULES_API_URLS.particularRule;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        context: encodeURIComponent(options.context),
        ruleType: options.ruleType,
        ruleId: options.ruleId
      });

      // Setup request with URL and Params
      var requestAPI = request.delete(url);

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
      if (self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      requestAPI.end(function (error, response) {
        if (error) {
          err = {};
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else {
          dfd.resolve(response.body);
        }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory params - context or ruleType or ruleId not found' +
        ' in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

},{"../../helpers":3,"q":90,"superagent":133}],28:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/
/***********************************************************
 * comproDLS SDK sisevents Adaptor
 * Functions for calling sisevents.
 ************************************************************/
/*********************************
 * Setting Up Module Entry Point
 **********************************/

var request = require('superagent');
var q = require('q');
var _und = require('underscore');

var helpers = require('../../helpers');
var DLSError = helpers.errors.DLSError;

module.exports = sisevents;

/*********************************
 * Public Function definitions
 **********************************/
function sisevents() {
    return {
		"postSISEvent": postSISEvent.bind(this)
    };
}

//options = {
//  "actor": {
//    "uuid": "string", // userid of user posting statements
//  },
//  "target": {
//    "uuid": "string", // userid of user posting statement
//  },
//  "product": {
//    "uuid": "string", // productid
//    "code": "string", // (optional)
//  },
//  "entities": [{
//    "verb": "string", // ['plan-responsibility-signoff', 'plan-status', 'plan-comment', 'item-responsibility', 'item-signoff', 'item-comment', 'item-assets', 'item-status'] currently only one verb is supported
//    "task": "string", // task-code of resource
//    "model": "string", // (optional) model hierarchy of resource if available
//    [verb] : {
//		"value": "string"
//	  }
//  }]
//};

function postSISEvent(options) {
	var self = this;

    //Initializing promise
    var dfd = q.defer();
    //Validations
    var err = {}, url;

    if(_und.isArray(options.entities)) {
        err = helpers.validations.isAuthenticated(self.orgId, self.token);
        if (err) {
            dfd.reject(err);
        } else {

            url = self.config.DEFAULT_HOSTS['SISEVENTS'] +
                  self.config.SISEVENTS_API_URLS.postMultiSISEvent;
            url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

            //Passed all validations, Construct API url

            var params = options;

            //Setup request with URL and Params
            var requestAPI = request.post(url).send(params);

            //Setup token in Authorization header
            requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
            if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

            //Call Product Timespent Api
            requestAPI.end(function(err, response) {
                if (err) {
                    err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
                    dfd.reject(err);
                } else {
                    dfd.resolve(response.body);
                }
            });
        }
    } else {
        err.message = err.description = 'Mandatory parameter entities not present in options';
        err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
        dfd.reject(err);
    }

    return dfd.promise;
}

},{"../../helpers":3,"q":90,"superagent":133,"underscore":137}],29:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

/***********************************************************
 * comproDLS SDK AUTH API Adaptor
 * Functions for calling AUTH API.
 ************************************************************/

var q = require('q');
var request = require('superagent');

var helpers = require('../../helpers');

var DLSError = helpers.errors.DLSError;

/*********************************
 * Setting Up Module Entry Point
 **********************************/
module.exports = spaces;

//Auth Adaptor Contsructor
function spaces(accountId) {
  this.accountId = accountId;
  return {
    getUserSpaces: getUserSpaces.bind(this),
    validateSpaceCode: validateSpaceCode.bind(this),
    validateClassCode: validateClassCode.bind(this),
    generateSpaceCode: generateSpaceCode.bind(this),
    changeSpaceCode: changeSpaceCode.bind(this),
    joinInstituteSpace: joinInstituteSpace.bind(this),
    provisionSpacesToStudent: provisionSpacesToStudent.bind(this),
    provisionSpacesToTeacher: provisionSpacesToTeacher.bind(this),
    provisionBulkSpaces: provisionBulkSpaces.bind(this),
    shadowProvision: shadowProvision.bind(this),
    entitleUserToProduct: entitleUserToProduct.bind(this),
    unentitleUserToProduct: unentitleUserToProduct.bind(this),
    revokeMicroEntitlementOfAUser: revokeMicroEntitlementOfAUser.bind(this),
    microEntitleUserToProduct: microEntitleUserToProduct.bind(this),
    bulkMicroEntitleProductToUser: bulkMicroEntitleProductToUser.bind(this),
    enrollUserInClass: enrollUserInClass.bind(this),
    getExtProduct: getExtProduct.bind(this),
    getSpaceDetails: getSpaceDetails.bind(this),
    updateUserInformation: updateUserInformation.bind(this),
    getInvitationsByEmail: getInvitationsByEmail.bind(this),
    updateInstituteTitle: updateInstituteTitle.bind(this)
  };
}

/*options = {
  extuserid: 'string',
  spaceRole: 'string',   //optional
  spaceType: 'string',   //optional
  spaceOrgContext: 'string',  //optional
  details: boolean, //optional
  cursor: 'string'   //optional
}*/
function getUserSpaces(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations

  if(options && options.extuserid) {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
              self.config.AUTH_API_URLS.getUserSpaces;
    url = helpers.api.constructAPIUrl(url, {
      accountid: self.accountId, extuserid: options.extuserid
    });

    var params = {};
    if(options.spaceRole) { params.spaceRole = options.spaceRole; }
    if(options.spaceType) { params.spaceType = options.spaceType; }
    if(options.spaceOrgContext) { params.spaceOrgContext = options.spaceOrgContext; }
    if(options.details) { params.details = options.details; }
    if(options.cursor) { params.cursor = options.cursor; }

    // Setup request with URL and Params
    var requestAPI = request.get(url).query(params);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } else {
    var err = {};
    err.message = err.description = 'extuserid not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/*options = {
  spaceCodeBody : {
      space_code: 'string'
  }
}*/
function validateSpaceCode(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  if(options && options.spaceCodeBody && options.spaceCodeBody.space_code) {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
                               self.config.AUTH_API_URLS.validateSpaceCode;
    url = helpers.api.constructAPIUrl(url, { accountid : self.accountId });

    // Setup request with URL and Params
    var requestAPI = request.post(url)
                     .set('Content-Type', 'application/json')
                     .set('Accept', 'application/json')
                     .send(options.spaceCodeBody);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } else {
    var err = {};
    err.message = err.description = 'spaceCodeBody or space_code not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/*options = {
  classCodeBody : {
      class_code: 'string'
  },
  details: boolean    // optional
}*/
function validateClassCode(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  if(options && options.classCodeBody && options.classCodeBody.class_code) {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
                               self.config.AUTH_API_URLS.validateClassCode;
    url = helpers.api.constructAPIUrl(url, { accountid : self.accountId });

    var queryParams = {};
    if (options.details) {
      queryParams.details = options.details;
    }

    // Setup request with URL and Params
    var requestAPI = request.post(url)
                     .set('Content-Type', 'application/json')
                     .set('Accept', 'application/json')
                     .query(queryParams)
                     .send(options.classCodeBody);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } else {
    var err = {};
    err.message = err.description = 'classCodeBody or class_code not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}
/* options = {
  "ignore_words": ["string"] //optional, This is the array of all bad words to be ignored.
}*/
function generateSpaceCode(options) {
  var self = this;

  // Initializing promise
  var dfd = q.defer();

  // Passed all validations, Contruct API url
  var url = self.config.DEFAULT_HOSTS.AUTH +
                              self.config.AUTH_API_URLS.generateSpaceCode;
  url = helpers.api.constructAPIUrl(url, { accountid : self.accountId });

  var bodyParams = {};
  if(options.ignore_words) { bodyParams.ignore_words = options.ignore_words }
  // Setup request with URL and Params
  var requestAPI = request.post(url)
                    .set('Content-Type', 'application/json')
                    .set('Accept', 'application/json')
                    .send(bodyParams);
  if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

  requestAPI.end(function(error, response) {
    if(error) {
      err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
      dfd.reject(err);
    }
    else { dfd.resolve(response); }
  });

  return dfd.promise;
}

/* options = {
  "ext_user_id": "string", //mandatory, This is the actor to change the spacecode.
  "ignore_words": ["string"] //optional, This is the array of all bad words to be ignored.
  "spacecode": "string" //mandatory, This is the spacecode that needs to be changed.
}*/
function changeSpaceCode(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  if(options && options.ext_user_id && options.spacecode) {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
                               self.config.AUTH_API_URLS.changeSpaceCode;
    url = helpers.api.constructAPIUrl(url, { accountid : self.accountId, spacecode: options.spacecode });
    var bodyParams = { ext_user_id: options.ext_user_id };
    if(options.ignore_words) { bodyParams.ignore_words = options.ignore_words }
    // Setup request with URL and Params
    var requestAPI = request.put(url)
                     .set('Content-Type', 'application/json')
                     .set('Accept', 'application/json')
                     .send(bodyParams);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response); }
    });
  } else {
    var err = {};
    err.message = err.description = 'Mandatory parameter options, ext_user_id or spacecode, not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/*
  ext_user_id: 'string',
  ext_role: 'string',
  space_code: 'string',
  ext_email: 'string',       //optional
  ext_first_name: 'string',  //optional
  ext_last_name: 'string,    //optional
  ref_id: 'string'           //optional
*/
function joinInstituteSpace(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  if(options && options.ext_user_id &&
      options.ext_role && options.space_code)
  {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
                               self.config.AUTH_API_URLS.joinInstituteSpace;
    url = helpers.api.constructAPIUrl(url, { accountid : self.accountId });

    // Setup request with URL and Params
    var requestAPI = request.post(url)
                     .set('Content-Type', 'application/json')
                     .set('Accept', 'application/json')
                     .send(options);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } else {
    var err = {};
    err.message = err.description = 'ext_user_id or ext_role or space_code not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/*options = {
    ext_user_id: 'string',
    ext_actor_id: 'string', (optional)
    ext_role: 'string',
    ext_first_name: 'string',
    ext_last_name: 'string',
    ext_email: 'string',
    ref_id: 'string', (optional)
    class_code: 'string' (optional)
    products: [{
      productcode: 'string',
      ext_product_id: 'string',
      ext_product_meta: {
        startdate: 'string',
        enddate: 'string',
        ...
      }
    }]
}*/
function provisionSpacesToStudent(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = {};
  if(options && options.ext_user_id && options.ext_role) {

    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
                              self.config.AUTH_API_URLS.provisionSpacesToStudent;
    url = helpers.api.constructAPIUrl(url, { accountId : self.accountId });

    // Setup request with URL and Params
    var requestAPI = request.post(url)
                    .set('Content-Type', 'application/json')
                    .set('Accept', 'application/json')
                    .send(options);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err.message = err.description = 'ext_user_id or ext_role not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/**
 * This function is used to provision spaces to a user with ext_role as teacher.
 * options = {
 *    ext_user_id: "string",
 *    ext_role: "string",
 *    ext_first_name: "string",
 *    ext_last_name: "string",
 *    ext_email: "string",
 *    ref_id: "string"
 * };
 */
function provisionSpacesToTeacher(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  if(options && options.ext_user_id && options.ext_role)
  {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
                               self.config.AUTH_API_URLS.provisionSpacesToTeacher;
    url = helpers.api.constructAPIUrl(url, { accountId : self.accountId });

    // Setup request with URL and Params
    var requestAPI = request.post(url)
                     .set('Content-Type', 'application/json')
                     .set('Accept', 'application/json')
                     .send(options);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } else {
    var err = {};
    err.message = err.description = 'Mandatory parameters [rxt_user_id, ext_role] not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/**
 * options = {
    "space_title": "string",          // mandatory
    "ext_data": {}                    //optional, external data(e.g. jobdata etc.)
		"users": [												// mandatory, min: 1, max: 200
			{
				"ext_user_id": "string",			// mandatory (it must be unique within users array)
				"ext_parent_id": "string",
				"ext_username": "string",
				"ext_role": "student",				// mandatory
				"ext_email": "string",
				"ext_first_name": "string",   // mandatory
				"ext_last_name": "string",    // mandatory
				"address": "string",
				"rowId": "string",						// mandatory (it must be unique within users array)
				"classes": [									// optional, min: 1, max: 3
					{
						"classid": "string",      // either of classid or class_code them must be
						"class_code": "string"    // present, classid is preferred
					}
        ],
        "products": [									// optional, min: 1
					{
						"productcode": "string",  // mandatory
						"ext_product_meta": {
              "startdate": "epoch",
              "enddate": "epoch"      // mandatory
            }
            "ext_data" : {}           // optional, external data (e.g., ref_id, ...)
					}
				]
			}
		]
	}
 *
 */
function provisionBulkSpaces(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.users && options.space_title) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
      self.config.AUTH_API_URLS.provisionBulkSpaces;
      url = helpers.api.constructAPIUrl(url, { orgId : self.orgId });

      // Setup request with URL and Params
      var requestAPI = request.post(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
			.send(options);

      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
			requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

			requestAPI.end(function(error, response) {
				if(error) {
					err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
					dfd.reject(err);
				}
				else { dfd.resolve(response.body); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory parameters: space_title or users not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
	}

	return dfd.promise;
}

/**
 * options = {
 *  ext_user_id: 'string',      // mandatory
 * "ext_role": "string",        // mandatory
 * "ext_first_name": "string",
 * "ext_last_name": "string",
 * "ext_email": "string",
 * "address": {
 *  "country": "string"
 * },
 * "ref_id": "string",
 * "ext_classid" : "string",
 * "ext_class_meta" :
 *  {
 *    "description": "string",
 *    "ext_data": {},
 *    "title": "string",       // mandatory
 *    "startdate": <epoch>,   // mandatory
 *    "enddate": <epoch>      // mandatory
 *  }
 * }
 **/
function shadowProvision(options) {
  var self = this;
  //Initializing promise
  var dfd = q.defer(), err = {};
  //Validations
  if (options && options.ext_user_id && options.ext_role) {
    //Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.shadowProvision;
    url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

    // Setup request with URL and Params
    var requestAPI = request.post(url)
    .set('Content-Type', 'application/json')
    .set('Accept', 'application/json')
    .send(options);
    if (self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (err, response) {
      if (err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err.message = err.description = 'Mandatory parameters: ext_user_id or ext_role not ' +
      'found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/*options = {
    ext_user_id: 'string',
    ext_actor_id: 'string',
    ext_role: 'string',
    ref_id: 'string', (optional)
    productcode: 'string',
    ext_product_id: 'string',
    ext_product_meta: {
      startdate: 'string',
      enddate: 'string',
      ...
    },
    audit: boolean
}*/
function entitleUserToProduct(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  if(options && options.ext_user_id &&
      options.ext_role && (options.productcode || options.ext_product_id))
  {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
                               self.config.AUTH_API_URLS.entitleUserToProduct;
    url = helpers.api.constructAPIUrl(url, { accountId : self.accountId });

    // Setup request with URL and Params
    var requestAPI = request.post(url)
                     .set('Content-Type', 'application/json')
                     .set('Accept', 'application/json')
                     .send(options);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } else {
    var err = {};
    err.description = 'Missing mandatory keys in request options. \'ext_user_id\', \'ext_role\' and ' +
                      'either of \'ext_product_id\' or \'productcode\' must be present.'
    err.message = err.description;
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/*options = {
    ext_user_id: 'string',
    ext_actor_id: 'string',
    productcode: 'string',
    audit: 'boolean'
}*/
function unentitleUserToProduct(options) {
  var self = this;
  var dfd = q.defer();

  if (options && options.ext_user_id && options.productcode && options.ext_actor_id
    && (options.audit !== undefined)) {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.entitleUserToProduct;
    url = helpers.api.constructAPIUrl(url, { accountId : self.accountId });

    // Setup request with URL and Params
    var requestAPI = request.delete(url)
                    .set('Content-Type', 'application/json')
                    .set('Accept', 'application/json')
                    .send(options);

    if (self.traceid) {
      requestAPI.set('X-Amzn-Trace-Id', self.traceid);
    }

    requestAPI.end(function(error, response) {
      if (error) {
        var err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else {
        dfd.resolve(response.body);
      }
    });
  } else {
    var err = {};
    err.message = err.description = 'Missing mandatory keys in request options.' +
                  ' \'ext_user_id\', \'ext_actor_id\', \'productcode\' and \'audit\'' +
                  ' must be present';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);

    dfd.reject(err);
  }

  return dfd.promise;
}

/* This function calls the ComproDLS API to micro entitle user to a product.
options = {
    "ext_user_id": "string",    // Mandatory
    "ext_actor_id": "string",   // Optional
    "feature_key": "string",    // Mandatory
    "feature_id": "string",     // Mandatory
    "context": "string",        // Mandatory
    "data": {},                 // Optional
    "productcode": "string",    // one of productcode and ext_product_id is mandatory
    "ext_product_id": "string",
    "ext_entitlement_meta": {    //Optional
      "startdate": "epoch",
      "enddate": "epoch"       //mandatory, if ext_entitlement_meta provided.
    },
    "audit": boolean            // Optional
}*/
function microEntitleUserToProduct(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var bValidOptions = true;
  var err = {
    description: '',
    message: ''
  };

  if (!(options && options.ext_user_id && options.context && options.feature_key &&
    options.feature_id)) {
    bValidOptions = false;
    err.description = 'ext_user_id or context or feature_key or feature_id ' +
      'not found in request options. ';
  }

  if (bValidOptions && (options.productcode || options.ext_product_id)) {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
                               self.config.AUTH_API_URLS.microEntitleUserToProduct;
    url = helpers.api.constructAPIUrl(url, { accountId : self.accountId });

    // Setup request with URL and Params
    var requestAPI = request.post(url)
                     .set('Content-Type', 'application/json')
                     .set('Accept', 'application/json')
                     .send(options);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } else {
    if(!(options.productcode || options.ext_product_id)) {
      err.description += 'Either of ext_product_id or productcode must be ' +
                                      'present in request options.';
    }
    err.message = err.description;
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/* This function calls the ComproDLS API to micro entitle user to product.
options = {
    "micro-entitlements": [{    // Mandatory, Min: 1
    "ext_user_id": "string",    // Mandatory

    "productcode": "string",
    "ext_product_id": "string",

    "context": "string",
    "feature_key": "string",
    "feature_id": "string",,
    "data": {},
    "ext_entitlement_meta": {
      "startdate": 0,
      "enddate": 0
    },

    "ext_actor_id": "string",        // Mandatory if 'audit' is true
    "audit": true
    },
  …
  ]
}
*/
function bulkMicroEntitleProductToUser(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  if(options && options['micro-entitlements'])
  {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
                               self.config.AUTH_API_URLS.bulkMicroEntitleProductToUser;
    url = helpers.api.constructAPIUrl(url, { accountId : self.accountId });

    // Setup request with URL and Params
    var requestAPI = request.post(url)
                     .set('Content-Type', 'application/json')
                     .set('Accept', 'application/json')
                     .send(options);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } else {
    var err = {};
    err.description = 'Missing mandatory keys in request options.' +
      ' \'micro-entitlements\' must be present.'
    err.message = err.description;
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/* This function calls the ComproDLS API to revoke micro entitlement of a user.
options = {
    "ext_user_id": "string",    // Mandatory
    "ext_actor_id": "string",   // Mandatory
    "feature_key": "string",    // Mandatory
    "context": "string",        // Mandatory
    "productcode": "string",    // one of productcode and ext_product_id is mandatory
    "ext_product_id": "string",
    "audit": boolean            // Mandatory
}*/
function revokeMicroEntitlementOfAUser(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = {
    description: '',
    message: ''
  };

  if((options && options.ext_user_id && options.context && options.feature_key &&
    options.ext_actor_id && (options.audit !== undefined) &&
    (options.productcode || options.ext_product_id))) {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
              self.config.AUTH_API_URLS.microEntitleUserToProduct;
    url = helpers.api.constructAPIUrl(url, { accountId : self.accountId });

    // Setup request with URL and Params
    var requestAPI = request.delete(url)
                    .set('Content-Type', 'application/json')
                    .set('Accept', 'application/json')
                    .send(options);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err.description = 'ext_user_id or context or feature_key or ext_actor_id or audit field ' +
                      'not found or is empty in request options. Either productcode or ' +
                      'ext_product_id must be provided.';
    err.message = err.description;
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/*options = {
    ext_product_id: 'string'
}*/
function getExtProduct(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  if(options && options.ext_product_id)
  {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
                               self.config.AUTH_API_URLS.getExtProductAPI;
    url = helpers.api.constructAPIUrl(url, { accountId : self.accountId, extProductId: options.ext_product_id});

    // Setup request with URL and Params
    var requestAPI = request.get(url);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } else {
    var err = {};
    err.message = err.description = 'ext_product_id not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/*options = {
    spacekey: 'string'
}*/
function getSpaceDetails(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  if(options && options.spacekey) {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.getSpaceDetails;
    url = helpers.api.constructAPIUrl(url, { accountId : self.accountId, spacekey: options.spacekey});

    var params = { orgid: self.orgId };

    // Setup request with URL and Params
    var requestAPI = request.get(url).query(params);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    // Setup token in Authorization header
    requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } else {
    var err = {};
    err.message = err.description = 'spacekey not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/*options = {
    ext_user_id: 'string',
    ext_role: 'string',
    ext_first_name: 'string',
    ext_last_name: 'string',
    ext_email: 'string',
    ref_id: 'string', (optional)
    class_code: 'string'
}*/
function enrollUserInClass(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  if(options && options.ext_user_id &&
      options.ext_role && options.class_code)
  {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
                               self.config.AUTH_API_URLS.enrollUserInClass;
    url = helpers.api.constructAPIUrl(url, { accountId : self.accountId });

    // Setup request with URL and Params
    var requestAPI = request.post(url)
                     .set('Content-Type', 'application/json')
                     .set('Accept', 'application/json')
                     .send(options);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } else {
    var err = {};
    err.message = err.description = 'ext_user_id or ext_role or class_code not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/**
 * This function calls the ComproDLS API to update user information.
 * options = {
 *    "ext_user_id": "string",
 *    "ref_id": "string",           // optional
 *    "ext_email": "string",        // optional
 *    "ext_first_name": "string",   // optional
 *    "ext_last_name": "string"     // optional
 * };
 */
function updateUserInformation(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer(), err = {};

  if(options && options.ext_user_id)
  {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
                               self.config.AUTH_API_URLS.updateUserInformation;
    url = helpers.api.constructAPIUrl(url, { accountId : self.accountId });
    var bodyParams = {
      ext_user_id: options.ext_user_id
    };
    if(options.ref_id) { bodyParams.ref_id = options.ref_id; }
    if(options.ext_email) { bodyParams.ext_email = options.ext_email; }
    if(options.ext_first_name) { bodyParams.ext_first_name = options.ext_first_name; }
    if(options.ext_last_name) { bodyParams.ext_last_name = options.ext_last_name; }
    if(options.address) { bodyParams.address = options.address; }
    // Setup request with URL and Params
    var requestAPI = request.put(url)
                     .set('Content-Type', 'application/json')
                     .set('Accept', 'application/json')
                     .send(bodyParams);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } else {
    err.message = err.description = 'Mandatory parameters not found in request options:' +
                                    ' ["ext_user_id"]';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

/* options = {
   "email": "string", // required
   "status " : "string", // optional
  };
*/
function getInvitationsByEmail(options) {
	var self = this;
	// Initializing promise
	var dfd = q.defer();
	var err = {};
	if (options && options.email) {

	  // Passed all validations, Contruct API url
	  var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.getInvitationsByEmail;
	  url = helpers.api.constructAPIUrl(url, { accountid: self.accountId });

	  var queryParam = { email: options.email };
	  if (options.status) { queryParam.status = options.status; }

	  // Setup request with URL and Params
    var requestAPI = request.get(url).query(queryParam);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

	  requestAPI.end(function (error, response) {
	  	if (error) {
		  err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
		  dfd.reject(err);
		}
		else { dfd.resolve(response.body); }
	  });
	}
	else {
	  err.message = err.description = 'email not found in request options.';
	  err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
	  dfd.reject(err);
	}
	return dfd.promise;
}

/**
 * This API is used to update an institute's space title
 * options = {
 *   space_code: "",       // Mandatory, space code of institute whose title is to be updated
 *   body : {
 *     ext_actor_id: "",   // Mandatory
 *     data: {
 *       space_title: ""
 *     }
 *   }
 * }
 */
function updateInstituteTitle(options){
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = {};
  if (options && options.space_code && options.body && options.body.ext_actor_id ) {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.updateInstituteTitle;
    url = helpers.api.constructAPIUrl(url,
      { accountId: self.accountId, instituteSpaceCode: options.space_code });

    // Setup request with URL and Params
    var requestAPI = request.put(url)
                    .set('Content-Type', 'application/json')
                    .set('Accept', 'application/json')
                    .send(options.body);
    if (self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (error, response) {
      if (error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err.message = err.description = 'space_code or ext_actor_id not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

},{"../../helpers":3,"q":90,"superagent":133}],30:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

/***********************************************************
 * comproDLS SDK AUTH API Adaptor
 * Functions for calling AUTH API.
 ************************************************************/

var q = require('q');
var request = require('superagent');

var helpers = require('../../helpers');

var DLSError = helpers.errors.DLSError;

/*********************************
 * Setting Up Module Entry Point
 **********************************/
module.exports = superuser;

//Superuser Adaptor Contsructor
function superuser(accountId) {
    this.accountId = accountId;
    return {
      getAllInstitutions: getAllInstitutions.bind(this),
      getInstitution: getInstitution.bind(this),
      provisionSpacesToSuperAdmin: provisionSpacesToSuperAdmin.bind(this)
    };
  }
  
  /*options = {
    "lookup": "string",
    "limit": "integer",
    "cursor": "object"
  }*/
function getAllInstitutions(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  var url = self.config.DEFAULT_HOSTS.AUTH +
            self.config.AUTH_API_URLS.getAllInstitutions;
  url = helpers.api.constructAPIUrl(url, { accountid : self.accountId });

  var params = {};
  if(options) {
    if(options.lookup) { params.lookup = options.lookup; }
    if(options.cursor) { params.cursor = options.cursor; }
    if(options.limit) { params.limit = options.limit; }
  }

  //Setup request with URL and Params
  var requestAPI = request.get(url).query(params);
  if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

  requestAPI.end(function(err, response) {
    if(err) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
        dfd.reject(err);
    } else {
        dfd.resolve(response.body);
    }
  });

  return dfd.promise;
}
  
  /** This function gets a particular Instituion using the unique identifier (space_code)
   *  options = { "spacecode" : "string" }
   */
function getInstitution(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  
  // Validations
  if(options && options.spacecode) {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.getInstitution;
    url = helpers.api.constructAPIUrl(url, {
      accountid: self.accountId, spacecode: options.spacecode
    });

    // Setup request with URL and Params
    var requestAPI = request.get(url);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } 
  else {
    var err = {};
    err.message = err.description = 'spacecode not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/**
 * This will provision space to the super admin in shared/institutional org.
 * Note: The super admin can only be provisioned in one (shared/institutional) org at a time.
 *
 * @param {Object} options {
    "ext_user_id": "string",
    "ext_role": "string",
    "ext_email": "string",
    "ext_first_name": "string",
    "ext_last_name": "string",
    "address": { "country": "string" }   // optional
    "space_code": "string",              // optional, to provision the superadmin in institutional space.
    "private_space": boolean             // optional, to provision the superadmin in shared space.
  }
 * @return {Promise} Promise.resolve({ entities:[ { spaces object }], count: entities.length })
 */
function provisionSpacesToSuperAdmin(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  if(options && options.ext_user_id &&
      options.ext_role && options.ext_email &&
      options.ext_first_name && options.ext_last_name)
  {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
              self.config.AUTH_API_URLS.provisionSpacesToSuperAdmin;
    url = helpers.api.constructAPIUrl(url, { accountid : self.accountId });

    // Setup request with URL and Params
    var requestAPI = request.post(url)
    .set('Content-Type', 'application/json')
    .set('Accept', 'application/json')
    .send(options);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    var err = {};
    err.message = err.description = 'Missing required input data';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

},{"../../helpers":3,"q":90,"superagent":133}],31:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

/***********************************************************
 * comproDLS SDK AUTH API Adaptor
 * Functions for calling AUTH API.
 ************************************************************/

var q = require('q');
var request = require('superagent');
var helpers = require('../../helpers');

var DLSError = helpers.errors.DLSError;

/*********************************
 * Setting Up Module Entry Point
 **********************************/
module.exports = taxonomy;
//Taxonomy Adaptor Contsructor
function taxonomy() {
  return {
    associateTagsWithEntity: associateTagsWithEntity.bind(this),
    createTags: createTags.bind(this),
    updateTags: updateTags.bind(this),
    deleteTags: deleteTags.bind(this),
    getTag: getTag.bind(this),
    getTagHierarchy: getTagHierarchy.bind(this),
    getAllTags: getAllTags.bind(this)
  };
}

/*********************************
 * Public Function definitions
 **********************************/

/**
 * options = {
 * entity_type: 'type of entity',
 * entity_id: 'id of the entity',
 * tags: 'array of tags for association with entity'
 */
function associateTagsWithEntity(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();

  //Validations
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if (err) {
    dfd.reject(err);
  } else {
    if (options && options.entity_type && options.entity_id && options.tags) {
      //Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH +
        self.config.TAXONOMY_API_URLS.associateTagsWithEntity;
      url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });

      //Setup request with URL and Params
      var requestAPI = request.put(url).send(options);

      if (self.traceid) {
        requestAPI.set('X-Amzn-Trace-Id', self.traceid);
      }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function(err, response) {
        if (err) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
          dfd.reject(err);
        } else {
          dfd.resolve(response.body);
        }
      });
    } else {
      err = {};
      err.message = err.description = 'entity_id or entity_type or tags not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }

  return dfd.promise;
}


/*
  options = {
    context: "string", //mandatory
    taxonomyid: "string", //mandatory
    body: {
      tags: [{
        "tagid": "",
        "tagname": "",
        "tag_data": {} // optional
      }]
    }
  }
*/
function createTags(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.context && options.taxonomyid && options.body && options.body.tags && (options.body.tags.length > 0)) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.TAXONOMY_API_URLS.tags;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        context: encodeURIComponent(options.context),
        taxonomyId: options.taxonomyid
      });

      var requestAPI = request.post(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .send(options.body);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory param - context or taxonomyid or body.tags(min. 1 tag) ' +
                                      'not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

 /* options = {
    "context": "string", //mandatory
    "taxonomyid": "string" //mandatory
    "body": {
      "tagid": "string", //mandatory
      "tagname": "string",
      "tag_data": {}
    }
  };
*/
function updateTags(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if(options && options.context && options.taxonomyid && options.body && options.body.tagid) {

      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.TAXONOMY_API_URLS.tags;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        context: encodeURIComponent(options.context),
        taxonomyId: options.taxonomyid
      });

      // Setup request with URL and Params
      var requestAPI = request.put(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .send(options.body);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function (error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    }
    else {
      err = {};
      err.message = err.description = 'Mandatory params - context or taxonomyid or tagid not found in ' +
                                      'request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/* options = {
    "context": "string", // required
    "taxonomyid" : "string", // required
    "tagid" : "string"
  };
*/
function deleteTags(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();

  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  else {
    if (options && options.context && options.taxonomyid) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.TAXONOMY_API_URLS.tags;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        context: encodeURIComponent(options.context),
        taxonomyId: options.taxonomyid
      });

      var queryParam = {};
      if(options.tagid) { queryParam.tagid = options.tagid; }

      // Setup request with URL and Params
      var requestAPI = request.delete(url).query(queryParam);

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      requestAPI.end(function (error, response) {
        if (error) {
          err = {};
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else {
          dfd.resolve(response.body);
        }
      });
    }
    else {
      err = {};
      err.message = err.description = 'context or taxonomyid or tagid not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*
  options = {
    context: "string", //mandatory
    taxonomyid: "string", //mandatory
    tagid: "string" //mandatory
  }
*/
function getTag(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  // Validations
  else {
    if(options && options.context && options.taxonomyid && options.tagid) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.TAXONOMY_API_URLS.tags;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        context: encodeURIComponent(options.context),
        taxonomyId: options.taxonomyid
      });

      // Setup request with URL and Params
      var queryParam = {
        hierarchy: false,
        tagid: options.tagid
      };

      var requestAPI = request.get(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .query(queryParam);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory param - context or taxonomyid or tagid not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*
  options = {
    context: "string", //mandatory
    taxonomyid: "string", //mandatory
    tagid: "string" //mandatory
  }
*/
function getTagHierarchy(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  // Validations
  else {
    if(options && options.context && options.taxonomyid && options.tagid) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.TAXONOMY_API_URLS.tags;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        context: encodeURIComponent(options.context),
        taxonomyId: options.taxonomyid
      });

      // Setup request with URL and Params
      var queryParam = {
        hierarchy: true,
        tagid: options.tagid
      };

      var requestAPI = request.get(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .query(queryParam);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory param - context or taxonomyid or tagid not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

/*
  options = {
    context: "string", //mandatory
    taxonomyid: "string" //mandatory
  }
*/
function getAllTags(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = helpers.validations.isAuthenticated(self.orgId, self.token);
  if(err) { dfd.reject(err); }
  // Validations
  else {
    if(options && options.context && options.taxonomyid) {
      // Passed all validations, Contruct API url
      var url = self.config.DEFAULT_HOSTS.AUTH + self.config.TAXONOMY_API_URLS.tags;
      url = helpers.api.constructAPIUrl(url, {
        orgId: self.orgId,
        context: encodeURIComponent(options.context),
        taxonomyId: options.taxonomyid
      });

      // Setup request with URL and Params
      var queryParam = {
        hierarchy: true
      };

      var requestAPI = request.get(url)
      .set('Content-Type', 'application/json')
      .set('Accept', 'application/json')
      .query(queryParam);
      if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

      //Setup token in Authorization header
      requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);

      requestAPI.end(function(error, response) {
        if(error) {
          err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
          dfd.reject(err);
        }
        else { dfd.resolve(response.body); }
      });
    } else {
      err = {};
      err.message = err.description = 'Mandatory param - context or taxonomyid not found in request options.';
      err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
      dfd.reject(err);
    }
  }
  return dfd.promise;
}

},{"../../helpers":3,"q":90,"superagent":133}],32:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/
/***********************************************************
 * comproDLS SDK Open Access Manager Module
 * Provides Open Access functions for the SDK
 ************************************************************/
var q = require('q');
var request = require('superagent');
var helpers = require('./../../helpers');
var DLSError = helpers.errors.DLSError;

/*************************************
 * Setting up Exports/Public functions
 *************************************/

module.exports = workflows;

//Workflows Adaptor Constructor
function workflows(accountId) {
  this.accountId = accountId;
  return {
    createWorkflow: createWorkflow.bind(this),
    getAllWorkflow: getAllWorkflow.bind(this),
    getAllWorkflowOfAUser: getAllWorkflowOfAUser.bind(this),
    getAWorkflow: getAWorkflow.bind(this),
    acceptAWorkflow: acceptAWorkflow.bind(this),
    processAWorkflow: processAWorkflow.bind(this),
    revokeAWorkflow: revokeAWorkflow.bind(this),
    completeAWorkflow: completeAWorkflow.bind(this),
    updateWorkflowRequest: updateWorkflowRequest.bind(this)
  }
}

/*********************************
 * Public Function definitions
 **********************************/
/**
 * options={
    "ext_user_id": "string", //mandatory
    "workflow_type": "institution_request", //mandatory
    "institution_request": {
      "address": {
        "city": "string",
        "country": "string",
        "street1": "string",
        "street2": "string",
        "street3": "string",
        "house_no": "string",
        "post_code": "string"
      },
      "display_name": "string",
      "school_key": "string"
    }
  }
 */
function createWorkflow(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations

  if(options && options.ext_user_id && options.workflow_type) {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
              self.config.AUTH_API_URLS.workflows;
    url = helpers.api.constructAPIUrl(url, {
      accountid: self.accountId
    });

    // Setup request with URL and Params
    var requestAPI = request.post(url)
    .set('Content-Type', 'application/json')
    .set('Accept', 'application/json')
    .send(options)

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  } else {
    var err = {};
    err.message = err.description = 'ext_user_id or workflow_type not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/* options = {
    "workflow_type": "string", // required
    "status" : "string", // required
    "start": "string" //epoch
    "end": "string" //epoch
    "cursor" : "string"
  };
*/
function getAllWorkflow(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  if(options && options.workflow_type && options.status ) {

    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.workflows;
    url = helpers.api.constructAPIUrl(url,{ accountid: self.accountId });
    var queryParams = { workflow_type: options.workflow_type, status: options.status };
    if(options.start) { queryParams.start =  options.start; }
    if(options.end) { queryParams.end =  options.end; }
    if(options.cursor) { queryParams.cursor =  options.cursor; }


    // Setup request with URL and Params
    var requestAPI = request.get(url).query(queryParams);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Mandatory params - workflow_type, status not found in ' +
                                    'request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/* options = {
    "workflow_type": "string", // required
    "status" : "string", // required
    "ext_user_id": "string" //required
    "start": "string" //epoch
    "end": "string" //epoch
    "cursor" : "string"
  };
*/
function getAllWorkflowOfAUser(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  if(options && options.workflow_type && options.status && options.ext_user_id) {

    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.getAllWorkflowOfAUser;
    url = helpers.api.constructAPIUrl(url,{ accountid: self.accountId });
    var queryParams = { workflow_type: options.workflow_type, status: options.status, ext_user_id: options.ext_user_id };
    if(options.start) { queryParams.start =  options.start; }
    if(options.end) { queryParams.end =  options.end; }
    if(options.cursor) { queryParams.cursor =  options.cursor; }


    // Setup request with URL and Params
    var requestAPI = request.get(url).query(queryParams);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Mandatory params - workflow_type, status, ext_user_id not found in ' +
                                    'request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/* options = {
    "workflowid": "string", // required
    "context_id" : "string", // required
  };
*/
function getAWorkflow(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  if(options && options.workflowid && options.context_id ) {

    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.getAWorkflow;
    url = helpers.api.constructAPIUrl(url,{ accountid: self.accountId, workflowid: options.workflowid });

    var queryParams = { context_id: options.context_id };


    // Setup request with URL
    var requestAPI = request.get(url).query(queryParams);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Mandatory params - workflow_type, status not found in ' +
                                    'request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/* options = {
    "workflowid": "string", // required
    "body" : {              // required
      "context_id": "string"  // required
    }
  };
*/
function acceptAWorkflow(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  if(options && options.workflowid && options.body && options.body.context_id ) {

    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.acceptAWorkflow;
    url = helpers.api.constructAPIUrl(url,{ accountid: self.accountId, workflowid: options.workflowid });

    var params = options.body;
    // Setup request with URL
    var requestAPI = request.put(url).send(params);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
    requestAPI.end(function (error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response); }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Mandatory params - workflowid, body or body.context_id not found in ' +
                                    'request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/* options = {
    "workflowid": "string", // required
    "body" : {              // required
      "context_id": "string",  // required
      "org_id": "string",   // required
    }
  };
*/
function processAWorkflow(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  if(options && options.workflowid && options.body && options.body.context_id &&
    options.body.org_id) {

    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.processAWorkflow;
    url = helpers.api.constructAPIUrl(url,{ accountid: self.accountId, workflowid: options.workflowid });

    var params = options.body;
    // Setup request with URL
    var requestAPI = request.put(url).send(params);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response); }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Mandatory params - workflowid, body, body.context_id, body.org_id' + 
                                    ' in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/* options = {
    "workflowid": "string", // required
    "body" : {              // required
      "context_id": "string"  // required
    }
  };
*/
function revokeAWorkflow(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  if(options && options.workflowid && options.body && options.body.context_id ) {

    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.revokeAWorkflow;
    url = helpers.api.constructAPIUrl(url,{ accountid: self.accountId, workflowid: options.workflowid });

    var params = options.body;


    // Setup request with URL
    var requestAPI = request.put(url).send(params);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response); }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Mandatory params - workflowid, body or body.context_id not found in ' +
                                    'request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/* options = {
    "workflowid": "string", // required
    "body" : {              // required
      "context_id": "string"  // required
    }
  };
*/
function completeAWorkflow(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  if(options && options.workflowid && options.body && options.body.context_id ) {

    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH + self.config.AUTH_API_URLS.completeAWorkflow;
    url = helpers.api.constructAPIUrl(url,{ accountid: self.accountId, workflowid: options.workflowid });

    var params = options.body;


    // Setup request with URL
    var requestAPI = request.put(url).send(params);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function (error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response); }
    });
  }
  else {
    err = {};
    err.message = err.description = 'Mandatory params - workflowid, body or body.context_id not found in ' +
                                    'request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}

/**
 * options={
 *  "context_id": "string", //mandatory
 *  "body": {
      "ext_user_id": "string", //mandatory
      "workflow_type": "institution_request", //mandatory
      "institution_request": {
        "address": {
          "city": "string",
          "country": "string",
          "street1": "string",
          "street2": "string",
          "street3": "string",
          "house_no": "string",
          "post_code": "string"
        },
        "display_name": "string",
        "school_key": "string"
      }
    } 
  }
 */
function updateWorkflowRequest(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  // Validations

  if(options && options.context_id && options.body.ext_user_id && options.body.workflow_type && options.workflowid) {
    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.AUTH +
              self.config.AUTH_API_URLS.getAWorkflow;
    url = helpers.api.constructAPIUrl(url, {
      accountid: self.accountId, workflowid: options.workflowid
    });
    var queryParams = { context_id: options.context_id };

    // Setup request with URL and Params
    var requestAPI = request.put(url)
    .set('Content-Type', 'application/json')
    .set('Accept', 'application/json').query(queryParams)
    .send(options.body)

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }
    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response); }
    });
  } else {
    var err = {};
    err.message = err.description = 'context_id or ext_user_id or workflow_type or workflowid not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }
  return dfd.promise;
}
},{"./../../helpers":3,"q":90,"superagent":133}],33:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/

/***********************************************************
 * comproDLS SDK xAPI Adaptor
 * Functions for calling xAPI.
 ************************************************************/

/*********************************
 * Setting Up Module Entry Point  
 **********************************/

var q = require('q');
var request = require('superagent');

var helpers = require('../../helpers');
var DLSError = helpers.errors.DLSError;

module.exports = xapi;

/*********************************
 * Public Function definitions
 **********************************/
function xapi(accountId) {
  this.accountId = accountId;
  return {
    postStatement: postStatements.bind(this),
    postExternalStatements: postExternalStatements.bind(this),
    resetUserProductProgress: resetUserProductProgress.bind(this)
  };
}

/*
options = {
  actor: {
    uuid: 'string', // userid of user posting statement / 'me'
    group: 'string' // (optional)
  },
  product: { // optional
    code: 'string',
    title: 'string' // (optional)
    ext-item: boolean  // (optional, all items in entities will be treated as external items, hence no progress JSON update for them)
  },
  classid: 'string', // (optional) Specify if posting via class,
  space_key: 'string'// (optional)

  entities: [{
    assigned_path_id: 'string' //optional, assigned-path of a class
    timestamp: 0,
    verb: 'string', // [redo | evaluated | launched | interacted | completed | answered | attempted | scored | submitted']
          //('redo' verb can only be sent by teacher, admin and superadmin )
    model: 'string', // (optional) model hierarchy of resource if available
    item-code: 'string', // item-code of resource(optional)
    user_data: {
        documentid: 'string',
        folderid: 'string',
        action: 'create/update/delete',
        type: 'string',
        payload: 'string'
    },
    timespent: 0, // (optional)
    activity_status: 'string', // (optional) ['in_process', 'timed_out', 'completed']
    result: { // (optional)
      response: {
          audioPath: 'string',
          text: 'string',
          link: [
            {
              url: 'string',
              title: 'string',
              description: 'string'
            }
          ],
          attribs: {}
      },
      score: { // optional
        min: 0,
        scaled: 0,
        max: 0,
        raw: 0
      },
      comment: 'string', // optional
      questions: [{ // optional
        question-code: 'string',
        status-progress: 'string',  // [not_attempted | in_progress]
        status-evaluation: 'string' // [not_applicable | partially_correct | correct | incorrect]
      }]
    },
    link-statementid: 'string' // required in case of verb = evaluated
  }],
  platform: {
    ua: 'string',
    sessionid: 'string'
  }
};
*/
function postStatements(options) {
  var self = this;

  //Initializing promise
  var dfd = q.defer();
  //Validations
  var err = {}, url;

  err = helpers.validations.isAuthenticated(self.orgId, self.token);
	if(err) { dfd.reject(err); }
  else {
    url = self.config.DEFAULT_HOSTS.XAPI +
          self.config.XAPI_API_URLS.postMultiStatements;
    url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });
		//Passed all validations, Construct API url

		var params = options;

		//Setup request with URL and Params
    var requestAPI = request.post(url).send(params);

		//Setup token in Authorization header
    requestAPI = helpers.api.setupAPIToken(requestAPI, self.token);
    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

		//Call Product Timespent Api

		requestAPI.end(function(err, response) {
      if(err) {
				err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
				dfd.reject(err);
			}
      else { dfd.resolve(response.body); }
		});
	}
  return dfd.promise;
}

/*
options = {
  actor: {
    ext_user_id: 'string', // (optional) who triggered the action - EXTERNAL_SYSTEM in case of verb = evaluated_external
    uuid: 'string' // who triggered the action - EXTERNAL_SYSTEM in case of verb = evaluated_external
  },
  product: {
    code: 'string',
    title: 'string' // (optional)
    ext-item: boolean  // (optional, all items in entities will be treated as external items, hence no progress JSON update for them)
  },
  student_userid: "string", // (optional when verb = submitted_external) ON whom is the action taking place
  student_ext_user_id: "string", // (optional when verb = submitted_external) ON whom is the action taking place
  classid: 'string', // (optional) Specify if posting via class
  space_key: 'string', // (optional)
  platform: {
    ua: "string"
  },
  group: {           // (optional)
    id: "string"
  }
  entities: [{
    assigned_path_id: 'string' //(optional) assigned-path of a class
    timestamp: 0,
    verb: 'string', // [evaluated_external, submitted_external]
    model: 'string', // (optional) model hierarchy of resource if available
    item-code: 'string', // item-code of resource
    timespent: 0, // (optional)
    part: integer, // (mandatory only for verb = evaluated_external)
    submission_order: integer, //  [1, 2, 3]
    result: { // (optional)
      "response": {
        "text": "string",
        "audioPath": "string",
        "link": [
          {
            "url": "string",
            "title": "string",
            "description": "string"
          }
        ]
      },
      "score": {
        "min": 0,
        "scaled": 0,
        "max": 0,
        "raw": 0
      },
      "comment": "string",  // (optional)
      "ext_data": "string", // (optional)
      questions: [{         // (optional)
        question-code: 'string',
        status-progress: 'string',  // [not_attempted | in_progress]
        status-evaluation: 'string' // [not_applicable | partially_correct | correct | incorrect]
      }]
    }
  }]
}
*/
function postExternalStatements(options) {
  var self = this;
  var dfd = q.defer();

  var url = self.config.DEFAULT_HOSTS.XAPI + self.config.XAPI_API_URLS.postExternalMultiStatements;
  url = helpers.api.constructAPIUrl(url, { orgId: self.orgId });
  //Passed all validations, Construct API url

  //Setup request with URL and Params
  var requestAPI = request.post(url).send(options);

  if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

  //Call Product Timespent Api

  requestAPI.end(function(err, response) {
    if(err) {
      err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
      dfd.reject(err);
    }
    else { dfd.resolve(response.body); }
  });
  return dfd.promise;
}

/*options = {
    userid: 'string',
    productcode: 'string',
    actorid: 'string'
}*/
function resetUserProductProgress(options) {
  var self = this;
  // Initializing promise
  var dfd = q.defer();
  var err = {};
  if(options && options.userid && options.productcode && options.actorid) {

    // Passed all validations, Contruct API url
    var url = self.config.DEFAULT_HOSTS.XAPI + self.config.XAPI_API_URLS.resetUserProductProgress;
    url = helpers.api.constructAPIUrl(url, { accountId : self.accountId });

    // Setup request with URL and Params
    var requestAPI = request.delete(url)
                    .set('Content-Type', 'application/json')
                    .set('Accept', 'application/json')
                    .send(options);

    if(self.traceid) { requestAPI.set('X-Amzn-Trace-Id', self.traceid); }

    requestAPI.end(function(error, response) {
      if(error) {
        err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, error);
        dfd.reject(err);
      }
      else { dfd.resolve(response.body); }
    });
  }
  else {
    err.message = err.description = 'userid, productcode or actorid not found in request options.';
    err = new DLSError(helpers.errors.ERROR_TYPES.SDK_ERROR, err);
    dfd.reject(err);
  }

  return dfd.promise;
}

},{"../../helpers":3,"q":90,"superagent":133}],34:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/
/***********************************************************
 * comproDLS SDK Token Manager Module
 * Provides Token managements functions for the SDK
 ************************************************************/
var request = require('superagent');
var q = require('q');

var helpers = require('../helpers');
var DLSError = helpers.errors.DLSError;
var validations = require('./validations');

/*************************************
 * Setting up Exports/Public functions
 *************************************/
exports.authWithExtUser = authWithExtUser;
exports.authWithToken = authWithToken;

function authWithExtUser(organizationId, options) {
    var self = this;
    var dfd = q.defer();

    //Validation
    var err = validations.validateAuthWithExtUser(organizationId, options);
    if (err) {
        dfd.reject(err);
    } else {
        //Passed all Validations, Setup the GET TOKEN API URL.
        var url = this.config.DEFAULT_HOSTS['AUTH'] + this.config.AUTH_API_URLS.getExtUserTokenAPI;
        url = helpers.api.constructAPIUrl(url, {"orgId" : organizationId});

        //Setup Credentials
        var params = {
            "ext_user_id": options.ext_user_id
        };
        //Call the comproDLS GET TOKEN API
        request.post(url).send(params).end(function(err, response) {
            if (err) {
                //API Error, Construct Standard SDK error response
                err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
                dfd.reject(err);
            } else {

                //Success, Extract the Token & Other useful information
                var token = {
                    'access_token': response.body.access_token
                };
                var user = response.body.user;
                var responseObj = {
                    'token': token,
                    'user': user,
                    'metrics': response.body.metrics
                }

                //Setting token and organisationid in comproDLS instance
                self.token = token;
                self.orgId = user.org.id;

                dfd.resolve(responseObj);
            }
        });
    }
    return dfd.promise;
};

function authWithToken(organizationId, token, options) {
    var self = this;
    var dfd = q.defer();

    //Validation
    var err = validations.authWithToken(organizationId, token ,options);
    if (err) {
        dfd.reject(err);
    } else {

        //Setting token and organisationid in comproDLS instance
        self.token = token;
        self.orgId = organizationId;

        if (options && options.getuserdetails) {
            self.Auth().getUserProfile().then(function(response) {
                var responseObj = {
                    'token': self.token,
                    'user': response
                }
                dfd.resolve(responseObj);
            }, function(err) {
                err = new DLSError(helpers.errors.ERROR_TYPES.API_ERROR, err);
                dfd.reject(err);
            });
        } else {
            dfd.resolve(self.token);
        }
    }
    return dfd.promise;
};

},{"../helpers":3,"./validations":35,"q":90,"superagent":133}],35:[function(require,module,exports){
/*************************************************************************
 *
 * COMPRO CONFIDENTIAL
 * __________________
 *
 *  [2015] - [2020] Compro Technologies Private Limited
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Compro Technologies Private Limited. The
 * intellectual and technical concepts contained herein are
 * proprietary to Compro Technologies Private Limited and may
 * be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Compro Technologies Pvt. Ltd..
 ***************************************************************************/
/***********************************************************
 * comproDLS Token Module Validations
 * This module contains validations for token manager module.
 ************************************************************/
var validate = require('../helpers').validations.validate;

/****************************************************
 * Setting up Exports/Public variables 
 *****************************************************/
exports.authWithToken = validateAuthWithToken;
exports.validateAuthWithExtUser = validateAuthWithExtUser;

/*********************************
 * Public Function definitions
 **********************************/
function validateAuthWithToken(organizationId, token ,options) {
    var validate_options = {
        'organization': organizationId,
        'token': token,
        'options': options
    };

    var validate_constraints = {
        "organization": {
            "isString": true,
            "presence": true
        },
        "token": {
            "isObject": true,
            "presence": true,
            "contains": ["access_token"]
        },
        "token.access_token": {
            "isString": true,
            "presence": true
        },
        "options": {
            "isObject": true
        }
    };

    return validate(validate_options, validate_constraints);
};

function validateAuthWithExtUser(organizationId, options) {
    var validate_options = {
        'organization': organizationId,
        'options': options
    };

    var validate_constraints = {
        "organization": {
            "isString": true,
            "presence": true
        },
        "options": {
            "isObject": true,
            "presence": true,
            "contains": ["ext_user_id"]
        },
        "options.ext_user_id": {
            "isString": true,
            "presence": true
        }
    };

    return validate(validate_options, validate_constraints);
};


},{"../helpers":3}],36:[function(require,module,exports){
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

},{}],37:[function(require,module,exports){
module.exports = noop;
module.exports.HttpsAgent = noop;

// Noop function for browser since native api's don't use agents.
function noop () {}

},{}],38:[function(require,module,exports){
/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

},{}],39:[function(require,module,exports){

/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};


},{}],40:[function(require,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(chars){
  "use strict";

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = chars.indexOf(base64[i]);
      encoded2 = chars.indexOf(base64[i+1]);
      encoded3 = chars.indexOf(base64[i+2]);
      encoded4 = chars.indexOf(base64[i+3]);

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");

},{}],41:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],42:[function(require,module,exports){
(function (global){
/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = global.BlobBuilder
  || global.WebKitBlobBuilder
  || global.MSBlobBuilder
  || global.MozBlobBuilder;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */

var blobSupportsArrayBufferView = blobSupported && (function() {
  try {
    var b = new Blob([new Uint8Array([1,2])]);
    return b.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  for (var i = 0; i < ary.length; i++) {
    var chunk = ary[i];
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer;

      // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer
      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      ary[i] = buf;
    }
  }
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  mapArrayBufferViews(ary);

  for (var i = 0; i < ary.length; i++) {
    bb.append(ary[i]);
  }

  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

function BlobConstructor(ary, options) {
  mapArrayBufferViews(ary);
  return new Blob(ary, options || {});
};

module.exports = (function() {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],43:[function(require,module,exports){

},{}],44:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
 *     on objects.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

function typedArraySupport () {
  function Bar () {}
  try {
    var arr = new Uint8Array(1)
    arr.foo = function () { return 42 }
    arr.constructor = Bar
    return arr.foo() === 42 && // typed array instances can be augmented
        arr.constructor === Bar && // constructor can be set
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    this.length = 0
    this.parent = undefined
  }

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined') {
    if (object.buffer instanceof ArrayBuffer) {
      return fromTypedArray(that, object)
    }
    if (object instanceof ArrayBuffer) {
      return fromArrayBuffer(that, object)
    }
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    array.byteLength
    that = Buffer._augment(new Uint8Array(array))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromTypedArray(that, new Uint8Array(array))
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
} else {
  // pre-set for values that may exist in the future
  Buffer.prototype.length = undefined
  Buffer.prototype.parent = undefined
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = '' + string

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      // Deprecated
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` is deprecated
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` is deprecated
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; i--) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"base64-js":41,"ieee754":74,"isarray":77}],45:[function(require,module,exports){
module.exports = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Moved Temporarily",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Time-out",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Request Entity Too Large",
  "414": "Request-URI Too Large",
  "415": "Unsupported Media Type",
  "416": "Requested Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Time-out",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
}

},{}],46:[function(require,module,exports){
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

},{}],47:[function(require,module,exports){

module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};
},{}],48:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('buffer').Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

},{"buffer":44}],49:[function(require,module,exports){

module.exports =  require('./lib/');

},{"./lib/":50}],50:[function(require,module,exports){

module.exports = require('./socket');

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = require('engine.io-parser');

},{"./socket":51,"engine.io-parser":63}],51:[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var transports = require('./transports');
var Emitter = require('component-emitter');
var debug = require('debug')('engine.io-client:socket');
var index = require('indexof');
var parser = require('engine.io-parser');
var parseuri = require('parseuri');
var parsejson = require('parsejson');
var parseqs = require('parseqs');

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Noop function.
 *
 * @api private
 */

function noop(){}

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket(uri, opts){
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' == typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.hostname = uri.host;
    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  } else if (opts.host) {
    opts.hostname = parseuri(opts.host).host;
  }

  this.secure = null != opts.secure ? opts.secure :
    (global.location && 'https:' == location.protocol);

  if (opts.hostname && !opts.port) {
    // if no port is specified manually, use the protocol default
    opts.port = this.secure ? '443' : '80';
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (global.location ? location.hostname : 'localhost');
  this.port = opts.port || (global.location && location.port ?
       location.port :
       (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.readyState = '';
  this.writeBuffer = [];
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
    this.perMessageDeflate.threshold = 1024;
  }

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? null : opts.rejectUnauthorized;

  // other options for Node.js client
  var freeGlobal = typeof global == 'object' && global;
  if (freeGlobal.global === freeGlobal) {
    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
      this.extraHeaders = opts.extraHeaders;
    }
  }

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = require('./transport');
Socket.transports = require('./transports');
Socket.parser = require('engine.io-parser');

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    agent: this.agent,
    hostname: this.hostname,
    port: this.port,
    secure: this.secure,
    path: this.path,
    query: query,
    forceJSONP: this.forceJSONP,
    jsonp: this.jsonp,
    forceBase64: this.forceBase64,
    enablesXDR: this.enablesXDR,
    timestampRequests: this.timestampRequests,
    timestampParam: this.timestampParam,
    policyPort: this.policyPort,
    socket: this,
    pfx: this.pfx,
    key: this.key,
    passphrase: this.passphrase,
    cert: this.cert,
    ca: this.ca,
    ciphers: this.ciphers,
    rejectUnauthorized: this.rejectUnauthorized,
    perMessageDeflate: this.perMessageDeflate,
    extraHeaders: this.extraHeaders
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
    transport = 'websocket';
  } else if (0 === this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function() {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function(transport){
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function(){
    self.onDrain();
  })
  .on('packet', function(packet){
    self.onPacket(packet);
  })
  .on('error', function(e){
    self.onError(e);
  })
  .on('close', function(){
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 })
    , failed = false
    , self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen(){
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' == msg.type && 'probe' == msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' == transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' == self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport() {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  //Handle any error that happens while probing
  function onerror(err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose(){
    onerror("transport closed");
  }

  //When the socket is closed while we're probing
  function onclose(){
    onerror("socket closed");
  }

  //When the socket is upgraded while we're probing
  function onupgrade(to){
    if (transport && to.name != transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  //Remove all listeners on the transport and on self
  function cleanup(){
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();

};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(parsejson(packet.data));
        break;

      case 'pong':
        this.setPing();
        this.emit('pong');
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.onError(err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if  ('closed' == this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' == self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api private
*/

Socket.prototype.ping = function () {
  var self = this;
  this.sendPacket('ping', function(){
    self.emit('ping');
  });
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function() {
  this.writeBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (0 === this.writeBuffer.length) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' != this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @param {Object} options.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, options, fn) {
  this.sendPacket('message', msg, options, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Object} options.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, options, fn) {
  if('function' == typeof data) {
    fn = data;
    data = undefined;
  }

  if ('function' == typeof options) {
    fn = options;
    options = null;
  }

  if ('closing' == this.readyState || 'closed' == this.readyState) {
    return;
  }

  options = options || {};
  options.compress = false !== options.compress;

  var packet = {
    type: type,
    data: data,
    options: options
  };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  if (fn) this.once('flush', fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.readyState = 'closing';

    var self = this;

    if (this.writeBuffer.length) {
      this.once('drain', function() {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  function close() {
    self.onClose('forced close');
    debug('socket closing - telling transport to close');
    self.transport.close();
  }

  function cleanupAndClose() {
    self.removeListener('upgrade', cleanupAndClose);
    self.removeListener('upgradeError', cleanupAndClose);
    close();
  }

  function waitForUpgrade() {
    // wait for upgrade to finish since we can't send packets while pausing a transport
    self.once('upgrade', cleanupAndClose);
    self.once('upgradeError', cleanupAndClose);
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);

    // clean buffers after, so users can still
    // grab the buffers on `close` event
    self.writeBuffer = [];
    self.prevBufferLen = 0;
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i<j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./transport":52,"./transports":53,"component-emitter":59,"debug":60,"engine.io-parser":63,"indexof":75,"parsejson":83,"parseqs":84,"parseuri":85}],52:[function(require,module,exports){
/**
 * Module dependencies.
 */

var parser = require('engine.io-parser');
var Emitter = require('component-emitter');

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' == this.readyState || '' == this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function(packets){
  if ('open' == this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function(data){
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

},{"component-emitter":59,"engine.io-parser":63}],53:[function(require,module,exports){
(function (global){
/**
 * Module dependencies
 */

var XMLHttpRequest = require('xmlhttprequest-ssl');
var XHR = require('./polling-xhr');
var JSONP = require('./polling-jsonp');
var websocket = require('./websocket');

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling(opts){
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname != location.hostname || port != opts.port;
    xs = opts.secure != isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling-jsonp":54,"./polling-xhr":55,"./websocket":57,"xmlhttprequest-ssl":58}],54:[function(require,module,exports){
(function (global){

/**
 * Module requirements.
 */

var Polling = require('./polling');
var inherit = require('component-inherit');

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Callbacks count.
 */

var index = 0;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document && global.addEventListener) {
    global.addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function(e){
    self.onError('jsonp poll error',e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  if (insertAt) {
    insertAt.parentNode.insertBefore(script, insertAt);
  }
  else {
    (document.head || document.body).appendChild(script);
  }
  this.script = script;

  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
  
  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="'+ self.iframeId +'">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch(e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function(){
      if (self.iframe.readyState == 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling":56,"component-inherit":47}],55:[function(require,module,exports){
(function (global){
/**
 * Module requirements.
 */

var XMLHttpRequest = require('xmlhttprequest-ssl');
var Polling = require('./polling');
var Emitter = require('component-emitter');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty(){}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR(opts){
  Polling.call(this, opts);

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname != global.location.hostname ||
      port != opts.port;
    this.xs = opts.secure != isSSL;
  } else {
    this.extraHeaders = opts.extraHeaders;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function(opts){
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  // other options for Node.js client
  opts.extraHeaders = this.extraHeaders;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function(data, fn){
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function(err){
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function(){
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function(data){
    self.onData(data);
  });
  req.on('error', function(err){
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request(opts){
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined != opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function(){
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    try {
      if (this.extraHeaders) {
        xhr.setDisableHeaderCheck(true);
        for (var i in this.extraHeaders) {
          if (this.extraHeaders.hasOwnProperty(i)) {
            xhr.setRequestHeader(i, this.extraHeaders[i]);
          }
        }
      }
    } catch (e) {}
    if (this.supportsBinary) {
      // This has to be done after open because Firefox is stupid
      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
      xhr.responseType = 'arraybuffer';
    }

    if ('POST' == this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.hasXDR()) {
      xhr.onload = function(){
        self.onLoad();
      };
      xhr.onerror = function(){
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function(){
        if (4 != xhr.readyState) return;
        if (200 == xhr.status || 1223 == xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function(){
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function() {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function(){
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function(data){
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function(err){
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function(fromError){
  if ('undefined' == typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch(e) {}
  }

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function(){
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response;
    } else {
      if (!this.supportsBinary) {
        data = this.xhr.responseText;
      } else {
        try {
          data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));
        } catch (e) {
          var ui8Arr = new Uint8Array(this.xhr.response);
          var dataArray = [];
          for (var idx = 0, length = ui8Arr.length; idx < length; idx++) {
            dataArray.push(ui8Arr[idx]);
          }

          data = String.fromCharCode.apply(null, dataArray);
        }
      }
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function(){
  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function(){
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

if (global.document) {
  Request.requestsCount = 0;
  Request.requests = {};
  if (global.attachEvent) {
    global.attachEvent('onunload', unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener('beforeunload', unloadHandler, false);
  }
}

function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling":56,"component-emitter":59,"component-inherit":47,"debug":60,"xmlhttprequest-ssl":58}],56:[function(require,module,exports){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parseqs = require('parseqs');
var parser = require('engine.io-parser');
var inherit = require('component-inherit');
var yeast = require('yeast');
var debug = require('debug')('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function() {
  var XMLHttpRequest = require('xmlhttprequest-ssl');
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function(){
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function(onPause){
  var pending = 0;
  var self = this;

  this.readyState = 'pausing';

  function pause(){
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function(){
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function(){
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function(){
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function(data){
  var self = this;
  debug('polling got data %s', data);
  var callback = function(packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' == self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' == packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' != this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' == this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function(){
  var self = this;

  function close(){
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' == this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  var callbackfn = function() {
    self.writable = true;
    self.emit('drain');
  };

  var self = this;
  parser.encodePayload(packets, this.supportsBinary, function(data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' == schema && this.port != 443) ||
     ('http' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

},{"../transport":52,"component-inherit":47,"debug":60,"engine.io-parser":63,"parseqs":84,"xmlhttprequest-ssl":58,"yeast":144}],57:[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parser = require('engine.io-parser');
var parseqs = require('parseqs');
var inherit = require('component-inherit');
var yeast = require('yeast');
var debug = require('debug')('engine.io-client:websocket');
var BrowserWebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Get either the `WebSocket` or `MozWebSocket` globals
 * in the browser or try to resolve WebSocket-compatible
 * interface exposed by `ws` for Node-like environment.
 */

var WebSocket = BrowserWebSocket;
if (!WebSocket && typeof window === 'undefined') {
  try {
    WebSocket = require('ws');
  } catch (e) { }
}

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  this.perMessageDeflate = opts.perMessageDeflate;
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function(){
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var self = this;
  var uri = this.uri();
  var protocols = void(0);
  var opts = {
    agent: this.agent,
    perMessageDeflate: this.perMessageDeflate
  };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  if (this.extraHeaders) {
    opts.headers = this.extraHeaders;
  }

  this.ws = BrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  if (this.ws.supports && this.ws.supports.binary) {
    this.supportsBinary = true;
    this.ws.binaryType = 'buffer';
  } else {
    this.ws.binaryType = 'arraybuffer';
  }

  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function(){
  var self = this;

  this.ws.onopen = function(){
    self.onOpen();
  };
  this.ws.onclose = function(){
    self.onClose();
  };
  this.ws.onmessage = function(ev){
    self.onData(ev.data);
  };
  this.ws.onerror = function(e){
    self.onError('websocket error', e);
  };
};

/**
 * Override `onData` to use a timer on iOS.
 * See: https://gist.github.com/mloughran/2052006
 *
 * @api private
 */

if ('undefined' != typeof navigator
  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
  WS.prototype.onData = function(data){
    var self = this;
    setTimeout(function(){
      Transport.prototype.onData.call(self, data);
    }, 0);
  };
}

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function(packets){
  var self = this;
  this.writable = false;

  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  var total = packets.length;
  for (var i = 0, l = total; i < l; i++) {
    (function(packet) {
      parser.encodePacket(packet, self.supportsBinary, function(data) {
        if (!BrowserWebSocket) {
          // always create a new object (GH-437)
          var opts = {};
          if (packet.options) {
            opts.compress = packet.options.compress;
          }

          if (self.perMessageDeflate) {
            var len = 'string' == typeof data ? global.Buffer.byteLength(data) : data.length;
            if (len < self.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }

        //Sometimes the websocket has already been closed but the browser didn't
        //have a chance of informing us about it yet, in that case send will
        //throw an error
        try {
          if (BrowserWebSocket) {
            // TypeError is thrown when passing the second argument on Safari
            self.ws.send(data);
          } else {
            self.ws.send(data, opts);
          }
        } catch (e){
          debug('websocket closed before onclose event');
        }

        --total || done();
      });
    })(packets[i]);
  }

  function done(){
    self.emit('flush');

    // fake drain
    // defer to next tick to allow Socket to clear writeBuffer
    setTimeout(function(){
      self.writable = true;
      self.emit('drain');
    }, 0);
  }
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function(){
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function(){
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' == schema && this.port != 443)
    || ('ws' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function(){
  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../transport":52,"component-inherit":47,"debug":60,"engine.io-parser":63,"parseqs":84,"ws":43,"yeast":144}],58:[function(require,module,exports){
// browser shim for xmlhttprequest module
var hasCORS = require('has-cors');

module.exports = function(opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new ActiveXObject('Microsoft.XMLHTTP');
    } catch(e) { }
  }
}

},{"has-cors":72}],59:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],60:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":61}],61:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":62}],62:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],63:[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var keys = require('./keys');
var hasBinary = require('has-binary');
var sliceBuffer = require('arraybuffer.slice');
var base64encoder = require('base64-arraybuffer');
var after = require('after');
var utf8 = require('utf8');

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = navigator.userAgent.match(/Android/i);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = require('blob');

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if ('function' == typeof supportsBinary) {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if ('function' == typeof utf8encode) {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (Blob && data instanceof global.Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    packet.data = fr.result;
    exports.encodePacket(packet, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (Blob && packet.data instanceof global.Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += global.btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  // String data
  if (typeof data == 'string' || data === undefined) {
    if (data.charAt(0) == 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      try {
        data = utf8.decode(data);
      } catch (e) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!global.ArrayBuffer) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary == 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data != 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data == '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = ''
    , n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (':' != chr) {
      length += chr;
    } else {
      if ('' == length || (length != (n = Number(length)))) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      msg = data.substr(i + 1, n);

      if (length != msg.length) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      if (msg.length) {
        packet = exports.decodePacket(msg, binaryType, true);

        if (err.type == packet.type && err.data == packet.data) {
          // parser error in individual packet - ignoring payload
          return callback(err, 0, 1);
        }

        var ret = callback(packet, i + n, l);
        if (false === ret) return;
      }

      // advance cursor
      i += n;
      length = '';
    }
  }

  if (length != '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  var numberTooLong = false;
  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] == 255) break;

      if (msgLength.length > 310) {
        numberTooLong = true;
        break;
      }

      msgLength += tailArray[i];
    }

    if(numberTooLong) return callback(err, 0, 1);

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./keys":64,"after":36,"arraybuffer.slice":38,"base64-arraybuffer":40,"blob":42,"has-binary":65,"utf8":139}],64:[function(require,module,exports){

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

},{}],65:[function(require,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = require('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"isarray":66}],66:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],67:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],68:[function(require,module,exports){
var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;

var isArray = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject = function isPlainObject(obj) {
	'use strict';

	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var hasOwnConstructor = hasOwn.call(obj, 'constructor');
	var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) { /**/ }

	return typeof key === 'undefined' || hasOwn.call(obj, key);
};

// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
var setProperty = function setProperty(target, options) {
	if (defineProperty && options.name === '__proto__') {
		defineProperty(target, options.name, {
			enumerable: true,
			configurable: true,
			value: options.newValue,
			writable: true
		});
	} else {
		target[options.name] = options.newValue;
	}
};

// Return undefined instead of __proto__ if '__proto__' is not an own property
var getProperty = function getProperty(obj, name) {
	if (name === '__proto__') {
		if (!hasOwn.call(obj, name)) {
			return void 0;
		} else if (gOPD) {
			// In early versions of node, obj['__proto__'] is buggy when obj has
			// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
			return gOPD(obj, name).value;
		}
	}

	return obj[name];
};

module.exports = function extend() {
	'use strict';

	var options, name, src, copy, copyIsArray, clone;
	var target = arguments[0];
	var i = 1;
	var length = arguments.length;
	var deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}
	if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = getProperty(target, name);
				copy = getProperty(options, name);

				// Prevent never-ending loop
				if (target !== copy) {
					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && isArray(src) ? src : [];
						} else {
							clone = src && isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						setProperty(target, { name: name, newValue: extend(deep, clone, copy) });

					// Don't bring in undefined values
					} else if (typeof copy !== 'undefined') {
						setProperty(target, { name: name, newValue: copy });
					}
				}
			}
		}
	}

	// Return the modified object
	return target;
};

},{}],69:[function(require,module,exports){

var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};


},{}],70:[function(require,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = require('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      // see: https://github.com/Automattic/has-binary/pull/4
      if (obj.toJSON && 'function' == typeof obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"isarray":71}],71:[function(require,module,exports){
arguments[4][66][0].apply(exports,arguments)
},{"dup":66}],72:[function(require,module,exports){

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = typeof XMLHttpRequest !== 'undefined' &&
    'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

},{}],73:[function(require,module,exports){
var http = require('http');

var https = module.exports;

for (var key in http) {
    if (http.hasOwnProperty(key)) https[key] = http[key];
};

https.request = function (params, cb) {
    if (!params) params = {};
    params.scheme = 'https';
    params.protocol = 'https:';
    return http.request.call(this, params, cb);
}

},{"http":127}],74:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],75:[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],76:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],77:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],78:[function(require,module,exports){
(function (global){
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],79:[function(require,module,exports){
'use strict';

var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var isArgs = require('./isArguments'); // eslint-disable-line global-require
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
module.exports = keysShim;

},{"./isArguments":81}],80:[function(require,module,exports){
'use strict';

var slice = Array.prototype.slice;
var isArgs = require('./isArguments');

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) { return origKeys(o); } : require('./implementation');

var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;

},{"./implementation":79,"./isArguments":81}],81:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};

},{}],82:[function(require,module,exports){
exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

},{}],83:[function(require,module,exports){
(function (global){
/**
 * JSON parse.
 *
 * @see Based on jQuery#parseJSON (MIT) and JSON2
 * @api private
 */

var rvalidchars = /^[\],:{}\s]*$/;
var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
var rtrimLeft = /^\s+/;
var rtrimRight = /\s+$/;

module.exports = function parsejson(data) {
  if ('string' != typeof data || !data) {
    return null;
  }

  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');

  // Attempt to parse using the native JSON parser first
  if (global.JSON && JSON.parse) {
    return JSON.parse(data);
  }

  if (rvalidchars.test(data.replace(rvalidescape, '@')
      .replace(rvalidtokens, ']')
      .replace(rvalidbraces, ''))) {
    return (new Function('return ' + data))();
  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],84:[function(require,module,exports){
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

},{}],85:[function(require,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};

},{}],86:[function(require,module,exports){
(function (process){
'use strict';

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this,require('_process'))
},{"_process":87}],87:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],88:[function(require,module,exports){
(function (global,Buffer){
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).PubNub=t()}(this,(function(){"use strict";
/*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */var e=function(t,n){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])},e(t,n)};function t(t,n){if("function"!=typeof n&&null!==n)throw new TypeError("Class extends value "+String(n)+" is not a constructor or null");function r(){this.constructor=t}e(t,n),t.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}var n=function(){return n=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var i in t=arguments[n])Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e},n.apply(this,arguments)};function r(e,t,n,r){return new(n||(n=Promise))((function(i,o){function s(e){try{u(r.next(e))}catch(e){o(e)}}function a(e){try{u(r.throw(e))}catch(e){o(e)}}function u(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,a)}u((r=r.apply(e,t||[])).next())}))}function i(e,t){var n,r,i,o,s={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function a(o){return function(a){return function(o){if(n)throw new TypeError("Generator is already executing.");for(;s;)try{if(n=1,r&&(i=2&o[0]?r.return:o[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,o[1])).done)return i;switch(r=0,i&&(o=[2&o[0],i.value]),o[0]){case 0:case 1:i=o;break;case 4:return s.label++,{value:o[1],done:!1};case 5:s.label++,r=o[1],o=[0];continue;case 7:o=s.ops.pop(),s.trys.pop();continue;default:if(!(i=s.trys,(i=i.length>0&&i[i.length-1])||6!==o[0]&&2!==o[0])){s=0;continue}if(3===o[0]&&(!i||o[1]>i[0]&&o[1]<i[3])){s.label=o[1];break}if(6===o[0]&&s.label<i[1]){s.label=i[1],i=o;break}if(i&&s.label<i[2]){s.label=i[2],s.ops.push(o);break}i[2]&&s.ops.pop(),s.trys.pop();continue}o=t.call(e,s)}catch(e){o=[6,e],r=0}finally{n=i=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,a])}}}function o(e){var t="function"==typeof Symbol&&Symbol.iterator,n=t&&e[t],r=0;if(n)return n.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}function s(e,t){var n="function"==typeof Symbol&&e[Symbol.iterator];if(!n)return e;var r,i,o=n.call(e),s=[];try{for(;(void 0===t||t-- >0)&&!(r=o.next()).done;)s.push(r.value)}catch(e){i={error:e}}finally{try{r&&!r.done&&(n=o.return)&&n.call(o)}finally{if(i)throw i.error}}return s}function a(e,t,n){if(n||2===arguments.length)for(var r,i=0,o=t.length;i<o;i++)!r&&i in t||(r||(r=Array.prototype.slice.call(t,0,i)),r[i]=t[i]);return e.concat(r||Array.prototype.slice.call(t))}var u="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},c={exports:{}};!function(e){!function(t,n){var r=Math.pow(2,-24),i=Math.pow(2,32),o=Math.pow(2,53);var s={encode:function(e){var t,r=new ArrayBuffer(256),s=new DataView(r),a=0;function u(e){for(var n=r.byteLength,i=a+e;n<i;)n*=2;if(n!==r.byteLength){var o=s;r=new ArrayBuffer(n),s=new DataView(r);for(var u=a+3>>2,c=0;c<u;++c)s.setUint32(4*c,o.getUint32(4*c))}return t=e,s}function c(){a+=t}function l(e){c(u(1).setUint8(a,e))}function p(e){for(var t=u(e.length),n=0;n<e.length;++n)t.setUint8(a+n,e[n]);c()}function h(e,t){t<24?l(e<<5|t):t<256?(l(e<<5|24),l(t)):t<65536?(l(e<<5|25),function(e){c(u(2).setUint16(a,e))}(t)):t<4294967296?(l(e<<5|26),function(e){c(u(4).setUint32(a,e))}(t)):(l(e<<5|27),function(e){var t=e%i,n=(e-t)/i,r=u(8);r.setUint32(a,n),r.setUint32(a+4,t),c()}(t))}if(function e(t){var r;if(!1===t)return l(244);if(!0===t)return l(245);if(null===t)return l(246);if(t===n)return l(247);switch(typeof t){case"number":if(Math.floor(t)===t){if(0<=t&&t<=o)return h(0,t);if(-o<=t&&t<0)return h(1,-(t+1))}return l(251),function(e){c(u(8).setFloat64(a,e))}(t);case"string":var i=[];for(r=0;r<t.length;++r){var s=t.charCodeAt(r);s<128?i.push(s):s<2048?(i.push(192|s>>6),i.push(128|63&s)):s<55296?(i.push(224|s>>12),i.push(128|s>>6&63),i.push(128|63&s)):(s=(1023&s)<<10,s|=1023&t.charCodeAt(++r),s+=65536,i.push(240|s>>18),i.push(128|s>>12&63),i.push(128|s>>6&63),i.push(128|63&s))}return h(3,i.length),p(i);default:var f;if(Array.isArray(t))for(h(4,f=t.length),r=0;r<f;++r)e(t[r]);else if(t instanceof Uint8Array)h(2,t.length),p(t);else{var d=Object.keys(t);for(h(5,f=d.length),r=0;r<f;++r){var g=d[r];e(g),e(t[g])}}}}(e),"slice"in r)return r.slice(0,a);for(var f=new ArrayBuffer(a),d=new DataView(f),g=0;g<a;++g)d.setUint8(g,s.getUint8(g));return f},decode:function(e,t,o){var s=new DataView(e),a=0;function u(e,t){return a+=t,e}function c(t){return u(new Uint8Array(e,a,t),t)}function l(){return u(s.getUint8(a),1)}function p(){return u(s.getUint16(a),2)}function h(){return u(s.getUint32(a),4)}function f(){return 255===s.getUint8(a)&&(a+=1,!0)}function d(e){if(e<24)return e;if(24===e)return l();if(25===e)return p();if(26===e)return h();if(27===e)return h()*i+h();if(31===e)return-1;throw"Invalid length encoding"}function g(e){var t=l();if(255===t)return-1;var n=d(31&t);if(n<0||t>>5!==e)throw"Invalid indefinite length element";return n}function y(e,t){for(var n=0;n<t;++n){var r=l();128&r&&(r<224?(r=(31&r)<<6|63&l(),t-=1):r<240?(r=(15&r)<<12|(63&l())<<6|63&l(),t-=2):(r=(15&r)<<18|(63&l())<<12|(63&l())<<6|63&l(),t-=3)),r<65536?e.push(r):(r-=65536,e.push(55296|r>>10),e.push(56320|1023&r))}}"function"!=typeof t&&(t=function(e){return e}),"function"!=typeof o&&(o=function(){return n});var b=function e(){var i,h,b=l(),v=b>>5,m=31&b;if(7===v)switch(m){case 25:return function(){var e=new ArrayBuffer(4),t=new DataView(e),n=p(),i=32768&n,o=31744&n,s=1023&n;if(31744===o)o=261120;else if(0!==o)o+=114688;else if(0!==s)return s*r;return t.setUint32(0,i<<16|o<<13|s<<13),t.getFloat32(0)}();case 26:return u(s.getFloat32(a),4);case 27:return u(s.getFloat64(a),8)}if((h=d(m))<0&&(v<2||6<v))throw"Invalid length";switch(v){case 0:return h;case 1:return-1-h;case 2:if(h<0){for(var _=[],O=0;(h=g(v))>=0;)O+=h,_.push(c(h));var P=new Uint8Array(O),S=0;for(i=0;i<_.length;++i)P.set(_[i],S),S+=_[i].length;return P}return c(h);case 3:var w=[];if(h<0)for(;(h=g(v))>=0;)y(w,h);else y(w,h);return String.fromCharCode.apply(null,w);case 4:var T;if(h<0)for(T=[];!f();)T.push(e());else for(T=new Array(h),i=0;i<h;++i)T[i]=e();return T;case 5:var k={};for(i=0;i<h||h<0&&!f();++i){k[e()]=e()}return k;case 6:return t(e(),h);case 7:switch(h){case 20:return!1;case 21:return!0;case 22:return null;case 23:return n;default:return o(h)}}}();if(a!==e.byteLength)throw"Remaining bytes";return b}};e.exports?e.exports=s:t.CBOR||(t.CBOR=s)}(u)}(c);var l=c.exports,p={exports:{}};
/*! lil-uuid - v0.1 - MIT License - https://github.com/lil-js/uuid */
!function(e,t){!function(e){var t="0.1.0",n={3:/^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,4:/^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,5:/^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,all:/^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i};function r(){var e,t,n="";for(e=0;e<32;e++)t=16*Math.random()|0,8!==e&&12!==e&&16!==e&&20!==e||(n+="-"),n+=(12===e?4:16===e?3&t|8:t).toString(16);return n}function i(e,t){var r=n[t||"all"];return r&&r.test(e)||!1}r.isUUID=i,r.VERSION=t,e.uuid=r,e.isUUID=i}(t),null!==e&&(e.exports=t.uuid)}(p,p.exports);var h,f,d,g,y,b=p.exports,v=function(){return b.uuid?b.uuid():b()},m=function(){function e(e){var t,n,r,i=e.setup;if(this._PNSDKSuffix={},this.instanceId="pn-".concat(v()),this.secretKey=i.secretKey||i.secret_key,this.subscribeKey=i.subscribeKey||i.subscribe_key,this.publishKey=i.publishKey||i.publish_key,this.sdkName=i.sdkName,this.sdkFamily=i.sdkFamily,this.partnerId=i.partnerId,this.setAuthKey(i.authKey),this.setCipherKey(i.cipherKey),this.setFilterExpression(i.filterExpression),"string"!=typeof i.origin&&!Array.isArray(i.origin)&&void 0!==i.origin)throw new Error("Origin must be either undefined, a string or a list of strings.");this.origin=i.origin||Array.from({length:20},(function(e,t){return"ps".concat(t+1,".pndsn.com")})),this.secure=i.ssl||!1,this.restore=i.restore||!1,this.proxy=i.proxy,this.keepAlive=i.keepAlive,this.keepAliveSettings=i.keepAliveSettings,this.autoNetworkDetection=i.autoNetworkDetection||!1,this.dedupeOnSubscribe=i.dedupeOnSubscribe||!1,this.maximumCacheSize=i.maximumCacheSize||100,this.customEncrypt=i.customEncrypt,this.customDecrypt=i.customDecrypt,this.fileUploadPublishRetryLimit=null!==(t=i.fileUploadPublishRetryLimit)&&void 0!==t?t:5,this.useRandomIVs=null===(n=i.useRandomIVs)||void 0===n||n,this.enableSubscribeBeta=null!==(r=i.enableSubscribeBeta)&&void 0!==r&&r,"undefined"!=typeof location&&"https:"===location.protocol&&(this.secure=!0),this.logVerbosity=i.logVerbosity||!1,this.suppressLeaveEvents=i.suppressLeaveEvents||!1,this.announceFailedHeartbeats=i.announceFailedHeartbeats||!0,this.announceSuccessfulHeartbeats=i.announceSuccessfulHeartbeats||!1,this.useInstanceId=i.useInstanceId||!1,this.useRequestId=i.useRequestId||!1,this.requestMessageCountThreshold=i.requestMessageCountThreshold,this.setTransactionTimeout(i.transactionalRequestTimeout||15e3),this.setSubscribeTimeout(i.subscribeRequestTimeout||31e4),this.setSendBeaconConfig(i.useSendBeacon||!0),i.presenceTimeout?this.setPresenceTimeout(i.presenceTimeout):this._presenceTimeout=300,null!=i.heartbeatInterval&&this.setHeartbeatInterval(i.heartbeatInterval),this.setUUID(i.uuid)}return e.prototype.getAuthKey=function(){return this.authKey},e.prototype.setAuthKey=function(e){return this.authKey=e,this},e.prototype.setCipherKey=function(e){return this.cipherKey=e,this},e.prototype.getUUID=function(){return this.UUID},e.prototype.setUUID=function(e){if(!e||"string"!=typeof e||0===e.trim().length)throw new Error("Missing uuid parameter. Provide a valid string uuid");return this.UUID=e,this},e.prototype.getFilterExpression=function(){return this.filterExpression},e.prototype.setFilterExpression=function(e){return this.filterExpression=e,this},e.prototype.getPresenceTimeout=function(){return this._presenceTimeout},e.prototype.setPresenceTimeout=function(e){return e>=20?this._presenceTimeout=e:(this._presenceTimeout=20,console.log("WARNING: Presence timeout is less than the minimum. Using minimum value: ",this._presenceTimeout)),this.setHeartbeatInterval(this._presenceTimeout/2-1),this},e.prototype.setProxy=function(e){this.proxy=e},e.prototype.getHeartbeatInterval=function(){return this._heartbeatInterval},e.prototype.setHeartbeatInterval=function(e){return this._heartbeatInterval=e,this},e.prototype.getSubscribeTimeout=function(){return this._subscribeRequestTimeout},e.prototype.setSubscribeTimeout=function(e){return this._subscribeRequestTimeout=e,this},e.prototype.getTransactionTimeout=function(){return this._transactionalRequestTimeout},e.prototype.setTransactionTimeout=function(e){return this._transactionalRequestTimeout=e,this},e.prototype.isSendBeaconEnabled=function(){return this._useSendBeacon},e.prototype.setSendBeaconConfig=function(e){return this._useSendBeacon=e,this},e.prototype.getVersion=function(){return"7.0.1"},e.prototype._addPnsdkSuffix=function(e,t){this._PNSDKSuffix[e]=t},e.prototype._getPnsdkSuffix=function(e){var t=this;return Object.keys(this._PNSDKSuffix).reduce((function(n,r){return n+e+t._PNSDKSuffix[r]}),"")},e}(),_=_||function(e,t){var n={},r=n.lib={},i=function(){},o=r.Base={extend:function(e){i.prototype=this;var t=new i;return e&&t.mixIn(e),t.hasOwnProperty("init")||(t.init=function(){t.$super.init.apply(this,arguments)}),t.init.prototype=t,t.$super=this,t},create:function(){var e=this.extend();return e.init.apply(e,arguments),e},init:function(){},mixIn:function(e){for(var t in e)e.hasOwnProperty(t)&&(this[t]=e[t]);e.hasOwnProperty("toString")&&(this.toString=e.toString)},clone:function(){return this.init.prototype.extend(this)}},s=r.WordArray=o.extend({init:function(e,t){e=this.words=e||[],this.sigBytes=null!=t?t:4*e.length},toString:function(e){return(e||u).stringify(this)},concat:function(e){var t=this.words,n=e.words,r=this.sigBytes;if(e=e.sigBytes,this.clamp(),r%4)for(var i=0;i<e;i++)t[r+i>>>2]|=(n[i>>>2]>>>24-i%4*8&255)<<24-(r+i)%4*8;else if(65535<n.length)for(i=0;i<e;i+=4)t[r+i>>>2]=n[i>>>2];else t.push.apply(t,n);return this.sigBytes+=e,this},clamp:function(){var t=this.words,n=this.sigBytes;t[n>>>2]&=4294967295<<32-n%4*8,t.length=e.ceil(n/4)},clone:function(){var e=o.clone.call(this);return e.words=this.words.slice(0),e},random:function(t){for(var n=[],r=0;r<t;r+=4)n.push(4294967296*e.random()|0);return new s.init(n,t)}}),a=n.enc={},u=a.Hex={stringify:function(e){var t=e.words;e=e.sigBytes;for(var n=[],r=0;r<e;r++){var i=t[r>>>2]>>>24-r%4*8&255;n.push((i>>>4).toString(16)),n.push((15&i).toString(16))}return n.join("")},parse:function(e){for(var t=e.length,n=[],r=0;r<t;r+=2)n[r>>>3]|=parseInt(e.substr(r,2),16)<<24-r%8*4;return new s.init(n,t/2)}},c=a.Latin1={stringify:function(e){var t=e.words;e=e.sigBytes;for(var n=[],r=0;r<e;r++)n.push(String.fromCharCode(t[r>>>2]>>>24-r%4*8&255));return n.join("")},parse:function(e){for(var t=e.length,n=[],r=0;r<t;r++)n[r>>>2]|=(255&e.charCodeAt(r))<<24-r%4*8;return new s.init(n,t)}},l=a.Utf8={stringify:function(e){try{return decodeURIComponent(escape(c.stringify(e)))}catch(e){throw Error("Malformed UTF-8 data")}},parse:function(e){return c.parse(unescape(encodeURIComponent(e)))}},p=r.BufferedBlockAlgorithm=o.extend({reset:function(){this._data=new s.init,this._nDataBytes=0},_append:function(e){"string"==typeof e&&(e=l.parse(e)),this._data.concat(e),this._nDataBytes+=e.sigBytes},_process:function(t){var n=this._data,r=n.words,i=n.sigBytes,o=this.blockSize,a=i/(4*o);if(t=(a=t?e.ceil(a):e.max((0|a)-this._minBufferSize,0))*o,i=e.min(4*t,i),t){for(var u=0;u<t;u+=o)this._doProcessBlock(r,u);u=r.splice(0,t),n.sigBytes-=i}return new s.init(u,i)},clone:function(){var e=o.clone.call(this);return e._data=this._data.clone(),e},_minBufferSize:0});r.Hasher=p.extend({cfg:o.extend(),init:function(e){this.cfg=this.cfg.extend(e),this.reset()},reset:function(){p.reset.call(this),this._doReset()},update:function(e){return this._append(e),this._process(),this},finalize:function(e){return e&&this._append(e),this._doFinalize()},blockSize:16,_createHelper:function(e){return function(t,n){return new e.init(n).finalize(t)}},_createHmacHelper:function(e){return function(t,n){return new h.HMAC.init(e,n).finalize(t)}}});var h=n.algo={};return n}(Math);!function(e){for(var t=_,n=(i=t.lib).WordArray,r=i.Hasher,i=t.algo,o=[],s=[],a=function(e){return 4294967296*(e-(0|e))|0},u=2,c=0;64>c;){var l;e:{l=u;for(var p=e.sqrt(l),h=2;h<=p;h++)if(!(l%h)){l=!1;break e}l=!0}l&&(8>c&&(o[c]=a(e.pow(u,.5))),s[c]=a(e.pow(u,1/3)),c++),u++}var f=[];i=i.SHA256=r.extend({_doReset:function(){this._hash=new n.init(o.slice(0))},_doProcessBlock:function(e,t){for(var n=this._hash.words,r=n[0],i=n[1],o=n[2],a=n[3],u=n[4],c=n[5],l=n[6],p=n[7],h=0;64>h;h++){if(16>h)f[h]=0|e[t+h];else{var d=f[h-15],g=f[h-2];f[h]=((d<<25|d>>>7)^(d<<14|d>>>18)^d>>>3)+f[h-7]+((g<<15|g>>>17)^(g<<13|g>>>19)^g>>>10)+f[h-16]}d=p+((u<<26|u>>>6)^(u<<21|u>>>11)^(u<<7|u>>>25))+(u&c^~u&l)+s[h]+f[h],g=((r<<30|r>>>2)^(r<<19|r>>>13)^(r<<10|r>>>22))+(r&i^r&o^i&o),p=l,l=c,c=u,u=a+d|0,a=o,o=i,i=r,r=d+g|0}n[0]=n[0]+r|0,n[1]=n[1]+i|0,n[2]=n[2]+o|0,n[3]=n[3]+a|0,n[4]=n[4]+u|0,n[5]=n[5]+c|0,n[6]=n[6]+l|0,n[7]=n[7]+p|0},_doFinalize:function(){var t=this._data,n=t.words,r=8*this._nDataBytes,i=8*t.sigBytes;return n[i>>>5]|=128<<24-i%32,n[14+(i+64>>>9<<4)]=e.floor(r/4294967296),n[15+(i+64>>>9<<4)]=r,t.sigBytes=4*n.length,this._process(),this._hash},clone:function(){var e=r.clone.call(this);return e._hash=this._hash.clone(),e}});t.SHA256=r._createHelper(i),t.HmacSHA256=r._createHmacHelper(i)}(Math),f=(h=_).enc.Utf8,h.algo.HMAC=h.lib.Base.extend({init:function(e,t){e=this._hasher=new e.init,"string"==typeof t&&(t=f.parse(t));var n=e.blockSize,r=4*n;t.sigBytes>r&&(t=e.finalize(t)),t.clamp();for(var i=this._oKey=t.clone(),o=this._iKey=t.clone(),s=i.words,a=o.words,u=0;u<n;u++)s[u]^=1549556828,a[u]^=909522486;i.sigBytes=o.sigBytes=r,this.reset()},reset:function(){var e=this._hasher;e.reset(),e.update(this._iKey)},update:function(e){return this._hasher.update(e),this},finalize:function(e){var t=this._hasher;return e=t.finalize(e),t.reset(),t.finalize(this._oKey.clone().concat(e))}}),g=(d=_).lib.WordArray,d.enc.Base64={stringify:function(e){var t=e.words,n=e.sigBytes,r=this._map;e.clamp(),e=[];for(var i=0;i<n;i+=3)for(var o=(t[i>>>2]>>>24-i%4*8&255)<<16|(t[i+1>>>2]>>>24-(i+1)%4*8&255)<<8|t[i+2>>>2]>>>24-(i+2)%4*8&255,s=0;4>s&&i+.75*s<n;s++)e.push(r.charAt(o>>>6*(3-s)&63));if(t=r.charAt(64))for(;e.length%4;)e.push(t);return e.join("")},parse:function(e){var t=e.length,n=this._map;(r=n.charAt(64))&&-1!=(r=e.indexOf(r))&&(t=r);for(var r=[],i=0,o=0;o<t;o++)if(o%4){var s=n.indexOf(e.charAt(o-1))<<o%4*2,a=n.indexOf(e.charAt(o))>>>6-o%4*2;r[i>>>2]|=(s|a)<<24-i%4*8,i++}return g.create(r,i)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="},function(e){function t(e,t,n,r,i,o,s){return((e=e+(t&n|~t&r)+i+s)<<o|e>>>32-o)+t}function n(e,t,n,r,i,o,s){return((e=e+(t&r|n&~r)+i+s)<<o|e>>>32-o)+t}function r(e,t,n,r,i,o,s){return((e=e+(t^n^r)+i+s)<<o|e>>>32-o)+t}function i(e,t,n,r,i,o,s){return((e=e+(n^(t|~r))+i+s)<<o|e>>>32-o)+t}for(var o=_,s=(u=o.lib).WordArray,a=u.Hasher,u=o.algo,c=[],l=0;64>l;l++)c[l]=4294967296*e.abs(e.sin(l+1))|0;u=u.MD5=a.extend({_doReset:function(){this._hash=new s.init([1732584193,4023233417,2562383102,271733878])},_doProcessBlock:function(e,o){for(var s=0;16>s;s++){var a=e[u=o+s];e[u]=16711935&(a<<8|a>>>24)|4278255360&(a<<24|a>>>8)}s=this._hash.words;var u=e[o+0],l=(a=e[o+1],e[o+2]),p=e[o+3],h=e[o+4],f=e[o+5],d=e[o+6],g=e[o+7],y=e[o+8],b=e[o+9],v=e[o+10],m=e[o+11],_=e[o+12],O=e[o+13],P=e[o+14],S=e[o+15],w=t(w=s[0],N=s[1],k=s[2],T=s[3],u,7,c[0]),T=t(T,w,N,k,a,12,c[1]),k=t(k,T,w,N,l,17,c[2]),N=t(N,k,T,w,p,22,c[3]);w=t(w,N,k,T,h,7,c[4]),T=t(T,w,N,k,f,12,c[5]),k=t(k,T,w,N,d,17,c[6]),N=t(N,k,T,w,g,22,c[7]),w=t(w,N,k,T,y,7,c[8]),T=t(T,w,N,k,b,12,c[9]),k=t(k,T,w,N,v,17,c[10]),N=t(N,k,T,w,m,22,c[11]),w=t(w,N,k,T,_,7,c[12]),T=t(T,w,N,k,O,12,c[13]),k=t(k,T,w,N,P,17,c[14]),w=n(w,N=t(N,k,T,w,S,22,c[15]),k,T,a,5,c[16]),T=n(T,w,N,k,d,9,c[17]),k=n(k,T,w,N,m,14,c[18]),N=n(N,k,T,w,u,20,c[19]),w=n(w,N,k,T,f,5,c[20]),T=n(T,w,N,k,v,9,c[21]),k=n(k,T,w,N,S,14,c[22]),N=n(N,k,T,w,h,20,c[23]),w=n(w,N,k,T,b,5,c[24]),T=n(T,w,N,k,P,9,c[25]),k=n(k,T,w,N,p,14,c[26]),N=n(N,k,T,w,y,20,c[27]),w=n(w,N,k,T,O,5,c[28]),T=n(T,w,N,k,l,9,c[29]),k=n(k,T,w,N,g,14,c[30]),w=r(w,N=n(N,k,T,w,_,20,c[31]),k,T,f,4,c[32]),T=r(T,w,N,k,y,11,c[33]),k=r(k,T,w,N,m,16,c[34]),N=r(N,k,T,w,P,23,c[35]),w=r(w,N,k,T,a,4,c[36]),T=r(T,w,N,k,h,11,c[37]),k=r(k,T,w,N,g,16,c[38]),N=r(N,k,T,w,v,23,c[39]),w=r(w,N,k,T,O,4,c[40]),T=r(T,w,N,k,u,11,c[41]),k=r(k,T,w,N,p,16,c[42]),N=r(N,k,T,w,d,23,c[43]),w=r(w,N,k,T,b,4,c[44]),T=r(T,w,N,k,_,11,c[45]),k=r(k,T,w,N,S,16,c[46]),w=i(w,N=r(N,k,T,w,l,23,c[47]),k,T,u,6,c[48]),T=i(T,w,N,k,g,10,c[49]),k=i(k,T,w,N,P,15,c[50]),N=i(N,k,T,w,f,21,c[51]),w=i(w,N,k,T,_,6,c[52]),T=i(T,w,N,k,p,10,c[53]),k=i(k,T,w,N,v,15,c[54]),N=i(N,k,T,w,a,21,c[55]),w=i(w,N,k,T,y,6,c[56]),T=i(T,w,N,k,S,10,c[57]),k=i(k,T,w,N,d,15,c[58]),N=i(N,k,T,w,O,21,c[59]),w=i(w,N,k,T,h,6,c[60]),T=i(T,w,N,k,m,10,c[61]),k=i(k,T,w,N,l,15,c[62]),N=i(N,k,T,w,b,21,c[63]);s[0]=s[0]+w|0,s[1]=s[1]+N|0,s[2]=s[2]+k|0,s[3]=s[3]+T|0},_doFinalize:function(){var t=this._data,n=t.words,r=8*this._nDataBytes,i=8*t.sigBytes;n[i>>>5]|=128<<24-i%32;var o=e.floor(r/4294967296);for(n[15+(i+64>>>9<<4)]=16711935&(o<<8|o>>>24)|4278255360&(o<<24|o>>>8),n[14+(i+64>>>9<<4)]=16711935&(r<<8|r>>>24)|4278255360&(r<<24|r>>>8),t.sigBytes=4*(n.length+1),this._process(),n=(t=this._hash).words,r=0;4>r;r++)i=n[r],n[r]=16711935&(i<<8|i>>>24)|4278255360&(i<<24|i>>>8);return t},clone:function(){var e=a.clone.call(this);return e._hash=this._hash.clone(),e}}),o.MD5=a._createHelper(u),o.HmacMD5=a._createHmacHelper(u)}(Math),function(){var e,t=_,n=(e=t.lib).Base,r=e.WordArray,i=(e=t.algo).EvpKDF=n.extend({cfg:n.extend({keySize:4,hasher:e.MD5,iterations:1}),init:function(e){this.cfg=this.cfg.extend(e)},compute:function(e,t){for(var n=(a=this.cfg).hasher.create(),i=r.create(),o=i.words,s=a.keySize,a=a.iterations;o.length<s;){u&&n.update(u);var u=n.update(e).finalize(t);n.reset();for(var c=1;c<a;c++)u=n.finalize(u),n.reset();i.concat(u)}return i.sigBytes=4*s,i}});t.EvpKDF=function(e,t,n){return i.create(n).compute(e,t)}}(),_.lib.Cipher||function(e){var t=(f=_).lib,n=t.Base,r=t.WordArray,i=t.BufferedBlockAlgorithm,o=f.enc.Base64,s=f.algo.EvpKDF,a=t.Cipher=i.extend({cfg:n.extend(),createEncryptor:function(e,t){return this.create(this._ENC_XFORM_MODE,e,t)},createDecryptor:function(e,t){return this.create(this._DEC_XFORM_MODE,e,t)},init:function(e,t,n){this.cfg=this.cfg.extend(n),this._xformMode=e,this._key=t,this.reset()},reset:function(){i.reset.call(this),this._doReset()},process:function(e){return this._append(e),this._process()},finalize:function(e){return e&&this._append(e),this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(e){return{encrypt:function(t,n,r){return("string"==typeof n?d:h).encrypt(e,t,n,r)},decrypt:function(t,n,r){return("string"==typeof n?d:h).decrypt(e,t,n,r)}}}});t.StreamCipher=a.extend({_doFinalize:function(){return this._process(!0)},blockSize:1});var u=f.mode={},c=function(e,t,n){var r=this._iv;r?this._iv=undefined:r=this._prevBlock;for(var i=0;i<n;i++)e[t+i]^=r[i]},l=(t.BlockCipherMode=n.extend({createEncryptor:function(e,t){return this.Encryptor.create(e,t)},createDecryptor:function(e,t){return this.Decryptor.create(e,t)},init:function(e,t){this._cipher=e,this._iv=t}})).extend();l.Encryptor=l.extend({processBlock:function(e,t){var n=this._cipher,r=n.blockSize;c.call(this,e,t,r),n.encryptBlock(e,t),this._prevBlock=e.slice(t,t+r)}}),l.Decryptor=l.extend({processBlock:function(e,t){var n=this._cipher,r=n.blockSize,i=e.slice(t,t+r);n.decryptBlock(e,t),c.call(this,e,t,r),this._prevBlock=i}}),u=u.CBC=l,l=(f.pad={}).Pkcs7={pad:function(e,t){for(var n,i=(n=(n=4*t)-e.sigBytes%n)<<24|n<<16|n<<8|n,o=[],s=0;s<n;s+=4)o.push(i);n=r.create(o,n),e.concat(n)},unpad:function(e){e.sigBytes-=255&e.words[e.sigBytes-1>>>2]}},t.BlockCipher=a.extend({cfg:a.cfg.extend({mode:u,padding:l}),reset:function(){a.reset.call(this);var e=(t=this.cfg).iv,t=t.mode;if(this._xformMode==this._ENC_XFORM_MODE)var n=t.createEncryptor;else n=t.createDecryptor,this._minBufferSize=1;this._mode=n.call(t,this,e&&e.words)},_doProcessBlock:function(e,t){this._mode.processBlock(e,t)},_doFinalize:function(){var e=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){e.pad(this._data,this.blockSize);var t=this._process(!0)}else t=this._process(!0),e.unpad(t);return t},blockSize:4});var p=t.CipherParams=n.extend({init:function(e){this.mixIn(e)},toString:function(e){return(e||this.formatter).stringify(this)}}),h=(u=(f.format={}).OpenSSL={stringify:function(e){var t=e.ciphertext;return((e=e.salt)?r.create([1398893684,1701076831]).concat(e).concat(t):t).toString(o)},parse:function(e){var t=(e=o.parse(e)).words;if(1398893684==t[0]&&1701076831==t[1]){var n=r.create(t.slice(2,4));t.splice(0,4),e.sigBytes-=16}return p.create({ciphertext:e,salt:n})}},t.SerializableCipher=n.extend({cfg:n.extend({format:u}),encrypt:function(e,t,n,r){r=this.cfg.extend(r);var i=e.createEncryptor(n,r);return t=i.finalize(t),i=i.cfg,p.create({ciphertext:t,key:n,iv:i.iv,algorithm:e,mode:i.mode,padding:i.padding,blockSize:e.blockSize,formatter:r.format})},decrypt:function(e,t,n,r){return r=this.cfg.extend(r),t=this._parse(t,r.format),e.createDecryptor(n,r).finalize(t.ciphertext)},_parse:function(e,t){return"string"==typeof e?t.parse(e,this):e}})),f=(f.kdf={}).OpenSSL={execute:function(e,t,n,i){return i||(i=r.random(8)),e=s.create({keySize:t+n}).compute(e,i),n=r.create(e.words.slice(t),4*n),e.sigBytes=4*t,p.create({key:e,iv:n,salt:i})}},d=t.PasswordBasedCipher=h.extend({cfg:h.cfg.extend({kdf:f}),encrypt:function(e,t,n,r){return n=(r=this.cfg.extend(r)).kdf.execute(n,e.keySize,e.ivSize),r.iv=n.iv,(e=h.encrypt.call(this,e,t,n.key,r)).mixIn(n),e},decrypt:function(e,t,n,r){return r=this.cfg.extend(r),t=this._parse(t,r.format),n=r.kdf.execute(n,e.keySize,e.ivSize,t.salt),r.iv=n.iv,h.decrypt.call(this,e,t,n.key,r)}})}(),function(){for(var e=_,t=e.lib.BlockCipher,n=e.algo,r=[],i=[],o=[],s=[],a=[],u=[],c=[],l=[],p=[],h=[],f=[],d=0;256>d;d++)f[d]=128>d?d<<1:d<<1^283;var g=0,y=0;for(d=0;256>d;d++){var b=(b=y^y<<1^y<<2^y<<3^y<<4)>>>8^255&b^99;r[g]=b,i[b]=g;var v=f[g],m=f[v],O=f[m],P=257*f[b]^16843008*b;o[g]=P<<24|P>>>8,s[g]=P<<16|P>>>16,a[g]=P<<8|P>>>24,u[g]=P,P=16843009*O^65537*m^257*v^16843008*g,c[b]=P<<24|P>>>8,l[b]=P<<16|P>>>16,p[b]=P<<8|P>>>24,h[b]=P,g?(g=v^f[f[f[O^v]]],y^=f[f[y]]):g=y=1}var S=[0,1,2,4,8,16,32,64,128,27,54];n=n.AES=t.extend({_doReset:function(){for(var e=(n=this._key).words,t=n.sigBytes/4,n=4*((this._nRounds=t+6)+1),i=this._keySchedule=[],o=0;o<n;o++)if(o<t)i[o]=e[o];else{var s=i[o-1];o%t?6<t&&4==o%t&&(s=r[s>>>24]<<24|r[s>>>16&255]<<16|r[s>>>8&255]<<8|r[255&s]):(s=r[(s=s<<8|s>>>24)>>>24]<<24|r[s>>>16&255]<<16|r[s>>>8&255]<<8|r[255&s],s^=S[o/t|0]<<24),i[o]=i[o-t]^s}for(e=this._invKeySchedule=[],t=0;t<n;t++)o=n-t,s=t%4?i[o]:i[o-4],e[t]=4>t||4>=o?s:c[r[s>>>24]]^l[r[s>>>16&255]]^p[r[s>>>8&255]]^h[r[255&s]]},encryptBlock:function(e,t){this._doCryptBlock(e,t,this._keySchedule,o,s,a,u,r)},decryptBlock:function(e,t){var n=e[t+1];e[t+1]=e[t+3],e[t+3]=n,this._doCryptBlock(e,t,this._invKeySchedule,c,l,p,h,i),n=e[t+1],e[t+1]=e[t+3],e[t+3]=n},_doCryptBlock:function(e,t,n,r,i,o,s,a){for(var u=this._nRounds,c=e[t]^n[0],l=e[t+1]^n[1],p=e[t+2]^n[2],h=e[t+3]^n[3],f=4,d=1;d<u;d++){var g=r[c>>>24]^i[l>>>16&255]^o[p>>>8&255]^s[255&h]^n[f++],y=r[l>>>24]^i[p>>>16&255]^o[h>>>8&255]^s[255&c]^n[f++],b=r[p>>>24]^i[h>>>16&255]^o[c>>>8&255]^s[255&l]^n[f++];h=r[h>>>24]^i[c>>>16&255]^o[l>>>8&255]^s[255&p]^n[f++],c=g,l=y,p=b}g=(a[c>>>24]<<24|a[l>>>16&255]<<16|a[p>>>8&255]<<8|a[255&h])^n[f++],y=(a[l>>>24]<<24|a[p>>>16&255]<<16|a[h>>>8&255]<<8|a[255&c])^n[f++],b=(a[p>>>24]<<24|a[h>>>16&255]<<16|a[c>>>8&255]<<8|a[255&l])^n[f++],h=(a[h>>>24]<<24|a[c>>>16&255]<<16|a[l>>>8&255]<<8|a[255&p])^n[f++],e[t]=g,e[t+1]=y,e[t+2]=b,e[t+3]=h},keySize:8});e.AES=t._createHelper(n)}(),_.mode.ECB=((y=_.lib.BlockCipherMode.extend()).Encryptor=y.extend({processBlock:function(e,t){this._cipher.encryptBlock(e,t)}}),y.Decryptor=y.extend({processBlock:function(e,t){this._cipher.decryptBlock(e,t)}}),y);var O=_;function P(e){var t,n=[];for(t=0;t<e.length;t+=1)n[t/4|0]|=e[t]<<24-8*t;return O.lib.WordArray.create(n,e.length)}var S=function(){function e(e){var t=e.config;this._config=t,this._iv="0123456789012345",this._allowedKeyEncodings=["hex","utf8","base64","binary"],this._allowedKeyLengths=[128,256],this._allowedModes=["ecb","cbc"],this._defaultOptions={encryptKey:!0,keyEncoding:"utf8",keyLength:256,mode:"cbc"}}return e.prototype.HMACSHA256=function(e){return O.HmacSHA256(e,this._config.secretKey).toString(O.enc.Base64)},e.prototype.SHA256=function(e){return O.SHA256(e).toString(O.enc.Hex)},e.prototype._parseOptions=function(e){var t=e||{};return t.hasOwnProperty("encryptKey")||(t.encryptKey=this._defaultOptions.encryptKey),t.hasOwnProperty("keyEncoding")||(t.keyEncoding=this._defaultOptions.keyEncoding),t.hasOwnProperty("keyLength")||(t.keyLength=this._defaultOptions.keyLength),t.hasOwnProperty("mode")||(t.mode=this._defaultOptions.mode),-1===this._allowedKeyEncodings.indexOf(t.keyEncoding.toLowerCase())&&(t.keyEncoding=this._defaultOptions.keyEncoding),-1===this._allowedKeyLengths.indexOf(parseInt(t.keyLength,10))&&(t.keyLength=this._defaultOptions.keyLength),-1===this._allowedModes.indexOf(t.mode.toLowerCase())&&(t.mode=this._defaultOptions.mode),t},e.prototype._decodeKey=function(e,t){return"base64"===t.keyEncoding?O.enc.Base64.parse(e):"hex"===t.keyEncoding?O.enc.Hex.parse(e):e},e.prototype._getPaddedKey=function(e,t){return e=this._decodeKey(e,t),t.encryptKey?O.enc.Utf8.parse(this.SHA256(e).slice(0,32)):e},e.prototype._getMode=function(e){return"ecb"===e.mode?O.mode.ECB:O.mode.CBC},e.prototype._getIV=function(e){return"cbc"===e.mode?O.enc.Utf8.parse(this._iv):null},e.prototype._getRandomIV=function(){return O.lib.WordArray.random(16)},e.prototype.encrypt=function(e,t,n){return this._config.customEncrypt?this._config.customEncrypt(e):this.pnEncrypt(e,t,n)},e.prototype.decrypt=function(e,t,n){return this._config.customDecrypt?this._config.customDecrypt(e):this.pnDecrypt(e,t,n)},e.prototype.pnEncrypt=function(e,t,n){if(!t&&!this._config.cipherKey)return e;n=this._parseOptions(n);var r=this._getMode(n),i=this._getPaddedKey(t||this._config.cipherKey,n);if(this._config.useRandomIVs){var o=this._getRandomIV(),s=O.AES.encrypt(e,i,{iv:o,mode:r}).ciphertext;return o.clone().concat(s.clone()).toString(O.enc.Base64)}var a=this._getIV(n);return O.AES.encrypt(e,i,{iv:a,mode:r}).ciphertext.toString(O.enc.Base64)||e},e.prototype.pnDecrypt=function(e,t,n){if(!t&&!this._config.cipherKey)return e;n=this._parseOptions(n);var r=this._getMode(n),i=this._getPaddedKey(t||this._config.cipherKey,n);if(this._config.useRandomIVs){var o=P((u=Buffer.from(e,"base64")).slice(0,16)),s=P(u.slice(16));try{var a=O.AES.decrypt({ciphertext:s},i,{iv:o,mode:r}).toString(O.enc.Utf8);return JSON.parse(a)}catch(e){return null}}else{o=this._getIV(n);try{var u=O.enc.Base64.parse(e);a=O.AES.decrypt({ciphertext:u},i,{iv:o,mode:r}).toString(O.enc.Utf8);return JSON.parse(a)}catch(e){return null}}},e}(),w=function(){function e(e){var t=e.timeEndpoint;this._timeEndpoint=t}return e.prototype.onReconnection=function(e){this._reconnectionCallback=e},e.prototype.startPolling=function(){this._timeTimer=setInterval(this._performTimeLoop.bind(this),3e3)},e.prototype.stopPolling=function(){clearInterval(this._timeTimer)},e.prototype._performTimeLoop=function(){var e=this;this._timeEndpoint((function(t){t.error||(clearInterval(e._timeTimer),e._reconnectionCallback())}))},e}(),T=function(){function e(e){var t=e.config;this.hashHistory=[],this._config=t}return e.prototype.getKey=function(e){var t=function(e){var t=0;if(0===e.length)return t;for(var n=0;n<e.length;n+=1)t=(t<<5)-t+e.charCodeAt(n),t&=t;return t}(JSON.stringify(e.payload)).toString(),n=e.publishMetaData.publishTimetoken;return"".concat(n,"-").concat(t)},e.prototype.isDuplicate=function(e){return this.hashHistory.includes(this.getKey(e))},e.prototype.addEntry=function(e){this.hashHistory.length>=this._config.maximumCacheSize&&this.hashHistory.shift(),this.hashHistory.push(this.getKey(e))},e.prototype.clearHistory=function(){this.hashHistory=[]},e}();function k(e){return encodeURIComponent(e).replace(/[!~*'()]/g,(function(e){return"%".concat(e.charCodeAt(0).toString(16).toUpperCase())}))}function N(e){return function(e){var t=[];return Object.keys(e).forEach((function(e){return t.push(e)})),t}(e).sort()}var C={signPamFromParams:function(e){return N(e).map((function(t){return"".concat(t,"=").concat(k(e[t]))})).join("&")},endsWith:function(e,t){return-1!==e.indexOf(t,this.length-t.length)},createPromise:function(){var e,t;return{promise:new Promise((function(n,r){e=n,t=r})),reject:t,fulfill:e}},encodeString:k},E={PNNetworkUpCategory:"PNNetworkUpCategory",PNNetworkDownCategory:"PNNetworkDownCategory",PNNetworkIssuesCategory:"PNNetworkIssuesCategory",PNTimeoutCategory:"PNTimeoutCategory",PNBadRequestCategory:"PNBadRequestCategory",PNAccessDeniedCategory:"PNAccessDeniedCategory",PNUnknownCategory:"PNUnknownCategory",PNReconnectedCategory:"PNReconnectedCategory",PNConnectedCategory:"PNConnectedCategory",PNRequestMessageCountExceededCategory:"PNRequestMessageCountExceededCategory"},A=function(){function e(e){var t=e.subscribeEndpoint,n=e.leaveEndpoint,r=e.heartbeatEndpoint,i=e.setStateEndpoint,o=e.timeEndpoint,s=e.getFileUrl,a=e.config,u=e.crypto,c=e.listenerManager;this._listenerManager=c,this._config=a,this._leaveEndpoint=n,this._heartbeatEndpoint=r,this._setStateEndpoint=i,this._subscribeEndpoint=t,this._getFileUrl=s,this._crypto=u,this._channels={},this._presenceChannels={},this._heartbeatChannels={},this._heartbeatChannelGroups={},this._channelGroups={},this._presenceChannelGroups={},this._pendingChannelSubscriptions=[],this._pendingChannelGroupSubscriptions=[],this._currentTimetoken=0,this._lastTimetoken=0,this._storedTimetoken=null,this._subscriptionStatusAnnounced=!1,this._isOnline=!0,this._reconnectionManager=new w({timeEndpoint:o}),this._dedupingManager=new T({config:a})}return e.prototype.adaptStateChange=function(e,t){var n=this,r=e.state,i=e.channels,o=void 0===i?[]:i,s=e.channelGroups,a=void 0===s?[]:s;return o.forEach((function(e){e in n._channels&&(n._channels[e].state=r)})),a.forEach((function(e){e in n._channelGroups&&(n._channelGroups[e].state=r)})),this._setStateEndpoint({state:r,channels:o,channelGroups:a},t)},e.prototype.adaptPresenceChange=function(e){var t=this,n=e.connected,r=e.channels,i=void 0===r?[]:r,o=e.channelGroups,s=void 0===o?[]:o;n?(i.forEach((function(e){t._heartbeatChannels[e]={state:{}}})),s.forEach((function(e){t._heartbeatChannelGroups[e]={state:{}}}))):(i.forEach((function(e){e in t._heartbeatChannels&&delete t._heartbeatChannels[e]})),s.forEach((function(e){e in t._heartbeatChannelGroups&&delete t._heartbeatChannelGroups[e]})),!1===this._config.suppressLeaveEvents&&this._leaveEndpoint({channels:i,channelGroups:s},(function(e){t._listenerManager.announceStatus(e)}))),this.reconnect()},e.prototype.adaptSubscribeChange=function(e){var t=this,n=e.timetoken,r=e.channels,i=void 0===r?[]:r,o=e.channelGroups,s=void 0===o?[]:o,a=e.withPresence,u=void 0!==a&&a,c=e.withHeartbeats,l=void 0!==c&&c;this._config.subscribeKey&&""!==this._config.subscribeKey?(n&&(this._lastTimetoken=this._currentTimetoken,this._currentTimetoken=n),"0"!==this._currentTimetoken&&0!==this._currentTimetoken&&(this._storedTimetoken=this._currentTimetoken,this._currentTimetoken=0),i.forEach((function(e){t._channels[e]={state:{}},u&&(t._presenceChannels[e]={}),(l||t._config.getHeartbeatInterval())&&(t._heartbeatChannels[e]={}),t._pendingChannelSubscriptions.push(e)})),s.forEach((function(e){t._channelGroups[e]={state:{}},u&&(t._presenceChannelGroups[e]={}),(l||t._config.getHeartbeatInterval())&&(t._heartbeatChannelGroups[e]={}),t._pendingChannelGroupSubscriptions.push(e)})),this._subscriptionStatusAnnounced=!1,this.reconnect()):console&&console.log&&console.log("subscribe key missing; aborting subscribe")},e.prototype.adaptUnsubscribeChange=function(e,t){var n=this,r=e.channels,i=void 0===r?[]:r,o=e.channelGroups,s=void 0===o?[]:o,a=[],u=[];i.forEach((function(e){e in n._channels&&(delete n._channels[e],a.push(e),e in n._heartbeatChannels&&delete n._heartbeatChannels[e]),e in n._presenceChannels&&(delete n._presenceChannels[e],a.push(e))})),s.forEach((function(e){e in n._channelGroups&&(delete n._channelGroups[e],u.push(e),e in n._heartbeatChannelGroups&&delete n._heartbeatChannelGroups[e]),e in n._presenceChannelGroups&&(delete n._presenceChannelGroups[e],u.push(e))})),0===a.length&&0===u.length||(!1!==this._config.suppressLeaveEvents||t||this._leaveEndpoint({channels:a,channelGroups:u},(function(e){e.affectedChannels=a,e.affectedChannelGroups=u,e.currentTimetoken=n._currentTimetoken,e.lastTimetoken=n._lastTimetoken,n._listenerManager.announceStatus(e)})),0===Object.keys(this._channels).length&&0===Object.keys(this._presenceChannels).length&&0===Object.keys(this._channelGroups).length&&0===Object.keys(this._presenceChannelGroups).length&&(this._lastTimetoken=0,this._currentTimetoken=0,this._storedTimetoken=null,this._region=null,this._reconnectionManager.stopPolling()),this.reconnect())},e.prototype.unsubscribeAll=function(e){this.adaptUnsubscribeChange({channels:this.getSubscribedChannels(),channelGroups:this.getSubscribedChannelGroups()},e)},e.prototype.getHeartbeatChannels=function(){return Object.keys(this._heartbeatChannels)},e.prototype.getHeartbeatChannelGroups=function(){return Object.keys(this._heartbeatChannelGroups)},e.prototype.getSubscribedChannels=function(){return Object.keys(this._channels)},e.prototype.getSubscribedChannelGroups=function(){return Object.keys(this._channelGroups)},e.prototype.reconnect=function(){this._startSubscribeLoop(),this._registerHeartbeatTimer()},e.prototype.disconnect=function(){this._stopSubscribeLoop(),this._stopHeartbeatTimer(),this._reconnectionManager.stopPolling()},e.prototype._registerHeartbeatTimer=function(){this._stopHeartbeatTimer(),0!==this._config.getHeartbeatInterval()&&void 0!==this._config.getHeartbeatInterval()&&(this._performHeartbeatLoop(),this._heartbeatTimer=setInterval(this._performHeartbeatLoop.bind(this),1e3*this._config.getHeartbeatInterval()))},e.prototype._stopHeartbeatTimer=function(){this._heartbeatTimer&&(clearInterval(this._heartbeatTimer),this._heartbeatTimer=null)},e.prototype._performHeartbeatLoop=function(){var e=this,t=this.getHeartbeatChannels(),n=this.getHeartbeatChannelGroups(),r={};if(0!==t.length||0!==n.length){this.getSubscribedChannels().forEach((function(t){var n=e._channels[t].state;Object.keys(n).length&&(r[t]=n)})),this.getSubscribedChannelGroups().forEach((function(t){var n=e._channelGroups[t].state;Object.keys(n).length&&(r[t]=n)}));this._heartbeatEndpoint({channels:t,channelGroups:n,state:r},function(t){t.error&&e._config.announceFailedHeartbeats&&e._listenerManager.announceStatus(t),t.error&&e._config.autoNetworkDetection&&e._isOnline&&(e._isOnline=!1,e.disconnect(),e._listenerManager.announceNetworkDown(),e.reconnect()),!t.error&&e._config.announceSuccessfulHeartbeats&&e._listenerManager.announceStatus(t)}.bind(this))}},e.prototype._startSubscribeLoop=function(){var e=this;this._stopSubscribeLoop();var t={},n=[],r=[];if(Object.keys(this._channels).forEach((function(r){var i=e._channels[r].state;Object.keys(i).length&&(t[r]=i),n.push(r)})),Object.keys(this._presenceChannels).forEach((function(e){n.push("".concat(e,"-pnpres"))})),Object.keys(this._channelGroups).forEach((function(n){var i=e._channelGroups[n].state;Object.keys(i).length&&(t[n]=i),r.push(n)})),Object.keys(this._presenceChannelGroups).forEach((function(e){r.push("".concat(e,"-pnpres"))})),0!==n.length||0!==r.length){var i={channels:n,channelGroups:r,state:t,timetoken:this._currentTimetoken,filterExpression:this._config.filterExpression,region:this._region};this._subscribeCall=this._subscribeEndpoint(i,this._processSubscribeResponse.bind(this))}},e.prototype._processSubscribeResponse=function(e,t){var n=this;if(e.error){if(e.errorData&&"Aborted"===e.errorData.message)return;e.category===E.PNTimeoutCategory?this._startSubscribeLoop():e.category===E.PNNetworkIssuesCategory?(this.disconnect(),e.error&&this._config.autoNetworkDetection&&this._isOnline&&(this._isOnline=!1,this._listenerManager.announceNetworkDown()),this._reconnectionManager.onReconnection((function(){n._config.autoNetworkDetection&&!n._isOnline&&(n._isOnline=!0,n._listenerManager.announceNetworkUp()),n.reconnect(),n._subscriptionStatusAnnounced=!0;var t={category:E.PNReconnectedCategory,operation:e.operation,lastTimetoken:n._lastTimetoken,currentTimetoken:n._currentTimetoken};n._listenerManager.announceStatus(t)})),this._reconnectionManager.startPolling(),this._listenerManager.announceStatus(e)):e.category===E.PNBadRequestCategory?(this._stopHeartbeatTimer(),this._listenerManager.announceStatus(e)):this._listenerManager.announceStatus(e)}else{if(this._storedTimetoken?(this._currentTimetoken=this._storedTimetoken,this._storedTimetoken=null):(this._lastTimetoken=this._currentTimetoken,this._currentTimetoken=t.metadata.timetoken),!this._subscriptionStatusAnnounced){var r={};r.category=E.PNConnectedCategory,r.operation=e.operation,r.affectedChannels=this._pendingChannelSubscriptions,r.subscribedChannels=this.getSubscribedChannels(),r.affectedChannelGroups=this._pendingChannelGroupSubscriptions,r.lastTimetoken=this._lastTimetoken,r.currentTimetoken=this._currentTimetoken,this._subscriptionStatusAnnounced=!0,this._listenerManager.announceStatus(r),this._pendingChannelSubscriptions=[],this._pendingChannelGroupSubscriptions=[]}var i=t.messages||[],o=this._config,s=o.requestMessageCountThreshold,a=o.dedupeOnSubscribe;if(s&&i.length>=s){var u={};u.category=E.PNRequestMessageCountExceededCategory,u.operation=e.operation,this._listenerManager.announceStatus(u)}i.forEach((function(e){var t=e.channel,r=e.subscriptionMatch,i=e.publishMetaData;if(t===r&&(r=null),a){if(n._dedupingManager.isDuplicate(e))return;n._dedupingManager.addEntry(e)}if(C.endsWith(e.channel,"-pnpres"))(u={channel:null,subscription:null}).actualChannel=null!=r?t:null,u.subscribedChannel=null!=r?r:t,t&&(u.channel=t.substring(0,t.lastIndexOf("-pnpres"))),r&&(u.subscription=r.substring(0,r.lastIndexOf("-pnpres"))),u.action=e.payload.action,u.state=e.payload.data,u.timetoken=i.publishTimetoken,u.occupancy=e.payload.occupancy,u.uuid=e.payload.uuid,u.timestamp=e.payload.timestamp,e.payload.join&&(u.join=e.payload.join),e.payload.leave&&(u.leave=e.payload.leave),e.payload.timeout&&(u.timeout=e.payload.timeout),n._listenerManager.announcePresence(u);else if(1===e.messageType){(u={channel:null,subscription:null}).channel=t,u.subscription=r,u.timetoken=i.publishTimetoken,u.publisher=e.issuingClientId,e.userMetadata&&(u.userMetadata=e.userMetadata),u.message=e.payload,n._listenerManager.announceSignal(u)}else if(2===e.messageType){(u={channel:null,subscription:null}).channel=t,u.subscription=r,u.timetoken=i.publishTimetoken,u.publisher=e.issuingClientId,e.userMetadata&&(u.userMetadata=e.userMetadata),u.message={event:e.payload.event,type:e.payload.type,data:e.payload.data},n._listenerManager.announceObjects(u),"user"===e.payload.type?n._listenerManager.announceUser(u):"space"===e.payload.type?n._listenerManager.announceSpace(u):"membership"===e.payload.type&&n._listenerManager.announceMembership(u)}else if(3===e.messageType){(u={}).channel=t,u.subscription=r,u.timetoken=i.publishTimetoken,u.publisher=e.issuingClientId,u.data={messageTimetoken:e.payload.data.messageTimetoken,actionTimetoken:e.payload.data.actionTimetoken,type:e.payload.data.type,uuid:e.issuingClientId,value:e.payload.data.value},u.event=e.payload.event,n._listenerManager.announceMessageAction(u)}else if(4===e.messageType){(u={}).channel=t,u.subscription=r,u.timetoken=i.publishTimetoken,u.publisher=e.issuingClientId;var o=e.payload;if(n._config.cipherKey){var s=n._crypto.decrypt(e.payload);"object"==typeof s&&null!==s&&(o=s)}e.userMetadata&&(u.userMetadata=e.userMetadata),u.message=o.message,u.file={id:o.file.id,name:o.file.name,url:n._getFileUrl({id:o.file.id,name:o.file.name,channel:t})},n._listenerManager.announceFile(u)}else{var u;(u={channel:null,subscription:null}).actualChannel=null!=r?t:null,u.subscribedChannel=null!=r?r:t,u.channel=t,u.subscription=r,u.timetoken=i.publishTimetoken,u.publisher=e.issuingClientId,e.userMetadata&&(u.userMetadata=e.userMetadata),n._config.cipherKey?u.message=n._crypto.decrypt(e.payload):u.message=e.payload,n._listenerManager.announceMessage(u)}})),this._region=t.metadata.region,this._startSubscribeLoop()}},e.prototype._stopSubscribeLoop=function(){this._subscribeCall&&("function"==typeof this._subscribeCall.abort&&this._subscribeCall.abort(),this._subscribeCall=null)},e}(),M={PNTimeOperation:"PNTimeOperation",PNHistoryOperation:"PNHistoryOperation",PNDeleteMessagesOperation:"PNDeleteMessagesOperation",PNFetchMessagesOperation:"PNFetchMessagesOperation",PNMessageCounts:"PNMessageCountsOperation",PNSubscribeOperation:"PNSubscribeOperation",PNUnsubscribeOperation:"PNUnsubscribeOperation",PNPublishOperation:"PNPublishOperation",PNSignalOperation:"PNSignalOperation",PNAddMessageActionOperation:"PNAddActionOperation",PNRemoveMessageActionOperation:"PNRemoveMessageActionOperation",PNGetMessageActionsOperation:"PNGetMessageActionsOperation",PNCreateUserOperation:"PNCreateUserOperation",PNUpdateUserOperation:"PNUpdateUserOperation",PNDeleteUserOperation:"PNDeleteUserOperation",PNGetUserOperation:"PNGetUsersOperation",PNGetUsersOperation:"PNGetUsersOperation",PNCreateSpaceOperation:"PNCreateSpaceOperation",PNUpdateSpaceOperation:"PNUpdateSpaceOperation",PNDeleteSpaceOperation:"PNDeleteSpaceOperation",PNGetSpaceOperation:"PNGetSpacesOperation",PNGetSpacesOperation:"PNGetSpacesOperation",PNGetMembersOperation:"PNGetMembersOperation",PNUpdateMembersOperation:"PNUpdateMembersOperation",PNGetMembershipsOperation:"PNGetMembershipsOperation",PNUpdateMembershipsOperation:"PNUpdateMembershipsOperation",PNListFilesOperation:"PNListFilesOperation",PNGenerateUploadUrlOperation:"PNGenerateUploadUrlOperation",PNPublishFileOperation:"PNPublishFileOperation",PNGetFileUrlOperation:"PNGetFileUrlOperation",PNDownloadFileOperation:"PNDownloadFileOperation",PNGetAllUUIDMetadataOperation:"PNGetAllUUIDMetadataOperation",PNGetUUIDMetadataOperation:"PNGetUUIDMetadataOperation",PNSetUUIDMetadataOperation:"PNSetUUIDMetadataOperation",PNRemoveUUIDMetadataOperation:"PNRemoveUUIDMetadataOperation",PNGetAllChannelMetadataOperation:"PNGetAllChannelMetadataOperation",PNGetChannelMetadataOperation:"PNGetChannelMetadataOperation",PNSetChannelMetadataOperation:"PNSetChannelMetadataOperation",PNRemoveChannelMetadataOperation:"PNRemoveChannelMetadataOperation",PNSetMembersOperation:"PNSetMembersOperation",PNSetMembershipsOperation:"PNSetMembershipsOperation",PNPushNotificationEnabledChannelsOperation:"PNPushNotificationEnabledChannelsOperation",PNRemoveAllPushNotificationsOperation:"PNRemoveAllPushNotificationsOperation",PNWhereNowOperation:"PNWhereNowOperation",PNSetStateOperation:"PNSetStateOperation",PNHereNowOperation:"PNHereNowOperation",PNGetStateOperation:"PNGetStateOperation",PNHeartbeatOperation:"PNHeartbeatOperation",PNChannelGroupsOperation:"PNChannelGroupsOperation",PNRemoveGroupOperation:"PNRemoveGroupOperation",PNChannelsForGroupOperation:"PNChannelsForGroupOperation",PNAddChannelsToGroupOperation:"PNAddChannelsToGroupOperation",PNRemoveChannelsFromGroupOperation:"PNRemoveChannelsFromGroupOperation",PNAccessManagerGrant:"PNAccessManagerGrant",PNAccessManagerGrantToken:"PNAccessManagerGrantToken",PNAccessManagerAudit:"PNAccessManagerAudit",PNAccessManagerRevokeToken:"PNAccessManagerRevokeToken",PNHandshakeOperation:"PNHandshakeOperation",PNReceiveMessagesOperation:"PNReceiveMessagesOperation"},R=function(){function e(e){this._maximumSamplesCount=100,this._trackedLatencies={},this._latencies={},this._maximumSamplesCount=e.maximumSamplesCount||this._maximumSamplesCount}return e.prototype.operationsLatencyForRequest=function(){var e=this,t={};return Object.keys(this._latencies).forEach((function(n){var r=e._latencies[n],i=e._averageLatency(r);i>0&&(t["l_".concat(n)]=i)})),t},e.prototype.startLatencyMeasure=function(e,t){e!==M.PNSubscribeOperation&&t&&(this._trackedLatencies[t]=Date.now())},e.prototype.stopLatencyMeasure=function(e,t){if(e!==M.PNSubscribeOperation&&t){var n=this._endpointName(e),r=this._latencies[n],i=this._trackedLatencies[t];r||(this._latencies[n]=[],r=this._latencies[n]),r.push(Date.now()-i),r.length>this._maximumSamplesCount&&r.splice(0,r.length-this._maximumSamplesCount),delete this._trackedLatencies[t]}},e.prototype._averageLatency=function(e){return Math.floor(e.reduce((function(e,t){return e+t}),0)/e.length)},e.prototype._endpointName=function(e){var t=null;switch(e){case M.PNPublishOperation:t="pub";break;case M.PNSignalOperation:t="sig";break;case M.PNHistoryOperation:case M.PNFetchMessagesOperation:case M.PNDeleteMessagesOperation:case M.PNMessageCounts:t="hist";break;case M.PNUnsubscribeOperation:case M.PNWhereNowOperation:case M.PNHereNowOperation:case M.PNHeartbeatOperation:case M.PNSetStateOperation:case M.PNGetStateOperation:t="pres";break;case M.PNAddChannelsToGroupOperation:case M.PNRemoveChannelsFromGroupOperation:case M.PNChannelGroupsOperation:case M.PNRemoveGroupOperation:case M.PNChannelsForGroupOperation:t="cg";break;case M.PNPushNotificationEnabledChannelsOperation:case M.PNRemoveAllPushNotificationsOperation:t="push";break;case M.PNCreateUserOperation:case M.PNUpdateUserOperation:case M.PNDeleteUserOperation:case M.PNGetUserOperation:case M.PNGetUsersOperation:case M.PNCreateSpaceOperation:case M.PNUpdateSpaceOperation:case M.PNDeleteSpaceOperation:case M.PNGetSpaceOperation:case M.PNGetSpacesOperation:case M.PNGetMembersOperation:case M.PNUpdateMembersOperation:case M.PNGetMembershipsOperation:case M.PNUpdateMembershipsOperation:t="obj";break;case M.PNAddMessageActionOperation:case M.PNRemoveMessageActionOperation:case M.PNGetMessageActionsOperation:t="msga";break;case M.PNAccessManagerGrant:case M.PNAccessManagerAudit:t="pam";break;case M.PNAccessManagerGrantToken:case M.PNAccessManagerRevokeToken:t="pamv3";break;default:t="time"}return t},e}(),j=function(){function e(e,t,n){this._payload=e,this._setDefaultPayloadStructure(),this.title=t,this.body=n}return Object.defineProperty(e.prototype,"payload",{get:function(){return this._payload},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"title",{set:function(e){this._title=e},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"subtitle",{set:function(e){this._subtitle=e},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"body",{set:function(e){this._body=e},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"badge",{set:function(e){this._badge=e},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"sound",{set:function(e){this._sound=e},enumerable:!1,configurable:!0}),e.prototype._setDefaultPayloadStructure=function(){},e.prototype.toObject=function(){return{}},e}(),U=function(e){function r(){return null!==e&&e.apply(this,arguments)||this}return t(r,e),Object.defineProperty(r.prototype,"configurations",{set:function(e){e&&e.length&&(this._configurations=e)},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"notification",{get:function(){return this._payload.aps},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"title",{get:function(){return this._title},set:function(e){e&&e.length&&(this._payload.aps.alert.title=e,this._title=e)},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"subtitle",{get:function(){return this._subtitle},set:function(e){e&&e.length&&(this._payload.aps.alert.subtitle=e,this._subtitle=e)},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"body",{get:function(){return this._body},set:function(e){e&&e.length&&(this._payload.aps.alert.body=e,this._body=e)},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"badge",{get:function(){return this._badge},set:function(e){null!=e&&(this._payload.aps.badge=e,this._badge=e)},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"sound",{get:function(){return this._sound},set:function(e){e&&e.length&&(this._payload.aps.sound=e,this._sound=e)},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"silent",{set:function(e){this._isSilent=e},enumerable:!1,configurable:!0}),r.prototype._setDefaultPayloadStructure=function(){this._payload.aps={alert:{}}},r.prototype.toObject=function(){var e=this,t=n({},this._payload),r=t.aps,i=r.alert;if(this._isSilent&&(r["content-available"]=1),"apns2"===this._apnsPushType){if(!this._configurations||!this._configurations.length)throw new ReferenceError("APNS2 configuration is missing");var o=[];this._configurations.forEach((function(t){o.push(e._objectFromAPNS2Configuration(t))})),o.length&&(t.pn_push=o)}return i&&Object.keys(i).length||delete r.alert,this._isSilent&&(delete r.alert,delete r.badge,delete r.sound,i={}),this._isSilent||Object.keys(i).length?t:null},r.prototype._objectFromAPNS2Configuration=function(e){var t=this;if(!e.targets||!e.targets.length)throw new ReferenceError("At least one APNS2 target should be provided");var n=[];e.targets.forEach((function(e){n.push(t._objectFromAPNSTarget(e))}));var r=e.collapseId,i=e.expirationDate,o={auth_method:"token",targets:n,version:"v2"};return r&&r.length&&(o.collapse_id=r),i&&(o.expiration=i.toISOString()),o},r.prototype._objectFromAPNSTarget=function(e){if(!e.topic||!e.topic.length)throw new TypeError("Target 'topic' undefined.");var t=e.topic,n=e.environment,r=void 0===n?"development":n,i=e.excludedDevices,o=void 0===i?[]:i,s={topic:t,environment:r};return o.length&&(s.excluded_devices=o),s},r}(j),x=function(e){function r(){return null!==e&&e.apply(this,arguments)||this}return t(r,e),Object.defineProperty(r.prototype,"backContent",{get:function(){return this._backContent},set:function(e){e&&e.length&&(this._payload.back_content=e,this._backContent=e)},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"backTitle",{get:function(){return this._backTitle},set:function(e){e&&e.length&&(this._payload.back_title=e,this._backTitle=e)},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"count",{get:function(){return this._count},set:function(e){null!=e&&(this._payload.count=e,this._count=e)},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"title",{get:function(){return this._title},set:function(e){e&&e.length&&(this._payload.title=e,this._title=e)},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"type",{get:function(){return this._type},set:function(e){e&&e.length&&(this._payload.type=e,this._type=e)},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"subtitle",{get:function(){return this.backTitle},set:function(e){this.backTitle=e},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"body",{get:function(){return this.backContent},set:function(e){this.backContent=e},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"badge",{get:function(){return this.count},set:function(e){this.count=e},enumerable:!1,configurable:!0}),r.prototype.toObject=function(){return Object.keys(this._payload).length?n({},this._payload):null},r}(j),D=function(e){function r(){return null!==e&&e.apply(this,arguments)||this}return t(r,e),Object.defineProperty(r.prototype,"notification",{get:function(){return this._payload.notification},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"data",{get:function(){return this._payload.data},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"title",{get:function(){return this._title},set:function(e){e&&e.length&&(this._payload.notification.title=e,this._title=e)},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"body",{get:function(){return this._body},set:function(e){e&&e.length&&(this._payload.notification.body=e,this._body=e)},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"sound",{get:function(){return this._sound},set:function(e){e&&e.length&&(this._payload.notification.sound=e,this._sound=e)},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"icon",{get:function(){return this._icon},set:function(e){e&&e.length&&(this._payload.notification.icon=e,this._icon=e)},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"tag",{get:function(){return this._tag},set:function(e){e&&e.length&&(this._payload.notification.tag=e,this._tag=e)},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"silent",{set:function(e){this._isSilent=e},enumerable:!1,configurable:!0}),r.prototype._setDefaultPayloadStructure=function(){this._payload.notification={},this._payload.data={}},r.prototype.toObject=function(){var e=n({},this._payload.data),t=null,r={};if(Object.keys(this._payload).length>2){var i=this._payload;i.notification,i.data;var o=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var i=0;for(r=Object.getOwnPropertySymbols(e);i<r.length;i++)t.indexOf(r[i])<0&&Object.prototype.propertyIsEnumerable.call(e,r[i])&&(n[r[i]]=e[r[i]])}return n}(i,["notification","data"]);e=n(n({},e),o)}return this._isSilent?e.notification=this._payload.notification:t=this._payload.notification,Object.keys(e).length&&(r.data=e),t&&Object.keys(t).length&&(r.notification=t),Object.keys(r).length?r:null},r}(j),I=function(){function e(e,t){this._payload={apns:{},mpns:{},fcm:{}},this._title=e,this._body=t,this.apns=new U(this._payload.apns,e,t),this.mpns=new x(this._payload.mpns,e,t),this.fcm=new D(this._payload.fcm,e,t)}return Object.defineProperty(e.prototype,"debugging",{set:function(e){this._debugging=e},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"title",{get:function(){return this._title},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"body",{get:function(){return this._body},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"subtitle",{get:function(){return this._subtitle},set:function(e){this._subtitle=e,this.apns.subtitle=e,this.mpns.subtitle=e,this.fcm.subtitle=e},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"badge",{get:function(){return this._badge},set:function(e){this._badge=e,this.apns.badge=e,this.mpns.badge=e,this.fcm.badge=e},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"sound",{get:function(){return this._sound},set:function(e){this._sound=e,this.apns.sound=e,this.mpns.sound=e,this.fcm.sound=e},enumerable:!1,configurable:!0}),e.prototype.buildPayload=function(e){var t={};if(e.includes("apns")||e.includes("apns2")){this.apns._apnsPushType=e.includes("apns")?"apns":"apns2";var n=this.apns.toObject();n&&Object.keys(n).length&&(t.pn_apns=n)}if(e.includes("mpns")){var r=this.mpns.toObject();r&&Object.keys(r).length&&(t.pn_mpns=r)}if(e.includes("fcm")){var i=this.fcm.toObject();i&&Object.keys(i).length&&(t.pn_gcm=i)}return Object.keys(t).length&&this._debugging&&(t.pn_debug=!0),t},e}(),G=function(){function e(){this._listeners=[]}return e.prototype.addListener=function(e){this._listeners.push(e)},e.prototype.removeListener=function(e){var t=[];this._listeners.forEach((function(n){n!==e&&t.push(n)})),this._listeners=t},e.prototype.removeAllListeners=function(){this._listeners=[]},e.prototype.announcePresence=function(e){this._listeners.forEach((function(t){t.presence&&t.presence(e)}))},e.prototype.announceStatus=function(e){this._listeners.forEach((function(t){t.status&&t.status(e)}))},e.prototype.announceMessage=function(e){this._listeners.forEach((function(t){t.message&&t.message(e)}))},e.prototype.announceSignal=function(e){this._listeners.forEach((function(t){t.signal&&t.signal(e)}))},e.prototype.announceMessageAction=function(e){this._listeners.forEach((function(t){t.messageAction&&t.messageAction(e)}))},e.prototype.announceFile=function(e){this._listeners.forEach((function(t){t.file&&t.file(e)}))},e.prototype.announceObjects=function(e){this._listeners.forEach((function(t){t.objects&&t.objects(e)}))},e.prototype.announceUser=function(e){this._listeners.forEach((function(t){t.user&&t.user(e)}))},e.prototype.announceSpace=function(e){this._listeners.forEach((function(t){t.space&&t.space(e)}))},e.prototype.announceMembership=function(e){this._listeners.forEach((function(t){t.membership&&t.membership(e)}))},e.prototype.announceNetworkUp=function(){var e={};e.category=E.PNNetworkUpCategory,this.announceStatus(e)},e.prototype.announceNetworkDown=function(){var e={};e.category=E.PNNetworkDownCategory,this.announceStatus(e)},e}(),K=function(){function e(e,t){this._config=e,this._cbor=t}return e.prototype.setToken=function(e){e&&e.length>0?this._token=e:this._token=void 0},e.prototype.getToken=function(){return this._token},e.prototype.extractPermissions=function(e){var t={read:!1,write:!1,manage:!1,delete:!1,get:!1,update:!1,join:!1};return 128==(128&e)&&(t.join=!0),64==(64&e)&&(t.update=!0),32==(32&e)&&(t.get=!0),8==(8&e)&&(t.delete=!0),4==(4&e)&&(t.manage=!0),2==(2&e)&&(t.write=!0),1==(1&e)&&(t.read=!0),t},e.prototype.parseToken=function(e){var t=this,n=this._cbor.decodeToken(e);if(void 0!==n){var r=n.res.uuid?Object.keys(n.res.uuid):[],i=Object.keys(n.res.chan),o=Object.keys(n.res.grp),s=n.pat.uuid?Object.keys(n.pat.uuid):[],a=Object.keys(n.pat.chan),u=Object.keys(n.pat.grp),c={version:n.v,timestamp:n.t,ttl:n.ttl,authorized_uuid:n.uuid},l=r.length>0,p=i.length>0,h=o.length>0;(l||p||h)&&(c.resources={},l&&(c.resources.uuids={},r.forEach((function(e){c.resources.uuids[e]=t.extractPermissions(n.res.uuid[e])}))),p&&(c.resources.channels={},i.forEach((function(e){c.resources.channels[e]=t.extractPermissions(n.res.chan[e])}))),h&&(c.resources.groups={},o.forEach((function(e){c.resources.groups[e]=t.extractPermissions(n.res.grp[e])}))));var f=s.length>0,d=a.length>0,g=u.length>0;return(f||d||g)&&(c.patterns={},f&&(c.patterns.uuids={},s.forEach((function(e){c.patterns.uuids[e]=t.extractPermissions(n.pat.uuid[e])}))),d&&(c.patterns.channels={},a.forEach((function(e){c.patterns.channels[e]=t.extractPermissions(n.pat.chan[e])}))),g&&(c.patterns.groups={},u.forEach((function(e){c.patterns.groups[e]=t.extractPermissions(n.pat.grp[e])})))),Object.keys(n.meta).length>0&&(c.meta=n.meta),c.signature=n.sig,c}},e}(),F=function(e){function n(t,n){var r=this.constructor,i=e.call(this,t)||this;return i.name=i.constructor.name,i.status=n,i.message=t,Object.setPrototypeOf(i,r.prototype),i}return t(n,e),n}(Error);function L(e){return(t={message:e}).type="validationError",t.error=!0,t;var t}function B(e,t,n){return e.usePost&&e.usePost(t,n)?e.postURL(t,n):e.usePatch&&e.usePatch(t,n)?e.patchURL(t,n):e.useGetFile&&e.useGetFile(t,n)?e.getFileURL(t,n):e.getURL(t,n)}function H(e){if(e.sdkName)return e.sdkName;var t="PubNub-JS-".concat(e.sdkFamily);e.partnerId&&(t+="-".concat(e.partnerId)),t+="/".concat(e.getVersion());var n=e._getPnsdkSuffix(" ");return n.length>0&&(t+=n),t}function q(e,t,n){return t.usePost&&t.usePost(e,n)?"POST":t.usePatch&&t.usePatch(e,n)?"PATCH":t.useDelete&&t.useDelete(e,n)?"DELETE":t.useGetFile&&t.useGetFile(e,n)?"GETFILE":"GET"}function z(e,t,n,r,i){var o=e.config,s=e.crypto,a=q(e,i,r);n.timestamp=Math.floor((new Date).getTime()/1e3),"PNPublishOperation"===i.getOperation()&&i.usePost&&i.usePost(e,r)&&(a="GET"),"GETFILE"===a&&(a="GET");var u="".concat(a,"\n").concat(o.publishKey,"\n").concat(t,"\n").concat(C.signPamFromParams(n),"\n");if("POST"===a)u+="string"==typeof(c=i.postPayload(e,r))?c:JSON.stringify(c);else if("PATCH"===a){var c;u+="string"==typeof(c=i.patchPayload(e,r))?c:JSON.stringify(c)}var l="v2.".concat(s.HMACSHA256(u));l=(l=(l=l.replace(/\+/g,"-")).replace(/\//g,"_")).replace(/=+$/,""),n.signature=l}function V(e,t){for(var r=[],i=2;i<arguments.length;i++)r[i-2]=arguments[i];var o=e.networking,s=e.config,a=e.telemetryManager,u=e.tokenManager,c=v(),l=null,p=null,h={};t.getOperation()===M.PNTimeOperation||t.getOperation()===M.PNChannelGroupsOperation?l=r[0]:(h=r[0],l=r[1]),"undefined"==typeof Promise||l||(p=C.createPromise());var f=t.validateParams(e,h);if(f)return l?l(L(f)):p?(p.reject(new F("Validation failed, check status for details",L(f))),p.promise):void 0;var d,g=t.prepareParams(e,h),y=B(t,e,h),b={url:y,operation:t.getOperation(),timeout:t.getRequestTimeout(e),headers:t.getRequestHeaders?t.getRequestHeaders():{},ignoreBody:"function"==typeof t.ignoreBody&&t.ignoreBody(e),forceBuffered:"function"==typeof t.forceBuffered?t.forceBuffered(e,h):null,abortSignal:"function"==typeof t.getAbortSignal?t.getAbortSignal(e,h):null};g.uuid=s.UUID,g.pnsdk=H(s);var m=a.operationsLatencyForRequest();if(Object.keys(m).length&&(g=n(n({},g),m)),s.useInstanceId&&(g.instanceid=s.instanceId),s.useRequestId&&(g.requestid=c),t.isAuthSupported()){var _=u.getToken()||s.getAuthKey();_&&(g.auth=_)}s.secretKey&&z(e,y,g,h,t);var O=function(n,r){if(n.error)return t.handleError&&t.handleError(e,h,n),void(l?l(n):p&&p.reject(new F("PubNub call failed, check status for details",n)));a.stopLatencyMeasure(t.getOperation(),c);var i=t.handleResponse(e,r,h);"function"!=typeof(null==i?void 0:i.then)&&(i=Promise.resolve(i)),i.then((function(e){l?l(n,e):p&&p.fulfill(e)})).catch((function(e){if(l){var n=e;t.getOperation()===M.PNSubscribeOperation&&(n={statusCode:400,error:!0,operation:t.getOperation(),errorData:e,category:E.PNUnknownCategory}),l(n,null)}else p&&p.reject(new F("PubNub call failed, check status for details",e))}))};if(a.startLatencyMeasure(t.getOperation(),c),"POST"===q(e,t,h)){var P=t.postPayload(e,h);d=o.POST(g,P,b,O)}else if("PATCH"===q(e,t,h)){P=t.patchPayload(e,h);d=o.PATCH(g,P,b,O)}else d="DELETE"===q(e,t,h)?o.DELETE(g,b,O):"GETFILE"===q(e,t,h)?o.GETFILE(g,b,O):o.GET(g,b,O);return t.getOperation()===M.PNSubscribeOperation?d:p?p.promise:void 0}var J=Object.freeze({__proto__:null,getOperation:function(){return M.PNAddChannelsToGroupOperation},validateParams:function(e,t){var n=t.channels,r=t.channelGroup,i=e.config;return r?n&&0!==n.length?i.subscribeKey?void 0:"Missing Subscribe Key":"Missing Channels":"Missing Channel Group"},getURL:function(e,t){var n=t.channelGroup,r=e.config;return"/v1/channel-registration/sub-key/".concat(r.subscribeKey,"/channel-group/").concat(C.encodeString(n))},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var n=t.channels;return{add:(void 0===n?[]:n).join(",")}},handleResponse:function(){return{}}});var W=Object.freeze({__proto__:null,getOperation:function(){return M.PNRemoveChannelsFromGroupOperation},validateParams:function(e,t){var n=t.channels,r=t.channelGroup,i=e.config;return r?n&&0!==n.length?i.subscribeKey?void 0:"Missing Subscribe Key":"Missing Channels":"Missing Channel Group"},getURL:function(e,t){var n=t.channelGroup,r=e.config;return"/v1/channel-registration/sub-key/".concat(r.subscribeKey,"/channel-group/").concat(C.encodeString(n))},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var n=t.channels;return{remove:(void 0===n?[]:n).join(",")}},handleResponse:function(){return{}}});var X=Object.freeze({__proto__:null,getOperation:function(){return M.PNRemoveGroupOperation},validateParams:function(e,t){var n=t.channelGroup,r=e.config;return n?r.subscribeKey?void 0:"Missing Subscribe Key":"Missing Channel Group"},getURL:function(e,t){var n=t.channelGroup,r=e.config;return"/v1/channel-registration/sub-key/".concat(r.subscribeKey,"/channel-group/").concat(C.encodeString(n),"/remove")},isAuthSupported:function(){return!0},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},prepareParams:function(){return{}},handleResponse:function(){return{}}});var $=Object.freeze({__proto__:null,getOperation:function(){return M.PNChannelGroupsOperation},validateParams:function(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"},getURL:function(e){var t=e.config;return"/v1/channel-registration/sub-key/".concat(t.subscribeKey,"/channel-group")},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(){return{}},handleResponse:function(e,t){return{groups:t.payload.groups}}});var Q=Object.freeze({__proto__:null,getOperation:function(){return M.PNChannelsForGroupOperation},validateParams:function(e,t){var n=t.channelGroup,r=e.config;return n?r.subscribeKey?void 0:"Missing Subscribe Key":"Missing Channel Group"},getURL:function(e,t){var n=t.channelGroup,r=e.config;return"/v1/channel-registration/sub-key/".concat(r.subscribeKey,"/channel-group/").concat(C.encodeString(n))},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(){return{}},handleResponse:function(e,t){return{channels:t.payload.channels}}});var Y=Object.freeze({__proto__:null,getOperation:function(){return M.PNPushNotificationEnabledChannelsOperation},validateParams:function(e,t){var n=t.device,r=t.pushGateway,i=t.channels,o=t.topic,s=e.config;return n?r?"apns2"!==r||o?i&&0!==i.length?s.subscribeKey?void 0:"Missing Subscribe Key":"Missing Channels":"Missing APNS2 topic":"Missing GW Type (pushGateway: gcm, apns or apns2)":"Missing Device ID (device)"},getURL:function(e,t){var n=t.device,r=t.pushGateway,i=e.config;return"apns2"===r?"/v2/push/sub-key/".concat(i.subscribeKey,"/devices-apns2/").concat(n):"/v1/push/sub-key/".concat(i.subscribeKey,"/devices/").concat(n)},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var r=t.pushGateway,i=t.channels,o=void 0===i?[]:i,s=t.environment,a=void 0===s?"development":s,u=t.topic,c={type:r,add:o.join(",")};return"apns2"===r&&delete(c=n(n({},c),{environment:a,topic:u})).type,c},handleResponse:function(){return{}}});var Z=Object.freeze({__proto__:null,getOperation:function(){return M.PNPushNotificationEnabledChannelsOperation},validateParams:function(e,t){var n=t.device,r=t.pushGateway,i=t.channels,o=t.topic,s=e.config;return n?r?"apns2"!==r||o?i&&0!==i.length?s.subscribeKey?void 0:"Missing Subscribe Key":"Missing Channels":"Missing APNS2 topic":"Missing GW Type (pushGateway: gcm, apns or apns2)":"Missing Device ID (device)"},getURL:function(e,t){var n=t.device,r=t.pushGateway,i=e.config;return"apns2"===r?"/v2/push/sub-key/".concat(i.subscribeKey,"/devices-apns2/").concat(n):"/v1/push/sub-key/".concat(i.subscribeKey,"/devices/").concat(n)},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var r=t.pushGateway,i=t.channels,o=void 0===i?[]:i,s=t.environment,a=void 0===s?"development":s,u=t.topic,c={type:r,remove:o.join(",")};return"apns2"===r&&delete(c=n(n({},c),{environment:a,topic:u})).type,c},handleResponse:function(){return{}}});var ee=Object.freeze({__proto__:null,getOperation:function(){return M.PNPushNotificationEnabledChannelsOperation},validateParams:function(e,t){var n=t.device,r=t.pushGateway,i=t.topic,o=e.config;return n?r?"apns2"!==r||i?o.subscribeKey?void 0:"Missing Subscribe Key":"Missing APNS2 topic":"Missing GW Type (pushGateway: gcm, apns or apns2)":"Missing Device ID (device)"},getURL:function(e,t){var n=t.device,r=t.pushGateway,i=e.config;return"apns2"===r?"/v2/push/sub-key/".concat(i.subscribeKey,"/devices-apns2/").concat(n):"/v1/push/sub-key/".concat(i.subscribeKey,"/devices/").concat(n)},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var r=t.pushGateway,i=t.environment,o=void 0===i?"development":i,s=t.topic,a={type:r};return"apns2"===r&&delete(a=n(n({},a),{environment:o,topic:s})).type,a},handleResponse:function(e,t){return{channels:t}}});var te=Object.freeze({__proto__:null,getOperation:function(){return M.PNRemoveAllPushNotificationsOperation},validateParams:function(e,t){var n=t.device,r=t.pushGateway,i=t.topic,o=e.config;return n?r?"apns2"!==r||i?o.subscribeKey?void 0:"Missing Subscribe Key":"Missing APNS2 topic":"Missing GW Type (pushGateway: gcm, apns or apns2)":"Missing Device ID (device)"},getURL:function(e,t){var n=t.device,r=t.pushGateway,i=e.config;return"apns2"===r?"/v2/push/sub-key/".concat(i.subscribeKey,"/devices-apns2/").concat(n,"/remove"):"/v1/push/sub-key/".concat(i.subscribeKey,"/devices/").concat(n,"/remove")},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var r=t.pushGateway,i=t.environment,o=void 0===i?"development":i,s=t.topic,a={type:r};return"apns2"===r&&delete(a=n(n({},a),{environment:o,topic:s})).type,a},handleResponse:function(){return{}}});var ne=Object.freeze({__proto__:null,getOperation:function(){return M.PNUnsubscribeOperation},validateParams:function(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"},getURL:function(e,t){var n=e.config,r=t.channels,i=void 0===r?[]:r,o=i.length>0?i.join(","):",";return"/v2/presence/sub-key/".concat(n.subscribeKey,"/channel/").concat(C.encodeString(o),"/leave")},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var n=t.channelGroups,r=void 0===n?[]:n,i={};return r.length>0&&(i["channel-group"]=r.join(",")),i},handleResponse:function(){return{}}});var re=Object.freeze({__proto__:null,getOperation:function(){return M.PNWhereNowOperation},validateParams:function(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"},getURL:function(e,t){var n=e.config,r=t.uuid,i=void 0===r?n.UUID:r;return"/v2/presence/sub-key/".concat(n.subscribeKey,"/uuid/").concat(C.encodeString(i))},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(){return{}},handleResponse:function(e,t){return t.payload?{channels:t.payload.channels}:{channels:[]}}});var ie=Object.freeze({__proto__:null,getOperation:function(){return M.PNHeartbeatOperation},validateParams:function(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"},getURL:function(e,t){var n=e.config,r=t.channels,i=void 0===r?[]:r,o=i.length>0?i.join(","):",";return"/v2/presence/sub-key/".concat(n.subscribeKey,"/channel/").concat(C.encodeString(o),"/heartbeat")},isAuthSupported:function(){return!0},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},prepareParams:function(e,t){var n=t.channelGroups,r=void 0===n?[]:n,i=t.state,o=void 0===i?{}:i,s=e.config,a={};return r.length>0&&(a["channel-group"]=r.join(",")),a.state=JSON.stringify(o),a.heartbeat=s.getPresenceTimeout(),a},handleResponse:function(){return{}}});var oe=Object.freeze({__proto__:null,getOperation:function(){return M.PNGetStateOperation},validateParams:function(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"},getURL:function(e,t){var n=e.config,r=t.uuid,i=void 0===r?n.UUID:r,o=t.channels,s=void 0===o?[]:o,a=s.length>0?s.join(","):",";return"/v2/presence/sub-key/".concat(n.subscribeKey,"/channel/").concat(C.encodeString(a),"/uuid/").concat(i)},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var n=t.channelGroups,r=void 0===n?[]:n,i={};return r.length>0&&(i["channel-group"]=r.join(",")),i},handleResponse:function(e,t,n){var r=n.channels,i=void 0===r?[]:r,o=n.channelGroups,s=void 0===o?[]:o,a={};return 1===i.length&&0===s.length?a[i[0]]=t.payload:a=t.payload,{channels:a}}});var se=Object.freeze({__proto__:null,getOperation:function(){return M.PNSetStateOperation},validateParams:function(e,t){var n=e.config,r=t.state,i=t.channels,o=void 0===i?[]:i,s=t.channelGroups,a=void 0===s?[]:s;return r?n.subscribeKey?0===o.length&&0===a.length?"Please provide a list of channels and/or channel-groups":void 0:"Missing Subscribe Key":"Missing State"},getURL:function(e,t){var n=e.config,r=t.channels,i=void 0===r?[]:r,o=i.length>0?i.join(","):",";return"/v2/presence/sub-key/".concat(n.subscribeKey,"/channel/").concat(C.encodeString(o),"/uuid/").concat(C.encodeString(n.UUID),"/data")},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var n=t.state,r=t.channelGroups,i=void 0===r?[]:r,o={};return o.state=JSON.stringify(n),i.length>0&&(o["channel-group"]=i.join(",")),o},handleResponse:function(e,t){return{state:t.payload}}});var ae=Object.freeze({__proto__:null,getOperation:function(){return M.PNHereNowOperation},validateParams:function(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"},getURL:function(e,t){var n=e.config,r=t.channels,i=void 0===r?[]:r,o=t.channelGroups,s=void 0===o?[]:o,a="/v2/presence/sub-key/".concat(n.subscribeKey);if(i.length>0||s.length>0){var u=i.length>0?i.join(","):",";a+="/channel/".concat(C.encodeString(u))}return a},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var r=t.channelGroups,i=void 0===r?[]:r,o=t.includeUUIDs,s=void 0===o||o,a=t.includeState,u=void 0!==a&&a,c=t.queryParameters,l=void 0===c?{}:c,p={};return s||(p.disable_uuids=1),u&&(p.state=1),i.length>0&&(p["channel-group"]=i.join(",")),p=n(n({},p),l)},handleResponse:function(e,t,n){var r=n.channels,i=void 0===r?[]:r,o=n.channelGroups,s=void 0===o?[]:o,a=n.includeUUIDs,u=void 0===a||a,c=n.includeState,l=void 0!==c&&c;return i.length>1||s.length>0||0===s.length&&0===i.length?function(){var e={};return e.totalChannels=t.payload.total_channels,e.totalOccupancy=t.payload.total_occupancy,e.channels={},Object.keys(t.payload.channels).forEach((function(n){var r=t.payload.channels[n],i=[];return e.channels[n]={occupants:i,name:n,occupancy:r.occupancy},u&&r.uuids.forEach((function(e){l?i.push({state:e.state,uuid:e.uuid}):i.push({state:null,uuid:e})})),e})),e}():function(){var e={},n=[];return e.totalChannels=1,e.totalOccupancy=t.occupancy,e.channels={},e.channels[i[0]]={occupants:n,name:i[0],occupancy:t.occupancy},u&&t.uuids&&t.uuids.forEach((function(e){l?n.push({state:e.state,uuid:e.uuid}):n.push({state:null,uuid:e})})),e}()},handleError:function(e,t,n){402!==n.statusCode||this.getURL(e,t).includes("channel")||(n.errorData.message="You have tried to perform a Global Here Now operation, your keyset configuration does not support that. Please provide a channel, or enable the Global Here Now feature from the Portal.")}});var ue=Object.freeze({__proto__:null,getOperation:function(){return M.PNAddMessageActionOperation},validateParams:function(e,t){var n=e.config,r=t.action,i=t.channel;return t.messageTimetoken?n.subscribeKey?i?r?r.value?r.type?r.type.length>15?"Action.type value exceed maximum length of 15":void 0:"Missing Action.type":"Missing Action.value":"Missing Action":"Missing message channel":"Missing Subscribe Key":"Missing message timetoken"},usePost:function(){return!0},postURL:function(e,t){var n=e.config,r=t.channel,i=t.messageTimetoken;return"/v1/message-actions/".concat(n.subscribeKey,"/channel/").concat(C.encodeString(r),"/message/").concat(i)},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},getRequestHeaders:function(){return{"Content-Type":"application/json"}},isAuthSupported:function(){return!0},prepareParams:function(){return{}},postPayload:function(e,t){return t.action},handleResponse:function(e,t){return{data:t.data}}});var ce=Object.freeze({__proto__:null,getOperation:function(){return M.PNRemoveMessageActionOperation},validateParams:function(e,t){var n=e.config,r=t.channel,i=t.actionTimetoken;return t.messageTimetoken?i?n.subscribeKey?r?void 0:"Missing message channel":"Missing Subscribe Key":"Missing action timetoken":"Missing message timetoken"},useDelete:function(){return!0},getURL:function(e,t){var n=e.config,r=t.channel,i=t.actionTimetoken,o=t.messageTimetoken;return"/v1/message-actions/".concat(n.subscribeKey,"/channel/").concat(C.encodeString(r),"/message/").concat(o,"/action/").concat(i)},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(){return{}},handleResponse:function(e,t){return{data:t.data}}});var le=Object.freeze({__proto__:null,getOperation:function(){return M.PNGetMessageActionsOperation},validateParams:function(e,t){var n=e.config,r=t.channel;return n.subscribeKey?r?void 0:"Missing message channel":"Missing Subscribe Key"},getURL:function(e,t){var n=e.config,r=t.channel;return"/v1/message-actions/".concat(n.subscribeKey,"/channel/").concat(C.encodeString(r))},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var n=t.limit,r=t.start,i=t.end,o={};return n&&(o.limit=n),r&&(o.start=r),i&&(o.end=i),o},handleResponse:function(e,t){var n={data:t.data,start:null,end:null};return n.data.length&&(n.end=n.data[n.data.length-1].actionTimetoken,n.start=n.data[0].actionTimetoken),n}}),pe={getOperation:function(){return M.PNListFilesOperation},validateParams:function(e,t){if(!(null==t?void 0:t.channel))return"channel can't be empty"},getURL:function(e,t){var n=e.config;return"/v1/files/".concat(n.subscribeKey,"/channels/").concat(C.encodeString(t.channel),"/files")},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var n={};return t.limit&&(n.limit=t.limit),t.next&&(n.next=t.next),n},handleResponse:function(e,t){return{status:t.status,data:t.data,next:t.next,count:t.count}}},he={getOperation:function(){return M.PNGenerateUploadUrlOperation},validateParams:function(e,t){return(null==t?void 0:t.channel)?(null==t?void 0:t.name)?void 0:"name can't be empty":"channel can't be empty"},usePost:function(){return!0},postURL:function(e,t){var n=e.config;return"/v1/files/".concat(n.subscribeKey,"/channels/").concat(C.encodeString(t.channel),"/generate-upload-url")},postPayload:function(e,t){return{name:t.name}},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(){return{}},handleResponse:function(e,t){return{status:t.status,data:t.data,file_upload_request:t.file_upload_request}}},fe={getOperation:function(){return M.PNPublishFileOperation},validateParams:function(e,t){return(null==t?void 0:t.channel)?(null==t?void 0:t.fileId)?(null==t?void 0:t.fileName)?void 0:"file name can't be empty":"file id can't be empty":"channel can't be empty"},getURL:function(e,t){var n=e.config,r=n.publishKey,i=n.subscribeKey,o=function(e,t){var n=e.crypto,r=e.config,i=JSON.stringify(t);return r.cipherKey&&(i=n.encrypt(i),i=JSON.stringify(i)),i||""}(e,{message:t.message,file:{name:t.fileName,id:t.fileId}});return"/v1/files/publish-file/".concat(r,"/").concat(i,"/0/").concat(C.encodeString(t.channel),"/0/").concat(C.encodeString(o))},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var n={};return t.ttl&&(n.ttl=t.ttl),void 0!==t.storeInHistory&&(n.store=t.storeInHistory?"1":"0"),t.meta&&"object"==typeof t.meta&&(n.meta=JSON.stringify(t.meta)),n},handleResponse:function(e,t){return{timetoken:t[2]}}},de=function(e){var t=function(e){var t=this,n=e.generateUploadUrl,o=e.publishFile,s=e.modules,a=s.PubNubFile,u=s.config,c=s.cryptography,l=s.networking;return function(e){var s=e.channel,p=e.file,h=e.message,f=e.cipherKey,d=e.meta,g=e.ttl,y=e.storeInHistory;return r(t,void 0,void 0,(function(){var e,t,r,b,v,m,_,O,P,S,w,T,k,N,C,E,A,M,R,j,U,x,D,I,G,K,B,H;return i(this,(function(i){switch(i.label){case 0:if(!s)throw new F("Validation failed, check status for details",L("channel can't be empty"));if(!p)throw new F("Validation failed, check status for details",L("file can't be empty"));return e=a.create(p),[4,n({channel:s,name:e.name})];case 1:return t=i.sent(),r=t.file_upload_request,b=r.url,v=r.form_fields,m=t.data,_=m.id,O=m.name,a.supportsEncryptFile&&(null!=f?f:u.cipherKey)?[4,c.encryptFile(null!=f?f:u.cipherKey,e,a)]:[3,3];case 2:e=i.sent(),i.label=3;case 3:P=v,e.mimeType&&(P=v.map((function(t){return"Content-Type"===t.key?{key:t.key,value:e.mimeType}:t}))),i.label=4;case 4:return i.trys.push([4,18,,20]),a.supportsFileUri&&p.uri?(T=(w=l).POSTFILE,k=[b,P],[4,e.toFileUri()]):[3,7];case 5:return[4,T.apply(w,k.concat([i.sent()]))];case 6:return S=i.sent(),[3,17];case 7:return a.supportsFile?(C=(N=l).POSTFILE,E=[b,P],[4,e.toFile()]):[3,10];case 8:return[4,C.apply(N,E.concat([i.sent()]))];case 9:return S=i.sent(),[3,17];case 10:return a.supportsBuffer?(M=(A=l).POSTFILE,R=[b,P],[4,e.toBuffer()]):[3,13];case 11:return[4,M.apply(A,R.concat([i.sent()]))];case 12:return S=i.sent(),[3,17];case 13:return a.supportsBlob?(U=(j=l).POSTFILE,x=[b,P],[4,e.toBlob()]):[3,16];case 14:return[4,U.apply(j,x.concat([i.sent()]))];case 15:return S=i.sent(),[3,17];case 16:throw new Error("Unsupported environment");case 17:return[3,20];case 18:return D=i.sent(),[4,(q=D.response,new Promise((function(e){var t="";q.on("data",(function(e){t+=e.toString("utf8")})),q.on("end",(function(){e(t)}))})))];case 19:throw I=i.sent(),G=/<Message>(.*)<\/Message>/gi.exec(I),new F(G?"Upload to bucket failed: ".concat(G[1]):"Upload to bucket failed.",D);case 20:if(204!==S.status)throw new F("Upload to bucket was unsuccessful",S);K=u.fileUploadPublishRetryLimit,B=!1,H={timetoken:"0"},i.label=21;case 21:return i.trys.push([21,23,,24]),[4,o({channel:s,message:h,fileId:_,fileName:O,meta:d,storeInHistory:y,ttl:g})];case 22:return H=i.sent(),B=!0,[3,24];case 23:return i.sent(),K-=1,[3,24];case 24:if(!B&&K>0)return[3,21];i.label=25;case 25:if(B)return[2,{timetoken:H.timetoken,id:_,name:O}];throw new F("Publish failed. You may want to execute that operation manually using pubnub.publishFile",{channel:s,id:_,name:O})}var q}))}))}}(e);return function(e,n){var r=t(e);return"function"==typeof n?(r.then((function(e){return n(null,e)})).catch((function(e){return n(e,null)})),r):r}},ge=function(e,t){var n=t.channel,r=t.id,i=t.name,o=e.config,s=e.networking;if(!n)throw new F("Validation failed, check status for details",L("channel can't be empty"));if(!r)throw new F("Validation failed, check status for details",L("file id can't be empty"));if(!i)throw new F("Validation failed, check status for details",L("file name can't be empty"));var a="/v1/files/".concat(o.subscribeKey,"/channels/").concat(C.encodeString(n),"/files/").concat(r,"/").concat(i),u={};u.uuid=o.getUUID(),u.pnsdk=H(o),o.getAuthKey()&&(u.auth=o.getAuthKey()),o.secretKey&&z(e,a,u,{},{getOperation:function(){return"PubNubGetFileUrlOperation"}});var c=Object.keys(u).map((function(e){return"".concat(encodeURIComponent(e),"=").concat(encodeURIComponent(u[e]))})).join("&");return""!==c?"".concat(s.getStandardOrigin()).concat(a,"?").concat(c):"".concat(s.getStandardOrigin()).concat(a)},ye={getOperation:function(){return M.PNDownloadFileOperation},validateParams:function(e,t){return(null==t?void 0:t.channel)?(null==t?void 0:t.name)?(null==t?void 0:t.id)?void 0:"id can't be empty":"name can't be empty":"channel can't be empty"},useGetFile:function(){return!0},getFileURL:function(e,t){var n=e.config;return"/v1/files/".concat(n.subscribeKey,"/channels/").concat(C.encodeString(t.channel),"/files/").concat(t.id,"/").concat(t.name)},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},ignoreBody:function(){return!0},forceBuffered:function(){return!0},prepareParams:function(){return{}},handleResponse:function(e,t,n){var o=e.PubNubFile,s=e.config,a=e.cryptography;return r(void 0,void 0,void 0,(function(){var e,r,u,c;return i(this,(function(i){switch(i.label){case 0:return e=t.response.body,o.supportsEncryptFile&&(null!==(r=n.cipherKey)&&void 0!==r?r:s.cipherKey)?[4,a.decrypt(null!==(u=n.cipherKey)&&void 0!==u?u:s.cipherKey,e)]:[3,2];case 1:e=i.sent(),i.label=2;case 2:return[2,o.create({data:e,name:null!==(c=t.response.name)&&void 0!==c?c:n.name,mimeType:t.response.type})]}}))}))}},be={getOperation:function(){return M.PNListFilesOperation},validateParams:function(e,t){return(null==t?void 0:t.channel)?(null==t?void 0:t.id)?(null==t?void 0:t.name)?void 0:"file name can't be empty":"file id can't be empty":"channel can't be empty"},useDelete:function(){return!0},getURL:function(e,t){var n=e.config;return"/v1/files/".concat(n.subscribeKey,"/channels/").concat(C.encodeString(t.channel),"/files/").concat(t.id,"/").concat(t.name)},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(){return{}},handleResponse:function(e,t){return{status:t.status}}},ve={getOperation:function(){return M.PNGetAllUUIDMetadataOperation},validateParams:function(){},getURL:function(e){var t=e.config;return"/v2/objects/".concat(t.subscribeKey,"/uuids")},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var n,r,i,o,a,u,c,l,p,h={};return(null===(n=null==t?void 0:t.include)||void 0===n?void 0:n.customFields)&&(h.include="custom"),(null===(r=null==t?void 0:t.include)||void 0===r?void 0:r.totalCount)&&(h.count=null===(i=t.include)||void 0===i?void 0:i.totalCount),(null===(o=null==t?void 0:t.page)||void 0===o?void 0:o.next)&&(h.start=null===(a=t.page)||void 0===a?void 0:a.next),(null===(u=null==t?void 0:t.page)||void 0===u?void 0:u.prev)&&(h.end=null===(c=t.page)||void 0===c?void 0:c.prev),(null==t?void 0:t.filter)&&(h.filter=t.filter),h.limit=null!==(l=null==t?void 0:t.limit)&&void 0!==l?l:100,(null==t?void 0:t.sort)&&(h.sort=Object.entries(null!==(p=t.sort)&&void 0!==p?p:{}).map((function(e){var t=s(e,2),n=t[0],r=t[1];return"asc"===r||"desc"===r?"".concat(n,":").concat(r):n}))),h},handleResponse:function(e,t){return{status:t.status,data:t.data,totalCount:t.totalCount,next:t.next,prev:t.prev}}},me={getOperation:function(){return M.PNGetUUIDMetadataOperation},validateParams:function(){},getURL:function(e,t){var n,r=e.config;return"/v2/objects/".concat(r.subscribeKey,"/uuids/").concat(C.encodeString(null!==(n=null==t?void 0:t.uuid)&&void 0!==n?n:r.getUUID()))},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var n,r,i,o=e.config;return{uuid:null!==(n=null==t?void 0:t.uuid)&&void 0!==n?n:o.getUUID(),include:(null===(i=null===(r=null==t?void 0:t.include)||void 0===r?void 0:r.customFields)||void 0===i||i)&&"custom"}},handleResponse:function(e,t){return{status:t.status,data:t.data}}},_e={getOperation:function(){return M.PNSetUUIDMetadataOperation},validateParams:function(e,t){if(!(null==t?void 0:t.data))return"Data cannot be empty"},usePatch:function(){return!0},patchURL:function(e,t){var n,r=e.config;return"/v2/objects/".concat(r.subscribeKey,"/uuids/").concat(C.encodeString(null!==(n=t.uuid)&&void 0!==n?n:r.getUUID()))},patchPayload:function(e,t){return t.data},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var n,r,i,o=e.config;return{uuid:null!==(n=null==t?void 0:t.uuid)&&void 0!==n?n:o.getUUID(),include:(null===(i=null===(r=null==t?void 0:t.include)||void 0===r?void 0:r.customFields)||void 0===i||i)&&"custom"}},handleResponse:function(e,t){return{status:t.status,data:t.data}}},Oe={getOperation:function(){return M.PNRemoveUUIDMetadataOperation},validateParams:function(){},getURL:function(e,t){var n,r=e.config;return"/v2/objects/".concat(r.subscribeKey,"/uuids/").concat(C.encodeString(null!==(n=null==t?void 0:t.uuid)&&void 0!==n?n:r.getUUID()))},useDelete:function(){return!0},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var n,r=e.config;return{uuid:null!==(n=null==t?void 0:t.uuid)&&void 0!==n?n:r.getUUID()}},handleResponse:function(e,t){return{status:t.status,data:t.data}}},Pe={getOperation:function(){return M.PNGetAllChannelMetadataOperation},validateParams:function(){},getURL:function(e){var t=e.config;return"/v2/objects/".concat(t.subscribeKey,"/channels")},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var n,r,i,o,a,u,c,l,p,h={};return(null===(n=null==t?void 0:t.include)||void 0===n?void 0:n.customFields)&&(h.include="custom"),(null===(r=null==t?void 0:t.include)||void 0===r?void 0:r.totalCount)&&(h.count=null===(i=t.include)||void 0===i?void 0:i.totalCount),(null===(o=null==t?void 0:t.page)||void 0===o?void 0:o.next)&&(h.start=null===(a=t.page)||void 0===a?void 0:a.next),(null===(u=null==t?void 0:t.page)||void 0===u?void 0:u.prev)&&(h.end=null===(c=t.page)||void 0===c?void 0:c.prev),(null==t?void 0:t.filter)&&(h.filter=t.filter),h.limit=null!==(l=null==t?void 0:t.limit)&&void 0!==l?l:100,(null==t?void 0:t.sort)&&(h.sort=Object.entries(null!==(p=t.sort)&&void 0!==p?p:{}).map((function(e){var t=s(e,2),n=t[0],r=t[1];return"asc"===r||"desc"===r?"".concat(n,":").concat(r):n}))),h},handleResponse:function(e,t){return{status:t.status,data:t.data,totalCount:t.totalCount,prev:t.prev,next:t.next}}},Se={getOperation:function(){return M.PNGetChannelMetadataOperation},validateParams:function(e,t){if(!(null==t?void 0:t.channel))return"Channel cannot be empty"},getURL:function(e,t){var n=e.config;return"/v2/objects/".concat(n.subscribeKey,"/channels/").concat(C.encodeString(t.channel))},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var n,r;return{include:(null===(r=null===(n=null==t?void 0:t.include)||void 0===n?void 0:n.customFields)||void 0===r||r)&&"custom"}},handleResponse:function(e,t){return{status:t.status,data:t.data}}},we={getOperation:function(){return M.PNSetChannelMetadataOperation},validateParams:function(e,t){return(null==t?void 0:t.channel)?(null==t?void 0:t.data)?void 0:"Data cannot be empty":"Channel cannot be empty"},usePatch:function(){return!0},patchURL:function(e,t){var n=e.config;return"/v2/objects/".concat(n.subscribeKey,"/channels/").concat(C.encodeString(t.channel))},patchPayload:function(e,t){return t.data},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var n,r;return{include:(null===(r=null===(n=null==t?void 0:t.include)||void 0===n?void 0:n.customFields)||void 0===r||r)&&"custom"}},handleResponse:function(e,t){return{status:t.status,data:t.data}}},Te={getOperation:function(){return M.PNRemoveChannelMetadataOperation},validateParams:function(e,t){if(!(null==t?void 0:t.channel))return"Channel cannot be empty"},getURL:function(e,t){var n=e.config;return"/v2/objects/".concat(n.subscribeKey,"/channels/").concat(C.encodeString(t.channel))},useDelete:function(){return!0},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(){return{}},handleResponse:function(e,t){return{status:t.status,data:t.data}}},ke={getOperation:function(){return M.PNGetMembersOperation},validateParams:function(e,t){if(!(null==t?void 0:t.channel))return"UUID cannot be empty"},getURL:function(e,t){var n=e.config;return"/v2/objects/".concat(n.subscribeKey,"/channels/").concat(C.encodeString(t.channel),"/uuids")},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var n,r,i,o,a,u,c,l,p,h,f,d,g={};return(null==t?void 0:t.include)&&(g.include=[],(null===(n=t.include)||void 0===n?void 0:n.customFields)&&g.include.push("custom"),(null===(r=t.include)||void 0===r?void 0:r.customUUIDFields)&&g.include.push("uuid.custom"),(null===(o=null===(i=t.include)||void 0===i?void 0:i.UUIDFields)||void 0===o||o)&&g.include.push("uuid"),g.include=g.include.join(",")),(null===(a=null==t?void 0:t.include)||void 0===a?void 0:a.totalCount)&&(g.count=null===(u=t.include)||void 0===u?void 0:u.totalCount),(null===(c=null==t?void 0:t.page)||void 0===c?void 0:c.next)&&(g.start=null===(l=t.page)||void 0===l?void 0:l.next),(null===(p=null==t?void 0:t.page)||void 0===p?void 0:p.prev)&&(g.end=null===(h=t.page)||void 0===h?void 0:h.prev),(null==t?void 0:t.filter)&&(g.filter=t.filter),g.limit=null!==(f=null==t?void 0:t.limit)&&void 0!==f?f:100,(null==t?void 0:t.sort)&&(g.sort=Object.entries(null!==(d=t.sort)&&void 0!==d?d:{}).map((function(e){var t=s(e,2),n=t[0],r=t[1];return"asc"===r||"desc"===r?"".concat(n,":").concat(r):n}))),g},handleResponse:function(e,t){return{status:t.status,data:t.data,totalCount:t.totalCount,prev:t.prev,next:t.next}}},Ne={getOperation:function(){return M.PNSetMembersOperation},validateParams:function(e,t){return(null==t?void 0:t.channel)?(null==t?void 0:t.uuids)&&0!==(null==t?void 0:t.uuids.length)?void 0:"UUIDs cannot be empty":"Channel cannot be empty"},usePatch:function(){return!0},patchURL:function(e,t){var n=e.config;return"/v2/objects/".concat(n.subscribeKey,"/channels/").concat(C.encodeString(t.channel),"/uuids")},patchPayload:function(e,t){var n;return(n={set:[],remove:[]})[t.type]=t.uuids.map((function(e){return"string"==typeof e?{uuid:{id:e}}:{uuid:{id:e.id},custom:e.custom}})),n},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var n,r,i,o,a,u,c,l,p,h={};return(null==t?void 0:t.include)&&(h.include=[],(null===(n=t.include)||void 0===n?void 0:n.customFields)&&h.include.push("custom"),(null===(r=t.include)||void 0===r?void 0:r.customUUIDFields)&&h.include.push("uuid.custom"),(null===(i=t.include)||void 0===i?void 0:i.UUIDFields)&&h.include.push("uuid"),h.include=h.include.join(",")),(null===(o=null==t?void 0:t.include)||void 0===o?void 0:o.totalCount)&&(h.count=!0),(null===(a=null==t?void 0:t.page)||void 0===a?void 0:a.next)&&(h.start=null===(u=t.page)||void 0===u?void 0:u.next),(null===(c=null==t?void 0:t.page)||void 0===c?void 0:c.prev)&&(h.end=null===(l=t.page)||void 0===l?void 0:l.prev),(null==t?void 0:t.filter)&&(h.filter=t.filter),(null==t?void 0:t.limit)&&(h.limit=t.limit),(null==t?void 0:t.sort)&&(h.sort=Object.entries(null!==(p=t.sort)&&void 0!==p?p:{}).map((function(e){var t=s(e,2),n=t[0],r=t[1];return"asc"===r||"desc"===r?"".concat(n,":").concat(r):n}))),h},handleResponse:function(e,t){return{status:t.status,data:t.data,totalCount:t.totalCount,prev:t.prev,next:t.next}}},Ce={getOperation:function(){return M.PNGetMembershipsOperation},validateParams:function(){},getURL:function(e,t){var n,r=e.config;return"/v2/objects/".concat(r.subscribeKey,"/uuids/").concat(C.encodeString(null!==(n=null==t?void 0:t.uuid)&&void 0!==n?n:r.getUUID()),"/channels")},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var n,r,i,o,a,u,c,l,p,h,f,d={};return(null==t?void 0:t.include)&&(d.include=[],(null===(n=t.include)||void 0===n?void 0:n.customFields)&&d.include.push("custom"),(null===(r=t.include)||void 0===r?void 0:r.customChannelFields)&&d.include.push("channel.custom"),(null===(i=t.include)||void 0===i?void 0:i.channelFields)&&d.include.push("channel"),d.include=d.include.join(",")),(null===(o=null==t?void 0:t.include)||void 0===o?void 0:o.totalCount)&&(d.count=null===(a=t.include)||void 0===a?void 0:a.totalCount),(null===(u=null==t?void 0:t.page)||void 0===u?void 0:u.next)&&(d.start=null===(c=t.page)||void 0===c?void 0:c.next),(null===(l=null==t?void 0:t.page)||void 0===l?void 0:l.prev)&&(d.end=null===(p=t.page)||void 0===p?void 0:p.prev),(null==t?void 0:t.filter)&&(d.filter=t.filter),d.limit=null!==(h=null==t?void 0:t.limit)&&void 0!==h?h:100,(null==t?void 0:t.sort)&&(d.sort=Object.entries(null!==(f=t.sort)&&void 0!==f?f:{}).map((function(e){var t=s(e,2),n=t[0],r=t[1];return"asc"===r||"desc"===r?"".concat(n,":").concat(r):n}))),d},handleResponse:function(e,t){return{status:t.status,data:t.data,totalCount:t.totalCount,prev:t.prev,next:t.next}}},Ee={getOperation:function(){return M.PNSetMembershipsOperation},validateParams:function(e,t){if(!(null==t?void 0:t.channels)||0===(null==t?void 0:t.channels.length))return"Channels cannot be empty"},usePatch:function(){return!0},patchURL:function(e,t){var n,r=e.config;return"/v2/objects/".concat(r.subscribeKey,"/uuids/").concat(C.encodeString(null!==(n=t.uuid)&&void 0!==n?n:r.getUUID()),"/channels")},patchPayload:function(e,t){var n;return(n={set:[],remove:[]})[t.type]=t.channels.map((function(e){return"string"==typeof e?{channel:{id:e}}:{channel:{id:e.id},custom:e.custom}})),n},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var n,r,i,o,a,u,c,l,p,h={};return(null==t?void 0:t.include)&&(h.include=[],(null===(n=t.include)||void 0===n?void 0:n.customFields)&&h.include.push("custom"),(null===(r=t.include)||void 0===r?void 0:r.customChannelFields)&&h.include.push("channel.custom"),(null===(i=t.include)||void 0===i?void 0:i.channelFields)&&h.include.push("channel"),h.include=h.include.join(",")),(null===(o=null==t?void 0:t.include)||void 0===o?void 0:o.totalCount)&&(h.count=!0),(null===(a=null==t?void 0:t.page)||void 0===a?void 0:a.next)&&(h.start=null===(u=t.page)||void 0===u?void 0:u.next),(null===(c=null==t?void 0:t.page)||void 0===c?void 0:c.prev)&&(h.end=null===(l=t.page)||void 0===l?void 0:l.prev),(null==t?void 0:t.filter)&&(h.filter=t.filter),(null==t?void 0:t.limit)&&(h.limit=t.limit),(null==t?void 0:t.sort)&&(h.sort=Object.entries(null!==(p=t.sort)&&void 0!==p?p:{}).map((function(e){var t=s(e,2),n=t[0],r=t[1];return"asc"===r||"desc"===r?"".concat(n,":").concat(r):n}))),h},handleResponse:function(e,t){return{status:t.status,data:t.data,totalCount:t.totalCount,prev:t.prev,next:t.next}}};var Ae=Object.freeze({__proto__:null,getOperation:function(){return M.PNAccessManagerAudit},validateParams:function(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"},getURL:function(e){var t=e.config;return"/v2/auth/audit/sub-key/".concat(t.subscribeKey)},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!1},prepareParams:function(e,t){var n=t.channel,r=t.channelGroup,i=t.authKeys,o=void 0===i?[]:i,s={};return n&&(s.channel=n),r&&(s["channel-group"]=r),o.length>0&&(s.auth=o.join(",")),s},handleResponse:function(e,t){return t.payload}});var Me=Object.freeze({__proto__:null,getOperation:function(){return M.PNAccessManagerGrant},validateParams:function(e,t){var n=e.config;return n.subscribeKey?n.publishKey?n.secretKey?null==t.uuids||t.authKeys?null==t.uuids||null==t.channels&&null==t.channelGroups?void 0:"Both channel/channelgroup and uuid cannot be used in the same request":"authKeys are required for grant request on uuids":"Missing Secret Key":"Missing Publish Key":"Missing Subscribe Key"},getURL:function(e){var t=e.config;return"/v2/auth/grant/sub-key/".concat(t.subscribeKey)},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!1},prepareParams:function(e,t){var n=t.channels,r=void 0===n?[]:n,i=t.channelGroups,o=void 0===i?[]:i,s=t.uuids,a=void 0===s?[]:s,u=t.ttl,c=t.read,l=void 0!==c&&c,p=t.write,h=void 0!==p&&p,f=t.manage,d=void 0!==f&&f,g=t.get,y=void 0!==g&&g,b=t.join,v=void 0!==b&&b,m=t.update,_=void 0!==m&&m,O=t.authKeys,P=void 0===O?[]:O,S=t.delete,w={};return w.r=l?"1":"0",w.w=h?"1":"0",w.m=d?"1":"0",w.d=S?"1":"0",w.g=y?"1":"0",w.j=v?"1":"0",w.u=_?"1":"0",r.length>0&&(w.channel=r.join(",")),o.length>0&&(w["channel-group"]=o.join(",")),P.length>0&&(w.auth=P.join(",")),a.length>0&&(w["target-uuid"]=a.join(",")),(u||0===u)&&(w.ttl=u),w},handleResponse:function(){return{}}});function Re(e){var t=0;return e.join&&(t|=128),e.update&&(t|=64),e.get&&(t|=32),e.delete&&(t|=8),e.manage&&(t|=4),e.write&&(t|=2),e.read&&(t|=1),t}var je=Object.freeze({__proto__:null,getOperation:function(){return M.PNAccessManagerGrantToken},extractPermissions:Re,validateParams:function(e,t){var n=e.config;return n.subscribeKey?n.publishKey?n.secretKey?t.resources||t.patterns?(!t.resources||t.resources.uuids&&0!==Object.keys(t.resources.uuids).length||t.resources.channels&&0!==Object.keys(t.resources.channels).length||t.resources.groups&&0!==Object.keys(t.resources.groups).length)&&(!t.patterns||t.patterns.uuids&&0!==Object.keys(t.patterns.uuids).length||t.patterns.channels&&0!==Object.keys(t.patterns.channels).length||t.patterns.groups&&0!==Object.keys(t.patterns.groups).length)?void 0:"Missing values for either Resources or Patterns.":"Missing either Resources or Patterns.":"Missing Secret Key":"Missing Publish Key":"Missing Subscribe Key"},postURL:function(e){var t=e.config;return"/v3/pam/".concat(t.subscribeKey,"/grant")},usePost:function(){return!0},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!1},prepareParams:function(){return{}},postPayload:function(e,t){return function(e,t){var n=t.ttl,r=t.resources,i=t.patterns,o=t.meta,s=t.authorized_uuid,a={ttl:0,permissions:{resources:{channels:{},groups:{},uuids:{},users:{},spaces:{}},patterns:{channels:{},groups:{},uuids:{},users:{},spaces:{}},meta:{}}};if(r){var u=r.uuids,c=r.channels,l=r.groups;u&&Object.keys(u).forEach((function(e){a.permissions.resources.uuids[e]=Re(u[e])})),c&&Object.keys(c).forEach((function(e){a.permissions.resources.channels[e]=Re(c[e])})),l&&Object.keys(l).forEach((function(e){a.permissions.resources.groups[e]=Re(l[e])}))}if(i){var p=i.uuids,h=i.channels,f=i.groups;p&&Object.keys(p).forEach((function(e){a.permissions.patterns.uuids[e]=Re(p[e])})),h&&Object.keys(h).forEach((function(e){a.permissions.patterns.channels[e]=Re(h[e])})),f&&Object.keys(f).forEach((function(e){a.permissions.patterns.groups[e]=Re(f[e])}))}return(n||0===n)&&(a.ttl=n),o&&(a.permissions.meta=o),s&&(a.permissions.uuid="".concat(s)),a}(0,t)},handleResponse:function(e,t){return t.data.token}}),Ue={getOperation:function(){return M.PNAccessManagerRevokeToken},validateParams:function(e,t){return e.config.secretKey?t?void 0:"token can't be empty":"Missing Secret Key"},getURL:function(e,t){var n=e.config;return"/v3/pam/".concat(n.subscribeKey,"/grant/").concat(C.encodeString(t))},useDelete:function(){return!0},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!1},prepareParams:function(e){return{uuid:e.config.getUUID()}},handleResponse:function(e,t){return{status:t.status,data:t.data}}};function xe(e,t){var n=e.crypto,r=e.config,i=JSON.stringify(t);return r.cipherKey&&(i=n.encrypt(i),i=JSON.stringify(i)),i}var De=Object.freeze({__proto__:null,getOperation:function(){return M.PNPublishOperation},validateParams:function(e,t){var n=e.config,r=t.message;return t.channel?r?n.subscribeKey?void 0:"Missing Subscribe Key":"Missing Message":"Missing Channel"},usePost:function(e,t){var n=t.sendByPost;return void 0!==n&&n},getURL:function(e,t){var n=e.config,r=t.channel,i=xe(e,t.message);return"/publish/".concat(n.publishKey,"/").concat(n.subscribeKey,"/0/").concat(C.encodeString(r),"/0/").concat(C.encodeString(i))},postURL:function(e,t){var n=e.config,r=t.channel;return"/publish/".concat(n.publishKey,"/").concat(n.subscribeKey,"/0/").concat(C.encodeString(r),"/0")},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},postPayload:function(e,t){return xe(e,t.message)},prepareParams:function(e,t){var n=t.meta,r=t.replicate,i=void 0===r||r,o=t.storeInHistory,s=t.ttl,a={};return null!=o&&(a.store=o?"1":"0"),s&&(a.ttl=s),!1===i&&(a.norep="true"),n&&"object"==typeof n&&(a.meta=JSON.stringify(n)),a},handleResponse:function(e,t){return{timetoken:t[2]}}});var Ie=Object.freeze({__proto__:null,getOperation:function(){return M.PNSignalOperation},validateParams:function(e,t){var n=e.config,r=t.message;return t.channel?r?n.subscribeKey?void 0:"Missing Subscribe Key":"Missing Message":"Missing Channel"},getURL:function(e,t){var n,r=e.config,i=t.channel,o=t.message,s=(n=o,JSON.stringify(n));return"/signal/".concat(r.publishKey,"/").concat(r.subscribeKey,"/0/").concat(C.encodeString(i),"/0/").concat(C.encodeString(s))},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(){return{}},handleResponse:function(e,t){return{timetoken:t[2]}}});function Ge(e,t){var n=e.config,r=e.crypto;if(!n.cipherKey)return t;try{return r.decrypt(t)}catch(e){return t}}var Ke=Object.freeze({__proto__:null,getOperation:function(){return M.PNHistoryOperation},validateParams:function(e,t){var n=t.channel,r=e.config;return n?r.subscribeKey?void 0:"Missing Subscribe Key":"Missing channel"},getURL:function(e,t){var n=t.channel,r=e.config;return"/v2/history/sub-key/".concat(r.subscribeKey,"/channel/").concat(C.encodeString(n))},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var n=t.start,r=t.end,i=t.reverse,o=t.count,s=void 0===o?100:o,a=t.stringifiedTimeToken,u=void 0!==a&&a,c=t.includeMeta,l=void 0!==c&&c,p={include_token:"true"};return p.count=s,n&&(p.start=n),r&&(p.end=r),u&&(p.string_message_token="true"),null!=i&&(p.reverse=i.toString()),l&&(p.include_meta="true"),p},handleResponse:function(e,t){var n={messages:[],startTimeToken:t[1],endTimeToken:t[2]};return Array.isArray(t[0])&&t[0].forEach((function(t){var r={timetoken:t.timetoken,entry:Ge(e,t.message)};t.meta&&(r.meta=t.meta),n.messages.push(r)})),n}});var Fe=Object.freeze({__proto__:null,getOperation:function(){return M.PNDeleteMessagesOperation},validateParams:function(e,t){var n=t.channel,r=e.config;return n?r.subscribeKey?void 0:"Missing Subscribe Key":"Missing channel"},useDelete:function(){return!0},getURL:function(e,t){var n=t.channel,r=e.config;return"/v3/history/sub-key/".concat(r.subscribeKey,"/channel/").concat(C.encodeString(n))},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var n=t.start,r=t.end,i={};return n&&(i.start=n),r&&(i.end=r),i},handleResponse:function(e,t){return t.payload}});var Le=Object.freeze({__proto__:null,getOperation:function(){return M.PNMessageCounts},validateParams:function(e,t){var n=t.channels,r=t.timetoken,i=t.channelTimetokens,o=e.config;return n?r&&i?"timetoken and channelTimetokens are incompatible together":r&&i&&i.length>1&&n.length!==i.length?"Length of channelTimetokens and channels do not match":o.subscribeKey?void 0:"Missing Subscribe Key":"Missing channel"},getURL:function(e,t){var n=t.channels,r=e.config,i=n.join(",");return"/v3/history/sub-key/".concat(r.subscribeKey,"/message-counts/").concat(C.encodeString(i))},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var n=t.timetoken,r=t.channelTimetokens,i={};if(r&&1===r.length){var o=s(r,1)[0];i.timetoken=o}else r?i.channelsTimetoken=r.join(","):n&&(i.timetoken=n);return i},handleResponse:function(e,t){return{channels:t.channels}}});var Be=Object.freeze({__proto__:null,getOperation:function(){return M.PNFetchMessagesOperation},validateParams:function(e,t){var n=t.channels,r=t.includeMessageActions,i=void 0!==r&&r,o=e.config;if(!n||0===n.length)return"Missing channels";if(!o.subscribeKey)return"Missing Subscribe Key";if(i&&n.length>1)throw new TypeError("History can return actions data for a single channel only. Either pass a single channel or disable the includeMessageActions flag.")},getURL:function(e,t){var n=t.channels,r=void 0===n?[]:n,i=t.includeMessageActions,o=void 0!==i&&i,s=e.config,a=o?"history-with-actions":"history",u=r.length>0?r.join(","):",";return"/v3/".concat(a,"/sub-key/").concat(s.subscribeKey,"/channel/").concat(C.encodeString(u))},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var n=t.channels,r=t.start,i=t.end,o=t.includeMessageActions,s=t.count,a=t.stringifiedTimeToken,u=void 0!==a&&a,c=t.includeMeta,l=void 0!==c&&c,p=t.includeUuid,h=t.includeUUID,f=void 0===h||h,d=t.includeMessageType,g=void 0===d||d,y={};return y.max=s||(n.length>1||!0===o?25:100),r&&(y.start=r),i&&(y.end=i),u&&(y.string_message_token="true"),l&&(y.include_meta="true"),f&&!1!==p&&(y.include_uuid="true"),g&&(y.include_message_type="true"),y},handleResponse:function(e,t){var n={channels:{}};return Object.keys(t.channels||{}).forEach((function(r){n.channels[r]=[],(t.channels[r]||[]).forEach((function(t){var i={};i.channel=r,i.timetoken=t.timetoken,i.message=function(e,t){var n=e.config,r=e.crypto;if(!n.cipherKey)return t;try{return r.decrypt(t)}catch(e){return t}}(e,t.message),i.messageType=t.message_type,i.uuid=t.uuid,t.actions&&(i.actions=t.actions,i.data=t.actions),t.meta&&(i.meta=t.meta),n.channels[r].push(i)}))})),t.more&&(n.more=t.more),n}});var He=Object.freeze({__proto__:null,getOperation:function(){return M.PNTimeOperation},getURL:function(){return"/time/0"},getRequestTimeout:function(e){return e.config.getTransactionTimeout()},prepareParams:function(){return{}},isAuthSupported:function(){return!1},handleResponse:function(e,t){return{timetoken:t[0]}},validateParams:function(){}});var qe=Object.freeze({__proto__:null,getOperation:function(){return M.PNSubscribeOperation},validateParams:function(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"},getURL:function(e,t){var n=e.config,r=t.channels,i=void 0===r?[]:r,o=i.length>0?i.join(","):",";return"/v2/subscribe/".concat(n.subscribeKey,"/").concat(C.encodeString(o),"/0")},getRequestTimeout:function(e){return e.config.getSubscribeTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var n=e.config,r=t.state,i=t.channelGroups,o=void 0===i?[]:i,s=t.timetoken,a=t.filterExpression,u=t.region,c={heartbeat:n.getPresenceTimeout()};return o.length>0&&(c["channel-group"]=o.join(",")),a&&a.length>0&&(c["filter-expr"]=a),Object.keys(r).length&&(c.state=JSON.stringify(r)),s&&(c.tt=s),u&&(c.tr=u),c},handleResponse:function(e,t){var n=[];t.m.forEach((function(e){var t={publishTimetoken:e.p.t,region:e.p.r},r={shard:parseInt(e.a,10),subscriptionMatch:e.b,channel:e.c,messageType:e.e,payload:e.d,flags:e.f,issuingClientId:e.i,subscribeKey:e.k,originationTimetoken:e.o,userMetadata:e.u,publishMetaData:t};n.push(r)}));var r={timetoken:t.t.t,region:t.t.r};return{messages:n,metadata:r}}}),ze={getOperation:function(){return M.PNHandshakeOperation},validateParams:function(e,t){if(!(null==t?void 0:t.channels)&&!(null==t?void 0:t.channelGroups))return"channels and channleGroups both should not be empty"},getURL:function(e,t){var n=e.config,r=t.channels?t.channels.join(","):",";return"/v2/subscribe/".concat(n.subscribeKey,"/").concat(C.encodeString(r),"/0")},getRequestTimeout:function(e){return e.config.getSubscribeTimeout()},isAuthSupported:function(){return!0},prepareParams:function(e,t){var n={};return t.channelGroups&&t.channelGroups.length>0&&(n["channel-group"]=t.channelGroups.join(",")),n.tt=0,n},handleResponse:function(e,t){return{region:t.t.r,timetoken:t.t.t}}},Ve={getOperation:function(){return M.PNReceiveMessagesOperation},validateParams:function(e,t){return(null==t?void 0:t.channels)||(null==t?void 0:t.channelGroups)?(null==t?void 0:t.timetoken)?(null==t?void 0:t.region)?void 0:"region can not be empty":"timetoken can not be empty":"channels and channleGroups both should not be empty"},getURL:function(e,t){var n=e.config,r=t.channels?t.channels.join(","):",";return"/v2/subscribe/".concat(n.subscribeKey,"/").concat(C.encodeString(r),"/0")},getRequestTimeout:function(e){return e.config.getSubscribeTimeout()},isAuthSupported:function(){return!0},getAbortSignal:function(e,t){return t.abortSignal},prepareParams:function(e,t){var n={};return t.channelGroups&&t.channelGroups.length>0&&(n["channel-group"]=t.channelGroups.join(",")),n.tt=t.timetoken,n.tr=t.region,n},handleResponse:function(e,t){var n=[];return t.m.forEach((function(e){var t={shard:parseInt(e.a,10),subscriptionMatch:e.b,channel:e.c,messageType:e.e,payload:e.d,flags:e.f,issuingClientId:e.i,subscribeKey:e.k,originationTimetoken:e.o,publishMetaData:{timetoken:e.p.t,region:e.p.r}};n.push(t)})),{messages:n,metadata:{region:t.t.r,timetoken:t.t.t}}}},Je=function(){function e(e){void 0===e&&(e=!1),this.sync=e,this.listeners=new Set}return e.prototype.subscribe=function(e){var t=this;return this.listeners.add(e),function(){t.listeners.delete(e)}},e.prototype.notify=function(e){var t=this,n=function(){t.listeners.forEach((function(t){t(e)}))};this.sync?n():setTimeout(n,0)},e}(),We=function(){function e(e){this.label=e,this.transitionMap=new Map,this.enterEffects=[],this.exitEffects=[]}return e.prototype.transition=function(e,t){var n;if(this.transitionMap.has(t.type))return null===(n=this.transitionMap.get(t.type))||void 0===n?void 0:n(e,t)},e.prototype.on=function(e,t){return this.transitionMap.set(e,t),this},e.prototype.with=function(e,t){return[this,e,null!=t?t:[]]},e.prototype.onEnter=function(e){return this.enterEffects.push(e),this},e.prototype.onExit=function(e){return this.exitEffects.push(e),this},e}(),Xe=function(e){function n(){return null!==e&&e.apply(this,arguments)||this}return t(n,e),n.prototype.describe=function(e){return new We(e)},n.prototype.start=function(e,t){this.currentState=e,this.currentContext=t,this.notify({type:"engineStarted",state:e,context:t})},n.prototype.transition=function(e){var t,n,r,i,a,u;if(!this.currentState)throw new Error("Start the engine first");this.notify({type:"eventReceived",event:e});var c=this.currentState.transition(this.currentContext,e);if(c){var l=s(c,3),p=l[0],h=l[1],f=l[2];try{for(var d=o(this.currentState.exitEffects),g=d.next();!g.done;g=d.next()){var y=g.value;this.notify({type:"invocationDispatched",invocation:y(this.currentContext)})}}catch(e){t={error:e}}finally{try{g&&!g.done&&(n=d.return)&&n.call(d)}finally{if(t)throw t.error}}var b=this.currentState;this.currentState=p;var v=this.currentContext;this.currentContext=h,this.notify({type:"transitionDone",fromState:b,fromContext:v,toState:p,toContext:h,event:e});try{for(var m=o(f),_=m.next();!_.done;_=m.next()){y=_.value;this.notify({type:"invocationDispatched",invocation:y})}}catch(e){r={error:e}}finally{try{_&&!_.done&&(i=m.return)&&i.call(m)}finally{if(r)throw r.error}}try{for(var O=o(this.currentState.enterEffects),P=O.next();!P.done;P=O.next()){y=P.value;this.notify({type:"invocationDispatched",invocation:y(this.currentContext)})}}catch(e){a={error:e}}finally{try{P&&!P.done&&(u=O.return)&&u.call(O)}finally{if(a)throw a.error}}}},n}(Je),$e=function(){function e(e){this.dependencies=e,this.instances=new Map,this.handlers=new Map}return e.prototype.on=function(e,t){this.handlers.set(e,t)},e.prototype.dispatch=function(e){if("CANCEL"!==e.type){var t=this.handlers.get(e.type);if(!t)throw new Error("Unhandled invocation '".concat(e.type,"'"));var n=t(e.payload,this.dependencies);e.managed&&this.instances.set(e.type,n),n.start()}else if(this.instances.has(e.payload)){var r=this.instances.get(e.payload);null==r||r.cancel(),this.instances.delete(e.payload)}},e}();function Qe(e,t){var n=function(){for(var n=[],r=0;r<arguments.length;r++)n[r]=arguments[r];return{type:e,payload:null==t?void 0:t.apply(void 0,a([],s(n),!1))}};return n.type=e,n}function Ye(e,t){var n=function(){for(var n=[],r=0;r<arguments.length;r++)n[r]=arguments[r];return{type:e,payload:t.apply(void 0,a([],s(n),!1)),managed:!0}};return n.type=e,n.cancel={type:"CANCEL",payload:e,managed:!1},n}var Ze,et,tt,nt=function(e){function n(){var t=this.constructor,n=e.call(this,"The operation was aborted.")||this;return n.name="AbortError",Object.setPrototypeOf(n,t.prototype),n}return t(n,e),n}(Error),rt=function(e){function n(){var t=null!==e&&e.apply(this,arguments)||this;return t._aborted=!1,t}return t(n,e),Object.defineProperty(n.prototype,"aborted",{get:function(){return this._aborted},enumerable:!1,configurable:!0}),n.prototype.throwIfAborted=function(){if(this._aborted)throw new nt},n.prototype.abort=function(){this._aborted=!0,this.notify(new nt)},n}(Je),it=function(e){function n(t,n,r){var i=e.call(this,t,n)||this;return i.asyncFunction=r,i.abortSignal=new rt,i}return t(n,e),n.prototype.start=function(){this.asyncFunction(this.payload,this.abortSignal,this.dependencies)},n.prototype.cancel=function(){this.abortSignal.abort()},n}((function(e,t){this.payload=e,this.dependencies=t})),ot=function(e){return function(t,n){return new it(t,n,e)}},st=Ye("HANDSHAKE",(function(e,t){return{channels:e,groups:t}})),at=Ye("RECEIVE_EVENTS",(function(e,t,n){return{channels:e,groups:t,cursor:n}})),ut=(et=function(e){return e},tt=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];return{type:Ze,payload:et.apply(void 0,a([],s(e),!1)),managed:!1}},tt.type=Ze="EMIT_EVENTS",tt),ct=Ye("RECONNECT",(function(e){return e})),lt=Ye("HANDSHAKE_RECONNECT",(function(e){return e})),pt=Qe("SUBSCRIPTION_CHANGE",(function(e,t){return{channels:e,groups:t}})),ht=Qe("DISCONNECT",(function(){return{}})),ft=Qe("RECONNECT",(function(){return{}}));Qe("RESTORE",(function(e,t,n,r){return{channels:e,groups:t,timetoken:n,region:r}}));var dt=Qe("HANDSHAKING_SUCCESS",(function(e){return e})),gt=Qe("HANDSHAKING_FAILURE",(function(e){return e})),yt=Qe("HANDSHAKING_RECONNECTING_SUCCESS",(function(e){return{cursor:e}})),bt=Qe("HANDSHAKING_RECONNECTING_FAILURE",(function(e){return e})),vt=Qe("HANDSHAKING_RECONNECTING_GIVEUP",(function(){return{}})),mt=Qe("HANDSHAKING_RECONNECTING_RETRY",(function(){return{}})),_t=Qe("RECEIVING_SUCCESS",(function(e,t){return{cursor:e,events:t}})),Ot=Qe("RECEIVING_FAILURE",(function(e){return e})),Pt=Qe("RECONNECTING_SUCCESS",(function(e,t){return{cursor:e,events:t}})),St=Qe("RECONNECTING_FAILURE",(function(e){return e})),wt=Qe("RECONNECTING_GIVEUP",(function(){return{}})),Tt=Qe("RECONNECTING_RETRY",(function(){return{}})),kt=function(e){function n(t,n){var o=e.call(this,n)||this;return o.on(st.type,ot((function(e,n,s){var a=s.handshake;return r(o,void 0,void 0,(function(){var r,o;return i(this,(function(i){switch(i.label){case 0:n.throwIfAborted(),i.label=1;case 1:return i.trys.push([1,3,,4]),[4,a({abortSignal:n,channels:e.channels,channelGroups:e.groups})];case 2:return r=i.sent(),t.transition(dt(r)),[3,4];case 3:return(o=i.sent())instanceof Error&&"Aborted"===o.message?[2]:o instanceof F?[2,t.transition(gt(o))]:[3,4];case 4:return[2]}}))}))}))),o.on(at.type,ot((function(e,n,s){var a=s.receiveEvents;return r(o,void 0,void 0,(function(){var r,o;return i(this,(function(i){switch(i.label){case 0:n.throwIfAborted(),i.label=1;case 1:return i.trys.push([1,3,,4]),[4,a({abortSignal:n,channels:e.channels,channelGroups:e.groups,timetoken:e.cursor.timetoken,region:e.cursor.region})];case 2:return r=i.sent(),t.transition(_t(r.metadata,r.messages)),[3,4];case 3:return(o=i.sent())instanceof Error&&"Aborted"===o.message?[2]:o instanceof F?[2,t.transition(Ot(o))]:[3,4];case 4:return[2]}}))}))}))),o.on(ut.type,ot((function(e,t,n){return n.receiveEvents,r(o,void 0,void 0,(function(){return i(this,(function(t){return e.length>0&&console.log(e),[2]}))}))}))),o.on(ct.type,ot((function(e,n,s){var a=s.receiveEvents,u=s.shouldRetry,c=s.getRetryDelay,l=s.delay;return r(o,void 0,void 0,(function(){var r,o;return i(this,(function(i){switch(i.label){case 0:return u(e.reason,e.attempts)?(n.throwIfAborted(),[4,l(c(e.attempts))]):[2,t.transition(wt())];case 1:i.sent(),n.throwIfAborted(),i.label=2;case 2:return i.trys.push([2,4,,5]),[4,a({abortSignal:n,channels:e.channels,channelGroups:e.groups,timetoken:e.cursor.timetoken,region:e.cursor.region})];case 3:return r=i.sent(),[2,t.transition(Pt(r.metadata,r.messages))];case 4:return(o=i.sent())instanceof Error&&"Aborted"===o.message?[2]:o instanceof F?[2,t.transition(St(o))]:[3,5];case 5:return[2]}}))}))}))),o.on(lt.type,ot((function(e,n,s){var a=s.handshake,u=s.shouldRetry,c=s.getRetryDelay,l=s.delay;return r(o,void 0,void 0,(function(){var r,o;return i(this,(function(i){switch(i.label){case 0:return u(e.reason,e.attempts)?(n.throwIfAborted(),[4,l(c(e.attempts))]):[2,t.transition(vt())];case 1:i.sent(),n.throwIfAborted(),i.label=2;case 2:return i.trys.push([2,4,,5]),[4,a({abortSignal:n,channels:e.channels,channelGroups:e.groups})];case 3:return r=i.sent(),[2,t.transition(yt(r.metadata))];case 4:return(o=i.sent())instanceof Error&&"Aborted"===o.message?[2]:o instanceof F?[2,t.transition(bt(o))]:[3,5];case 5:return[2]}}))}))}))),o}return t(n,e),n}($e),Nt=new We("STOPPED");Nt.on(pt.type,(function(e,t){return Nt.with({channels:t.payload.channels,groups:t.payload.groups})})),Nt.on(ft.type,(function(e){return Ut.with(n({},e))}));var Ct=new We("HANDSHAKE_FAILURE");Ct.on(mt.type,(function(e){return jt.with(n(n({},e),{attempts:0}))})),Ct.on(ht.type,(function(e){return Nt.with({channels:e.channels,groups:e.groups})}));var Et=new We("STOPPED");Et.on(pt.type,(function(e,t){return Et.with({channels:t.payload.channels,groups:t.payload.groups,cursor:e.cursor})})),Et.on(ft.type,(function(e){return Rt.with(n({},e))}));var At=new We("RECEIVE_FAILURE");At.on(Tt.type,(function(e){return Mt.with(n(n({},e),{attempts:0}))})),At.on(ht.type,(function(e){return Et.with({channels:e.channels,groups:e.groups,cursor:e.cursor})}));var Mt=new We("RECEIVE_RECONNECTING");Mt.onEnter((function(e){return ct(e)})),Mt.onExit((function(){return ct.cancel})),Mt.on(Pt.type,(function(e,t){return Rt.with({channels:e.channels,groups:e.groups,cursor:t.payload.cursor},[ut(t.payload.events)])})),Mt.on(St.type,(function(e,t){return Mt.with(n(n({},e),{attempts:e.attempts+1,reason:t.payload}))})),Mt.on(wt.type,(function(e){return At.with({groups:e.groups,channels:e.channels,cursor:e.cursor,reason:e.reason})})),Mt.on(ht.type,(function(e){return Et.with({channels:e.channels,groups:e.groups,cursor:e.cursor})}));var Rt=new We("RECEIVING");Rt.onEnter((function(e){return at(e.channels,e.groups,e.cursor)})),Rt.onExit((function(){return at.cancel})),Rt.on(_t.type,(function(e,t){return Rt.with(n(n({},e),{cursor:t.payload.cursor}),[ut(t.payload.events)])})),Rt.on(pt.type,(function(e,t){return 0===t.payload.channels.length&&0===t.payload.groups.length?xt.with(void 0):Rt.with(n(n({},e),{channels:t.payload.channels,groups:t.payload.groups}))})),Rt.on(Ot.type,(function(e,t){return Mt.with(n(n({},e),{attempts:0,reason:t.payload}))})),Rt.on(ht.type,(function(e){return Et.with({channels:e.channels,groups:e.groups,cursor:e.cursor})}));var jt=new We("HANDSHAKE_RECONNECTING");jt.onEnter((function(e){return lt(e)})),jt.onExit((function(){return ct.cancel})),jt.on(Pt.type,(function(e,t){return Rt.with({channels:e.channels,groups:e.groups,cursor:t.payload.cursor},[ut(t.payload.events)])})),jt.on(St.type,(function(e,t){return jt.with(n(n({},e),{attempts:e.attempts+1,reason:t.payload}))})),jt.on(wt.type,(function(e){return Ct.with({groups:e.groups,channels:e.channels,reason:e.reason})})),jt.on(ht.type,(function(e){return Nt.with({channels:e.channels,groups:e.groups})}));var Ut=new We("HANDSHAKING");Ut.onEnter((function(e){return st(e.channels,e.groups)})),Ut.onExit((function(){return st.cancel})),Ut.on(pt.type,(function(e,t){return 0===t.payload.channels.length&&0===t.payload.groups.length?xt.with(void 0):Ut.with({channels:t.payload.channels,groups:t.payload.groups})})),Ut.on(dt.type,(function(e,t){return Rt.with({channels:e.channels,groups:e.groups,cursor:t.payload})})),Ut.on(gt.type,(function(e,t){return jt.with(n(n({},e),{attempts:0,reason:t.payload}))})),Ut.on(ht.type,(function(e){return Nt.with({channels:e.channels,groups:e.groups})}));var xt=new We("UNSUBSCRIBED");xt.on(pt.type,(function(e,t){return Ut.with({channels:t.payload.channels,groups:t.payload.groups})}));var Dt=function(){function e(e){var t=this;this.engine=new Xe,this.channels=[],this.groups=[],this.dispatcher=new kt(this.engine,e),this.engine.subscribe((function(e){"invocationDispatched"===e.type&&t.dispatcher.dispatch(e.invocation)})),this.engine.start(xt,void 0)}return Object.defineProperty(e.prototype,"_engine",{get:function(){return this.engine},enumerable:!1,configurable:!0}),e.prototype.subscribe=function(e){var t=e.channels,n=e.groups;this.channels=a(a([],s(this.channels),!1),s(null!=t?t:[]),!1),this.groups=a(a([],s(this.groups),!1),s(null!=n?n:[]),!1),this.engine.transition(pt(this.channels,this.groups))},e.prototype.unsubscribe=function(e){var t=e.channels,n=e.groups;this.channels=this.channels.filter((function(e){var n;return null===(n=!(null==t?void 0:t.includes(e)))||void 0===n||n})),this.groups=this.groups.filter((function(e){var t;return null===(t=!(null==n?void 0:n.includes(e)))||void 0===t||t})),this.engine.transition(pt(this.channels.slice(0),this.groups.slice(0)))},e.prototype.unsubscribeAll=function(){this.channels=[],this.groups=[],this.engine.transition(pt(this.channels.slice(0),this.groups.slice(0)))},e.prototype.reconnect=function(){this.engine.transition(ft())},e.prototype.disconnect=function(){this.engine.transition(ht())},e}(),It=function(){function e(e){var t=this,r=e.networking,i=e.cbor,o=new m({setup:e});this._config=o;var u=new S({config:o}),c=e.cryptography;r.init(o);var l=new K(o,i);this._tokenManager=l;var p=new R({maximumSamplesCount:6e4});this._telemetryManager=p;var h={config:o,networking:r,crypto:u,cryptography:c,tokenManager:l,telemetryManager:p,PubNubFile:e.PubNubFile};this.File=e.PubNubFile,this.encryptFile=function(e,n){return c.encryptFile(e,n,t.File)},this.decryptFile=function(e,n){return c.decryptFile(e,n,t.File)};var f=V.bind(this,h,He),d=V.bind(this,h,ne),g=V.bind(this,h,ie),y=V.bind(this,h,se),b=V.bind(this,h,qe),v=new G;if(this._listenerManager=v,this.iAmHere=V.bind(this,h,ie),this.iAmAway=V.bind(this,h,ne),this.setPresenceState=V.bind(this,h,se),this.handshake=V.bind(this,h,ze),this.receiveMessages=V.bind(this,h,Ve),!0===o.enableSubscribeBeta){var _=new Dt({handshake:this.handshake,receiveEvents:this.receiveMessages});this.subscribe=_.subscribe.bind(_),this.unsubscribe=_.unsubscribe.bind(_),this.eventEngine=_}else{var O=new A({timeEndpoint:f,leaveEndpoint:d,heartbeatEndpoint:g,setStateEndpoint:y,subscribeEndpoint:b,crypto:h.crypto,config:h.config,listenerManager:v,getFileUrl:function(e){return ge(h,e)}});this.subscribe=O.adaptSubscribeChange.bind(O),this.unsubscribe=O.adaptUnsubscribeChange.bind(O),this.disconnect=O.disconnect.bind(O),this.reconnect=O.reconnect.bind(O),this.unsubscribeAll=O.unsubscribeAll.bind(O),this.getSubscribedChannels=O.getSubscribedChannels.bind(O),this.getSubscribedChannelGroups=O.getSubscribedChannelGroups.bind(O),this.setState=O.adaptStateChange.bind(O),this.presence=O.adaptPresenceChange.bind(O),this.destroy=function(e){O.unsubscribeAll(e),O.disconnect()}}this.addListener=v.addListener.bind(v),this.removeListener=v.removeListener.bind(v),this.removeAllListeners=v.removeAllListeners.bind(v),this.parseToken=l.parseToken.bind(l),this.setToken=l.setToken.bind(l),this.getToken=l.getToken.bind(l),this.channelGroups={listGroups:V.bind(this,h,$),listChannels:V.bind(this,h,Q),addChannels:V.bind(this,h,J),removeChannels:V.bind(this,h,W),deleteGroup:V.bind(this,h,X)},this.push={addChannels:V.bind(this,h,Y),removeChannels:V.bind(this,h,Z),deleteDevice:V.bind(this,h,te),listChannels:V.bind(this,h,ee)},this.hereNow=V.bind(this,h,ae),this.whereNow=V.bind(this,h,re),this.getState=V.bind(this,h,oe),this.grant=V.bind(this,h,Me),this.grantToken=V.bind(this,h,je),this.audit=V.bind(this,h,Ae),this.revokeToken=V.bind(this,h,Ue),this.publish=V.bind(this,h,De),this.fire=function(e,n){return e.replicate=!1,e.storeInHistory=!1,t.publish(e,n)},this.signal=V.bind(this,h,Ie),this.history=V.bind(this,h,Ke),this.deleteMessages=V.bind(this,h,Fe),this.messageCounts=V.bind(this,h,Le),this.fetchMessages=V.bind(this,h,Be),this.addMessageAction=V.bind(this,h,ue),this.removeMessageAction=V.bind(this,h,ce),this.getMessageActions=V.bind(this,h,le),this.listFiles=V.bind(this,h,pe);var P=V.bind(this,h,he);this.publishFile=V.bind(this,h,fe),this.sendFile=de({generateUploadUrl:P,publishFile:this.publishFile,modules:h}),this.getFileUrl=function(e){return ge(h,e)},this.downloadFile=V.bind(this,h,ye),this.deleteFile=V.bind(this,h,be),this.objects={getAllUUIDMetadata:V.bind(this,h,ve),getUUIDMetadata:V.bind(this,h,me),setUUIDMetadata:V.bind(this,h,_e),removeUUIDMetadata:V.bind(this,h,Oe),getAllChannelMetadata:V.bind(this,h,Pe),getChannelMetadata:V.bind(this,h,Se),setChannelMetadata:V.bind(this,h,we),removeChannelMetadata:V.bind(this,h,Te),getChannelMembers:V.bind(this,h,ke),setChannelMembers:function(e){for(var r=[],i=1;i<arguments.length;i++)r[i-1]=arguments[i];return V.call.apply(V,a([t,h,Ne,n({type:"set"},e)],s(r),!1))},removeChannelMembers:function(e){for(var r=[],i=1;i<arguments.length;i++)r[i-1]=arguments[i];return V.call.apply(V,a([t,h,Ne,n({type:"delete"},e)],s(r),!1))},getMemberships:V.bind(this,h,Ce),setMemberships:function(e){for(var r=[],i=1;i<arguments.length;i++)r[i-1]=arguments[i];return V.call.apply(V,a([t,h,Ee,n({type:"set"},e)],s(r),!1))},removeMemberships:function(e){for(var r=[],i=1;i<arguments.length;i++)r[i-1]=arguments[i];return V.call.apply(V,a([t,h,Ee,n({type:"delete"},e)],s(r),!1))}},this.createUser=function(e){return t.objects.setUUIDMetadata({uuid:e.userId,data:e.data,include:e.include})},this.updateUser=this.createUser,this.removeUser=function(e){return t.objects.removeUUIDMetadata({uuid:null==e?void 0:e.userId})},this.fetchUser=function(e){return t.objects.getUUIDMetadata({uuid:null==e?void 0:e.userId,include:null==e?void 0:e.include})},this.fetchUsers=this.objects.getAllUUIDMetadata,this.createSpace=function(e){return t.objects.setChannelMetadata({channel:e.spaceId,data:e.data,include:e.include})},this.updateSpace=this.createSpace,this.removeSpace=function(e){return t.objects.removeChannelMetadata({channel:e.spaceId})},this.fetchSpace=function(e){return t.objects.getChannelMetadata({channel:e.spaceId,include:e.include})},this.fetchSpaces=this.objects.getAllChannelMetadata,this.time=f,this.stop=this.destroy,this.encrypt=u.encrypt.bind(u),this.decrypt=u.decrypt.bind(u),this.getAuthKey=h.config.getAuthKey.bind(h.config),this.setAuthKey=h.config.setAuthKey.bind(h.config),this.setCipherKey=h.config.setCipherKey.bind(h.config),this.getUUID=h.config.getUUID.bind(h.config),this.setUUID=h.config.setUUID.bind(h.config),this.getFilterExpression=h.config.getFilterExpression.bind(h.config),this.setFilterExpression=h.config.setFilterExpression.bind(h.config),this.setHeartbeatInterval=h.config.setHeartbeatInterval.bind(h.config),r.hasModule("proxy")&&(this.setProxy=function(e){h.config.setProxy(e),t.reconnect()})}return e.prototype.getVersion=function(){return this._config.getVersion()},e.prototype._addPnsdkSuffix=function(e,t){this._config._addPnsdkSuffix(e,t)},e.prototype.networkDownDetected=function(){this._listenerManager.announceNetworkDown(),this._config.restore?this.disconnect():this.destroy(!0)},e.prototype.networkUpDetected=function(){this._listenerManager.announceNetworkUp(),this.reconnect()},e.notificationPayload=function(e,t){return new I(e,t)},e.generateUUID=function(){return v()},e.OPERATIONS=M,e.CATEGORIES=E,e}(),Gt=function(){function e(e){var t=this;this._modules={},Object.keys(e).forEach((function(n){t._modules[n]=e[n].bind(t)}))}return e.prototype.init=function(e){this._config=e,Array.isArray(this._config.origin)?this._currentSubDomain=Math.floor(Math.random()*this._config.origin.length):this._currentSubDomain=0,this._coreParams={},this.shiftStandardOrigin()},e.prototype.nextOrigin=function(){var e=this._config.secure?"https://":"http://";if("string"==typeof this._config.origin)return"".concat(e).concat(this._config.origin);this._currentSubDomain+=1,this._currentSubDomain>=this._config.origin.length&&(this._currentSubDomain=0);var t=this._config.origin[this._currentSubDomain];return"".concat(e).concat(t)},e.prototype.hasModule=function(e){return e in this._modules},e.prototype.shiftStandardOrigin=function(){return this._standardOrigin=this.nextOrigin(),this._standardOrigin},e.prototype.getStandardOrigin=function(){return this._standardOrigin},e.prototype.POSTFILE=function(e,t,n){return this._modules.postfile(e,t,n)},e.prototype.GETFILE=function(e,t,n){return this._modules.getfile(e,t,n)},e.prototype.POST=function(e,t,n,r){return this._modules.post(e,t,n,r)},e.prototype.PATCH=function(e,t,n,r){return this._modules.patch(e,t,n,r)},e.prototype.GET=function(e,t,n){return this._modules.get(e,t,n)},e.prototype.DELETE=function(e,t,n){return this._modules.del(e,t,n)},e.prototype._detectErrorCategory=function(e){if("ENOTFOUND"===e.code)return E.PNNetworkIssuesCategory;if("ECONNREFUSED"===e.code)return E.PNNetworkIssuesCategory;if("ECONNRESET"===e.code)return E.PNNetworkIssuesCategory;if("EAI_AGAIN"===e.code)return E.PNNetworkIssuesCategory;if(0===e.status||e.hasOwnProperty("status")&&void 0===e.status)return E.PNNetworkIssuesCategory;if(e.timeout)return E.PNTimeoutCategory;if("ETIMEDOUT"===e.code)return E.PNNetworkIssuesCategory;if(e.response){if(e.response.badRequest)return E.PNBadRequestCategory;if(e.response.forbidden)return E.PNAccessDeniedCategory}return E.PNUnknownCategory},e}(),Kt=function(){function e(e,t){this._base64ToBinary=t,this._decode=e}return e.prototype.decodeToken=function(e){var t="";e.length%4==3?t="=":e.length%4==2&&(t="==");var n=e.replace(/-/gi,"+").replace(/_/gi,"/")+t,r=this._decode(this._base64ToBinary(n));if("object"==typeof r)return r},e}(),Ft={exports:{}},Lt={exports:{}};!function(e){function t(e){if(e)return function(e){for(var n in t.prototype)e[n]=t.prototype[n];return e}(e)}e.exports=t,t.prototype.on=t.prototype.addEventListener=function(e,t){return this._callbacks=this._callbacks||{},(this._callbacks["$"+e]=this._callbacks["$"+e]||[]).push(t),this},t.prototype.once=function(e,t){function n(){this.off(e,n),t.apply(this,arguments)}return n.fn=t,this.on(e,n),this},t.prototype.off=t.prototype.removeListener=t.prototype.removeAllListeners=t.prototype.removeEventListener=function(e,t){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var n,r=this._callbacks["$"+e];if(!r)return this;if(1==arguments.length)return delete this._callbacks["$"+e],this;for(var i=0;i<r.length;i++)if((n=r[i])===t||n.fn===t){r.splice(i,1);break}return 0===r.length&&delete this._callbacks["$"+e],this},t.prototype.emit=function(e){this._callbacks=this._callbacks||{};for(var t=new Array(arguments.length-1),n=this._callbacks["$"+e],r=1;r<arguments.length;r++)t[r-1]=arguments[r];if(n){r=0;for(var i=(n=n.slice(0)).length;r<i;++r)n[r].apply(this,t)}return this},t.prototype.listeners=function(e){return this._callbacks=this._callbacks||{},this._callbacks["$"+e]||[]},t.prototype.hasListeners=function(e){return!!this.listeners(e).length}}(Lt);var Bt=Wt;Wt.default=Wt,Wt.stable=Yt,Wt.stableStringify=Yt;var Ht="[...]",qt="[Circular]",zt=[],Vt=[];function Jt(){return{depthLimit:Number.MAX_SAFE_INTEGER,edgesLimit:Number.MAX_SAFE_INTEGER}}function Wt(e,t,n,r){var i;void 0===r&&(r=Jt()),$t(e,"",0,[],void 0,0,r);try{i=0===Vt.length?JSON.stringify(e,t,n):JSON.stringify(e,en(t),n)}catch(e){return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]")}finally{for(;0!==zt.length;){var o=zt.pop();4===o.length?Object.defineProperty(o[0],o[1],o[3]):o[0][o[1]]=o[2]}}return i}function Xt(e,t,n,r){var i=Object.getOwnPropertyDescriptor(r,n);void 0!==i.get?i.configurable?(Object.defineProperty(r,n,{value:e}),zt.push([r,n,t,i])):Vt.push([t,n,e]):(r[n]=e,zt.push([r,n,t]))}function $t(e,t,n,r,i,o,s){var a;if(o+=1,"object"==typeof e&&null!==e){for(a=0;a<r.length;a++)if(r[a]===e)return void Xt(qt,e,t,i);if(void 0!==s.depthLimit&&o>s.depthLimit)return void Xt(Ht,e,t,i);if(void 0!==s.edgesLimit&&n+1>s.edgesLimit)return void Xt(Ht,e,t,i);if(r.push(e),Array.isArray(e))for(a=0;a<e.length;a++)$t(e[a],a,a,r,e,o,s);else{var u=Object.keys(e);for(a=0;a<u.length;a++){var c=u[a];$t(e[c],c,a,r,e,o,s)}}r.pop()}}function Qt(e,t){return e<t?-1:e>t?1:0}function Yt(e,t,n,r){void 0===r&&(r=Jt());var i,o=Zt(e,"",0,[],void 0,0,r)||e;try{i=0===Vt.length?JSON.stringify(o,t,n):JSON.stringify(o,en(t),n)}catch(e){return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]")}finally{for(;0!==zt.length;){var s=zt.pop();4===s.length?Object.defineProperty(s[0],s[1],s[3]):s[0][s[1]]=s[2]}}return i}function Zt(e,t,n,r,i,o,s){var a;if(o+=1,"object"==typeof e&&null!==e){for(a=0;a<r.length;a++)if(r[a]===e)return void Xt(qt,e,t,i);try{if("function"==typeof e.toJSON)return}catch(e){return}if(void 0!==s.depthLimit&&o>s.depthLimit)return void Xt(Ht,e,t,i);if(void 0!==s.edgesLimit&&n+1>s.edgesLimit)return void Xt(Ht,e,t,i);if(r.push(e),Array.isArray(e))for(a=0;a<e.length;a++)Zt(e[a],a,a,r,e,o,s);else{var u={},c=Object.keys(e).sort(Qt);for(a=0;a<c.length;a++){var l=c[a];Zt(e[l],l,a,r,e,o,s),u[l]=e[l]}if(void 0===i)return u;zt.push([i,t,e]),i[t]=u}r.pop()}}function en(e){return e=void 0!==e?e:function(e,t){return t},function(t,n){if(Vt.length>0)for(var r=0;r<Vt.length;r++){var i=Vt[r];if(i[1]===t&&i[0]===n){n=i[2],Vt.splice(r,1);break}}return e.call(this,t,n)}}var tn=String.prototype.replace,nn=/%20/g,rn="RFC3986",on={default:rn,formatters:{RFC1738:function(e){return tn.call(e,nn,"+")},RFC3986:function(e){return String(e)}},RFC1738:"RFC1738",RFC3986:rn},sn=on,an=Object.prototype.hasOwnProperty,un=Array.isArray,cn=function(){for(var e=[],t=0;t<256;++t)e.push("%"+((t<16?"0":"")+t.toString(16)).toUpperCase());return e}(),ln=function(e,t){for(var n=t&&t.plainObjects?Object.create(null):{},r=0;r<e.length;++r)void 0!==e[r]&&(n[r]=e[r]);return n},pn={arrayToObject:ln,assign:function(e,t){return Object.keys(t).reduce((function(e,n){return e[n]=t[n],e}),e)},combine:function(e,t){return[].concat(e,t)},compact:function(e){for(var t=[{obj:{o:e},prop:"o"}],n=[],r=0;r<t.length;++r)for(var i=t[r],o=i.obj[i.prop],s=Object.keys(o),a=0;a<s.length;++a){var u=s[a],c=o[u];"object"==typeof c&&null!==c&&-1===n.indexOf(c)&&(t.push({obj:o,prop:u}),n.push(c))}return function(e){for(;e.length>1;){var t=e.pop(),n=t.obj[t.prop];if(un(n)){for(var r=[],i=0;i<n.length;++i)void 0!==n[i]&&r.push(n[i]);t.obj[t.prop]=r}}}(t),e},decode:function(e,t,n){var r=e.replace(/\+/g," ");if("iso-8859-1"===n)return r.replace(/%[0-9a-f]{2}/gi,unescape);try{return decodeURIComponent(r)}catch(e){return r}},encode:function(e,t,n,r,i){if(0===e.length)return e;var o=e;if("symbol"==typeof e?o=Symbol.prototype.toString.call(e):"string"!=typeof e&&(o=String(e)),"iso-8859-1"===n)return escape(o).replace(/%u[0-9a-f]{4}/gi,(function(e){return"%26%23"+parseInt(e.slice(2),16)+"%3B"}));for(var s="",a=0;a<o.length;++a){var u=o.charCodeAt(a);45===u||46===u||95===u||126===u||u>=48&&u<=57||u>=65&&u<=90||u>=97&&u<=122||i===sn.RFC1738&&(40===u||41===u)?s+=o.charAt(a):u<128?s+=cn[u]:u<2048?s+=cn[192|u>>6]+cn[128|63&u]:u<55296||u>=57344?s+=cn[224|u>>12]+cn[128|u>>6&63]+cn[128|63&u]:(a+=1,u=65536+((1023&u)<<10|1023&o.charCodeAt(a)),s+=cn[240|u>>18]+cn[128|u>>12&63]+cn[128|u>>6&63]+cn[128|63&u])}return s},isBuffer:function(e){return!(!e||"object"!=typeof e)&&!!(e.constructor&&e.constructor.isBuffer&&e.constructor.isBuffer(e))},isRegExp:function(e){return"[object RegExp]"===Object.prototype.toString.call(e)},maybeMap:function(e,t){if(un(e)){for(var n=[],r=0;r<e.length;r+=1)n.push(t(e[r]));return n}return t(e)},merge:function e(t,n,r){if(!n)return t;if("object"!=typeof n){if(un(t))t.push(n);else{if(!t||"object"!=typeof t)return[t,n];(r&&(r.plainObjects||r.allowPrototypes)||!an.call(Object.prototype,n))&&(t[n]=!0)}return t}if(!t||"object"!=typeof t)return[t].concat(n);var i=t;return un(t)&&!un(n)&&(i=ln(t,r)),un(t)&&un(n)?(n.forEach((function(n,i){if(an.call(t,i)){var o=t[i];o&&"object"==typeof o&&n&&"object"==typeof n?t[i]=e(o,n,r):t.push(n)}else t[i]=n})),t):Object.keys(n).reduce((function(t,i){var o=n[i];return an.call(t,i)?t[i]=e(t[i],o,r):t[i]=o,t}),i)}},hn=pn,fn=on,dn=Object.prototype.hasOwnProperty,gn={brackets:function(e){return e+"[]"},comma:"comma",indices:function(e,t){return e+"["+t+"]"},repeat:function(e){return e}},yn=Array.isArray,bn=String.prototype.split,vn=Array.prototype.push,mn=function(e,t){vn.apply(e,yn(t)?t:[t])},_n=Date.prototype.toISOString,On=fn.default,Pn={addQueryPrefix:!1,allowDots:!1,charset:"utf-8",charsetSentinel:!1,delimiter:"&",encode:!0,encoder:hn.encode,encodeValuesOnly:!1,format:On,formatter:fn.formatters[On],indices:!1,serializeDate:function(e){return _n.call(e)},skipNulls:!1,strictNullHandling:!1},Sn=function e(t,n,r,i,o,s,a,u,c,l,p,h,f,d){var g,y=t;if("function"==typeof a?y=a(n,y):y instanceof Date?y=l(y):"comma"===r&&yn(y)&&(y=hn.maybeMap(y,(function(e){return e instanceof Date?l(e):e}))),null===y){if(i)return s&&!f?s(n,Pn.encoder,d,"key",p):n;y=""}if("string"==typeof(g=y)||"number"==typeof g||"boolean"==typeof g||"symbol"==typeof g||"bigint"==typeof g||hn.isBuffer(y)){if(s){var b=f?n:s(n,Pn.encoder,d,"key",p);if("comma"===r&&f){for(var v=bn.call(String(y),","),m="",_=0;_<v.length;++_)m+=(0===_?"":",")+h(s(v[_],Pn.encoder,d,"value",p));return[h(b)+"="+m]}return[h(b)+"="+h(s(y,Pn.encoder,d,"value",p))]}return[h(n)+"="+h(String(y))]}var O,P=[];if(void 0===y)return P;if("comma"===r&&yn(y))O=[{value:y.length>0?y.join(",")||null:void 0}];else if(yn(a))O=a;else{var S=Object.keys(y);O=u?S.sort(u):S}for(var w=0;w<O.length;++w){var T=O[w],k="object"==typeof T&&void 0!==T.value?T.value:y[T];if(!o||null!==k){var N=yn(y)?"function"==typeof r?r(n,T):n:n+(c?"."+T:"["+T+"]");mn(P,e(k,N,r,i,o,s,a,u,c,l,p,h,f,d))}}return P},wn=pn,Tn=Object.prototype.hasOwnProperty,kn=Array.isArray,Nn={allowDots:!1,allowPrototypes:!1,arrayLimit:20,charset:"utf-8",charsetSentinel:!1,comma:!1,decoder:wn.decode,delimiter:"&",depth:5,ignoreQueryPrefix:!1,interpretNumericEntities:!1,parameterLimit:1e3,parseArrays:!0,plainObjects:!1,strictNullHandling:!1},Cn=function(e){return e.replace(/&#(\d+);/g,(function(e,t){return String.fromCharCode(parseInt(t,10))}))},En=function(e,t){return e&&"string"==typeof e&&t.comma&&e.indexOf(",")>-1?e.split(","):e},An=function(e,t,n,r){if(e){var i=n.allowDots?e.replace(/\.([^.[]+)/g,"[$1]"):e,o=/(\[[^[\]]*])/g,s=n.depth>0&&/(\[[^[\]]*])/.exec(i),a=s?i.slice(0,s.index):i,u=[];if(a){if(!n.plainObjects&&Tn.call(Object.prototype,a)&&!n.allowPrototypes)return;u.push(a)}for(var c=0;n.depth>0&&null!==(s=o.exec(i))&&c<n.depth;){if(c+=1,!n.plainObjects&&Tn.call(Object.prototype,s[1].slice(1,-1))&&!n.allowPrototypes)return;u.push(s[1])}return s&&u.push("["+i.slice(s.index)+"]"),function(e,t,n,r){for(var i=r?t:En(t,n),o=e.length-1;o>=0;--o){var s,a=e[o];if("[]"===a&&n.parseArrays)s=[].concat(i);else{s=n.plainObjects?Object.create(null):{};var u="["===a.charAt(0)&&"]"===a.charAt(a.length-1)?a.slice(1,-1):a,c=parseInt(u,10);n.parseArrays||""!==u?!isNaN(c)&&a!==u&&String(c)===u&&c>=0&&n.parseArrays&&c<=n.arrayLimit?(s=[])[c]=i:"__proto__"!==u&&(s[u]=i):s={0:i}}i=s}return i}(u,t,n,r)}},Mn={formats:on,parse:function(e,t){var n=function(e){if(!e)return Nn;if(null!==e.decoder&&void 0!==e.decoder&&"function"!=typeof e.decoder)throw new TypeError("Decoder has to be a function.");if(void 0!==e.charset&&"utf-8"!==e.charset&&"iso-8859-1"!==e.charset)throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");var t=void 0===e.charset?Nn.charset:e.charset;return{allowDots:void 0===e.allowDots?Nn.allowDots:!!e.allowDots,allowPrototypes:"boolean"==typeof e.allowPrototypes?e.allowPrototypes:Nn.allowPrototypes,arrayLimit:"number"==typeof e.arrayLimit?e.arrayLimit:Nn.arrayLimit,charset:t,charsetSentinel:"boolean"==typeof e.charsetSentinel?e.charsetSentinel:Nn.charsetSentinel,comma:"boolean"==typeof e.comma?e.comma:Nn.comma,decoder:"function"==typeof e.decoder?e.decoder:Nn.decoder,delimiter:"string"==typeof e.delimiter||wn.isRegExp(e.delimiter)?e.delimiter:Nn.delimiter,depth:"number"==typeof e.depth||!1===e.depth?+e.depth:Nn.depth,ignoreQueryPrefix:!0===e.ignoreQueryPrefix,interpretNumericEntities:"boolean"==typeof e.interpretNumericEntities?e.interpretNumericEntities:Nn.interpretNumericEntities,parameterLimit:"number"==typeof e.parameterLimit?e.parameterLimit:Nn.parameterLimit,parseArrays:!1!==e.parseArrays,plainObjects:"boolean"==typeof e.plainObjects?e.plainObjects:Nn.plainObjects,strictNullHandling:"boolean"==typeof e.strictNullHandling?e.strictNullHandling:Nn.strictNullHandling}}(t);if(""===e||null==e)return n.plainObjects?Object.create(null):{};for(var r="string"==typeof e?function(e,t){var n,r={},i=t.ignoreQueryPrefix?e.replace(/^\?/,""):e,o=t.parameterLimit===1/0?void 0:t.parameterLimit,s=i.split(t.delimiter,o),a=-1,u=t.charset;if(t.charsetSentinel)for(n=0;n<s.length;++n)0===s[n].indexOf("utf8=")&&("utf8=%E2%9C%93"===s[n]?u="utf-8":"utf8=%26%2310003%3B"===s[n]&&(u="iso-8859-1"),a=n,n=s.length);for(n=0;n<s.length;++n)if(n!==a){var c,l,p=s[n],h=p.indexOf("]="),f=-1===h?p.indexOf("="):h+1;-1===f?(c=t.decoder(p,Nn.decoder,u,"key"),l=t.strictNullHandling?null:""):(c=t.decoder(p.slice(0,f),Nn.decoder,u,"key"),l=wn.maybeMap(En(p.slice(f+1),t),(function(e){return t.decoder(e,Nn.decoder,u,"value")}))),l&&t.interpretNumericEntities&&"iso-8859-1"===u&&(l=Cn(l)),p.indexOf("[]=")>-1&&(l=kn(l)?[l]:l),Tn.call(r,c)?r[c]=wn.combine(r[c],l):r[c]=l}return r}(e,n):e,i=n.plainObjects?Object.create(null):{},o=Object.keys(r),s=0;s<o.length;++s){var a=o[s],u=An(a,r[a],n,"string"==typeof e);i=wn.merge(i,u,n)}return wn.compact(i)},stringify:function(e,t){var n,r=e,i=function(e){if(!e)return Pn;if(null!==e.encoder&&void 0!==e.encoder&&"function"!=typeof e.encoder)throw new TypeError("Encoder has to be a function.");var t=e.charset||Pn.charset;if(void 0!==e.charset&&"utf-8"!==e.charset&&"iso-8859-1"!==e.charset)throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");var n=fn.default;if(void 0!==e.format){if(!dn.call(fn.formatters,e.format))throw new TypeError("Unknown format option provided.");n=e.format}var r=fn.formatters[n],i=Pn.filter;return("function"==typeof e.filter||yn(e.filter))&&(i=e.filter),{addQueryPrefix:"boolean"==typeof e.addQueryPrefix?e.addQueryPrefix:Pn.addQueryPrefix,allowDots:void 0===e.allowDots?Pn.allowDots:!!e.allowDots,charset:t,charsetSentinel:"boolean"==typeof e.charsetSentinel?e.charsetSentinel:Pn.charsetSentinel,delimiter:void 0===e.delimiter?Pn.delimiter:e.delimiter,encode:"boolean"==typeof e.encode?e.encode:Pn.encode,encoder:"function"==typeof e.encoder?e.encoder:Pn.encoder,encodeValuesOnly:"boolean"==typeof e.encodeValuesOnly?e.encodeValuesOnly:Pn.encodeValuesOnly,filter:i,format:n,formatter:r,serializeDate:"function"==typeof e.serializeDate?e.serializeDate:Pn.serializeDate,skipNulls:"boolean"==typeof e.skipNulls?e.skipNulls:Pn.skipNulls,sort:"function"==typeof e.sort?e.sort:null,strictNullHandling:"boolean"==typeof e.strictNullHandling?e.strictNullHandling:Pn.strictNullHandling}}(t);"function"==typeof i.filter?r=(0,i.filter)("",r):yn(i.filter)&&(n=i.filter);var o,s=[];if("object"!=typeof r||null===r)return"";o=t&&t.arrayFormat in gn?t.arrayFormat:t&&"indices"in t?t.indices?"indices":"repeat":"indices";var a=gn[o];n||(n=Object.keys(r)),i.sort&&n.sort(i.sort);for(var u=0;u<n.length;++u){var c=n[u];i.skipNulls&&null===r[c]||mn(s,Sn(r[c],c,a,i.strictNullHandling,i.skipNulls,i.encode?i.encoder:null,i.filter,i.sort,i.allowDots,i.serializeDate,i.format,i.formatter,i.encodeValuesOnly,i.charset))}var l=s.join(i.delimiter),p=!0===i.addQueryPrefix?"?":"";return i.charsetSentinel&&("iso-8859-1"===i.charset?p+="utf8=%26%2310003%3B&":p+="utf8=%E2%9C%93&"),l.length>0?p+l:""}};function Rn(e){return Rn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Rn(e)}var jn=function(e){return null!==e&&"object"===Rn(e)};function Un(e){return Un="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Un(e)}var xn=jn,Dn=In;function In(e){if(e)return function(e){for(var t in In.prototype)Object.prototype.hasOwnProperty.call(In.prototype,t)&&(e[t]=In.prototype[t]);return e}(e)}In.prototype.clearTimeout=function(){return clearTimeout(this._timer),clearTimeout(this._responseTimeoutTimer),clearTimeout(this._uploadTimeoutTimer),delete this._timer,delete this._responseTimeoutTimer,delete this._uploadTimeoutTimer,this},In.prototype.parse=function(e){return this._parser=e,this},In.prototype.responseType=function(e){return this._responseType=e,this},In.prototype.serialize=function(e){return this._serializer=e,this},In.prototype.timeout=function(e){if(!e||"object"!==Un(e))return this._timeout=e,this._responseTimeout=0,this._uploadTimeout=0,this;for(var t in e)if(Object.prototype.hasOwnProperty.call(e,t))switch(t){case"deadline":this._timeout=e.deadline;break;case"response":this._responseTimeout=e.response;break;case"upload":this._uploadTimeout=e.upload;break;default:console.warn("Unknown timeout option",t)}return this},In.prototype.retry=function(e,t){return 0!==arguments.length&&!0!==e||(e=1),e<=0&&(e=0),this._maxRetries=e,this._retries=0,this._retryCallback=t,this};var Gn=new Set(["ETIMEDOUT","ECONNRESET","EADDRINUSE","ECONNREFUSED","EPIPE","ENOTFOUND","ENETUNREACH","EAI_AGAIN"]),Kn=new Set([408,413,429,500,502,503,504,521,522,524]);In.prototype._shouldRetry=function(e,t){if(!this._maxRetries||this._retries++>=this._maxRetries)return!1;if(this._retryCallback)try{var n=this._retryCallback(e,t);if(!0===n)return!0;if(!1===n)return!1}catch(e){console.error(e)}if(t&&t.status&&Kn.has(t.status))return!0;if(e){if(e.code&&Gn.has(e.code))return!0;if(e.timeout&&"ECONNABORTED"===e.code)return!0;if(e.crossDomain)return!0}return!1},In.prototype._retry=function(){return this.clearTimeout(),this.req&&(this.req=null,this.req=this.request()),this._aborted=!1,this.timedout=!1,this.timedoutError=null,this._end()},In.prototype.then=function(e,t){var n=this;if(!this._fullfilledPromise){var r=this;this._endCalled&&console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises"),this._fullfilledPromise=new Promise((function(e,t){r.on("abort",(function(){if(!(n._maxRetries&&n._maxRetries>n._retries))if(n.timedout&&n.timedoutError)t(n.timedoutError);else{var e=new Error("Aborted");e.code="ABORTED",e.status=n.status,e.method=n.method,e.url=n.url,t(e)}})),r.end((function(n,r){n?t(n):e(r)}))}))}return this._fullfilledPromise.then(e,t)},In.prototype.catch=function(e){return this.then(void 0,e)},In.prototype.use=function(e){return e(this),this},In.prototype.ok=function(e){if("function"!=typeof e)throw new Error("Callback required");return this._okCallback=e,this},In.prototype._isResponseOK=function(e){return!!e&&(this._okCallback?this._okCallback(e):e.status>=200&&e.status<300)},In.prototype.get=function(e){return this._header[e.toLowerCase()]},In.prototype.getHeader=In.prototype.get,In.prototype.set=function(e,t){if(xn(e)){for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&this.set(n,e[n]);return this}return this._header[e.toLowerCase()]=t,this.header[e]=t,this},In.prototype.unset=function(e){return delete this._header[e.toLowerCase()],delete this.header[e],this},In.prototype.field=function(e,t){if(null==e)throw new Error(".field(name, val) name can not be empty");if(this._data)throw new Error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");if(xn(e)){for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&this.field(n,e[n]);return this}if(Array.isArray(t)){for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&this.field(e,t[r]);return this}if(null==t)throw new Error(".field(name, val) val can not be empty");return"boolean"==typeof t&&(t=String(t)),this._getFormData().append(e,t),this},In.prototype.abort=function(){return this._aborted||(this._aborted=!0,this.xhr&&this.xhr.abort(),this.req&&this.req.abort(),this.clearTimeout(),this.emit("abort")),this},In.prototype._auth=function(e,t,n,r){switch(n.type){case"basic":this.set("Authorization","Basic ".concat(r("".concat(e,":").concat(t))));break;case"auto":this.username=e,this.password=t;break;case"bearer":this.set("Authorization","Bearer ".concat(e))}return this},In.prototype.withCredentials=function(e){return void 0===e&&(e=!0),this._withCredentials=e,this},In.prototype.redirects=function(e){return this._maxRedirects=e,this},In.prototype.maxResponseSize=function(e){if("number"!=typeof e)throw new TypeError("Invalid argument");return this._maxResponseSize=e,this},In.prototype.toJSON=function(){return{method:this.method,url:this.url,data:this._data,headers:this._header}},In.prototype.send=function(e){var t=xn(e),n=this._header["content-type"];if(this._formData)throw new Error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");if(t&&!this._data)Array.isArray(e)?this._data=[]:this._isHost(e)||(this._data={});else if(e&&this._data&&this._isHost(this._data))throw new Error("Can't merge these send calls");if(t&&xn(this._data))for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(this._data[r]=e[r]);else"string"==typeof e?(n||this.type("form"),(n=this._header["content-type"])&&(n=n.toLowerCase().trim()),this._data="application/x-www-form-urlencoded"===n?this._data?"".concat(this._data,"&").concat(e):e:(this._data||"")+e):this._data=e;return!t||this._isHost(e)||n||this.type("json"),this},In.prototype.sortQuery=function(e){return this._sort=void 0===e||e,this},In.prototype._finalizeQueryString=function(){var e=this._query.join("&");if(e&&(this.url+=(this.url.includes("?")?"&":"?")+e),this._query.length=0,this._sort){var t=this.url.indexOf("?");if(t>=0){var n=this.url.slice(t+1).split("&");"function"==typeof this._sort?n.sort(this._sort):n.sort(),this.url=this.url.slice(0,t)+"?"+n.join("&")}}},In.prototype._appendQueryString=function(){console.warn("Unsupported")},In.prototype._timeoutError=function(e,t,n){if(!this._aborted){var r=new Error("".concat(e+t,"ms exceeded"));r.timeout=t,r.code="ECONNABORTED",r.errno=n,this.timedout=!0,this.timedoutError=r,this.abort(),this.callback(r)}},In.prototype._setTimeouts=function(){var e=this;this._timeout&&!this._timer&&(this._timer=setTimeout((function(){e._timeoutError("Timeout of ",e._timeout,"ETIME")}),this._timeout)),this._responseTimeout&&!this._responseTimeoutTimer&&(this._responseTimeoutTimer=setTimeout((function(){e._timeoutError("Response timeout of ",e._responseTimeout,"ETIMEDOUT")}),this._responseTimeout))};var Fn={};function Ln(e,t){var n;if("undefined"==typeof Symbol||null==e[Symbol.iterator]){if(Array.isArray(e)||(n=function(e,t){if(!e)return;if("string"==typeof e)return Bn(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return Bn(e,t)}(e))||t&&e&&"number"==typeof e.length){n&&(e=n);var r=0,i=function(){};return{s:i,n:function(){return r>=e.length?{done:!0}:{done:!1,value:e[r++]}},e:function(e){throw e},f:i}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,s=!0,a=!1;return{s:function(){n=e[Symbol.iterator]()},n:function(){var e=n.next();return s=e.done,e},e:function(e){a=!0,o=e},f:function(){try{s||null==n.return||n.return()}finally{if(a)throw o}}}}function Bn(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}Fn.type=function(e){return e.split(/ *; */).shift()},Fn.params=function(e){var t,n={},r=Ln(e.split(/ *; */));try{for(r.s();!(t=r.n()).done;){var i=t.value.split(/ *= */),o=i.shift(),s=i.shift();o&&s&&(n[o]=s)}}catch(e){r.e(e)}finally{r.f()}return n},Fn.parseLinks=function(e){var t,n={},r=Ln(e.split(/ *, */));try{for(r.s();!(t=r.n()).done;){var i=t.value.split(/ *; */),o=i[0].slice(1,-1);n[i[1].split(/ *= */)[1].slice(1,-1)]=o}}catch(e){r.e(e)}finally{r.f()}return n},Fn.cleanHeader=function(e,t){return delete e["content-type"],delete e["content-length"],delete e["transfer-encoding"],delete e.host,t&&(delete e.authorization,delete e.cookie),e};var Hn=Fn,qn=zn;function zn(e){if(e)return function(e){for(var t in zn.prototype)Object.prototype.hasOwnProperty.call(zn.prototype,t)&&(e[t]=zn.prototype[t]);return e}(e)}function Vn(e){return function(e){if(Array.isArray(e))return Jn(e)}(e)||function(e){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(e))return Array.from(e)}(e)||function(e,t){if(!e)return;if("string"==typeof e)return Jn(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return Jn(e,t)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Jn(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function Wn(){this._defaults=[]}zn.prototype.get=function(e){return this.header[e.toLowerCase()]},zn.prototype._setHeaderProperties=function(e){var t=e["content-type"]||"";this.type=Hn.type(t);var n=Hn.params(t);for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(this[r]=n[r]);this.links={};try{e.link&&(this.links=Hn.parseLinks(e.link))}catch(e){}},zn.prototype._setStatusProperties=function(e){var t=e/100|0;this.statusCode=e,this.status=this.statusCode,this.statusType=t,this.info=1===t,this.ok=2===t,this.redirect=3===t,this.clientError=4===t,this.serverError=5===t,this.error=(4===t||5===t)&&this.toError(),this.created=201===e,this.accepted=202===e,this.noContent=204===e,this.badRequest=400===e,this.unauthorized=401===e,this.notAcceptable=406===e,this.forbidden=403===e,this.notFound=404===e,this.unprocessableEntity=422===e},["use","on","once","set","query","type","accept","auth","withCredentials","sortQuery","retry","ok","redirects","timeout","buffer","serialize","parse","ca","key","pfx","cert","disableTLSCerts"].forEach((function(e){Wn.prototype[e]=function(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return this._defaults.push({fn:e,args:n}),this}})),Wn.prototype._setDefaults=function(e){this._defaults.forEach((function(t){e[t.fn].apply(e,Vn(t.args))}))};var Xn=Wn;!function(e,t){function n(e){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n(e)}var r;"undefined"!=typeof window?r=window:"undefined"==typeof self?(console.warn("Using browser-only version of superagent in non-browser environment"),r=void 0):r=self;var i=Lt.exports,o=Bt,s=Mn,a=Dn,u=jn,c=qn,l=Xn;function p(){}e.exports=function(e,n){return"function"==typeof n?new t.Request("GET",e).end(n):1===arguments.length?new t.Request("GET",e):new t.Request(e,n)};var h=t=e.exports;t.Request=m,h.getXHR=function(){if(r.XMLHttpRequest&&(!r.location||"file:"!==r.location.protocol||!r.ActiveXObject))return new XMLHttpRequest;try{return new ActiveXObject("Microsoft.XMLHTTP")}catch(e){}try{return new ActiveXObject("Msxml2.XMLHTTP.6.0")}catch(e){}try{return new ActiveXObject("Msxml2.XMLHTTP.3.0")}catch(e){}try{return new ActiveXObject("Msxml2.XMLHTTP")}catch(e){}throw new Error("Browser-only version of superagent could not find XHR")};var f="".trim?function(e){return e.trim()}:function(e){return e.replace(/(^\s*|\s*$)/g,"")};function d(e){if(!u(e))return e;var t=[];for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&g(t,n,e[n]);return t.join("&")}function g(e,t,n){if(void 0!==n)if(null!==n)if(Array.isArray(n))n.forEach((function(n){g(e,t,n)}));else if(u(n))for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&g(e,"".concat(t,"[").concat(r,"]"),n[r]);else e.push(encodeURI(t)+"="+encodeURIComponent(n));else e.push(encodeURI(t))}function y(e){for(var t,n,r={},i=e.split("&"),o=0,s=i.length;o<s;++o)-1===(n=(t=i[o]).indexOf("="))?r[decodeURIComponent(t)]="":r[decodeURIComponent(t.slice(0,n))]=decodeURIComponent(t.slice(n+1));return r}function b(e){return/[/+]json($|[^-\w])/i.test(e)}function v(e){this.req=e,this.xhr=this.req.xhr,this.text="HEAD"!==this.req.method&&(""===this.xhr.responseType||"text"===this.xhr.responseType)||void 0===this.xhr.responseType?this.xhr.responseText:null,this.statusText=this.req.xhr.statusText;var t=this.xhr.status;1223===t&&(t=204),this._setStatusProperties(t),this.headers=function(e){for(var t,n,r,i,o=e.split(/\r?\n/),s={},a=0,u=o.length;a<u;++a)-1!==(t=(n=o[a]).indexOf(":"))&&(r=n.slice(0,t).toLowerCase(),i=f(n.slice(t+1)),s[r]=i);return s}(this.xhr.getAllResponseHeaders()),this.header=this.headers,this.header["content-type"]=this.xhr.getResponseHeader("content-type"),this._setHeaderProperties(this.header),null===this.text&&e._responseType?this.body=this.xhr.response:this.body="HEAD"===this.req.method?null:this._parseBody(this.text?this.text:this.xhr.response)}function m(e,t){var n=this;this._query=this._query||[],this.method=e,this.url=t,this.header={},this._header={},this.on("end",(function(){var e,t=null,r=null;try{r=new v(n)}catch(e){return(t=new Error("Parser is unable to parse the response")).parse=!0,t.original=e,n.xhr?(t.rawResponse=void 0===n.xhr.responseType?n.xhr.responseText:n.xhr.response,t.status=n.xhr.status?n.xhr.status:null,t.statusCode=t.status):(t.rawResponse=null,t.status=null),n.callback(t)}n.emit("response",r);try{n._isResponseOK(r)||(e=new Error(r.statusText||r.text||"Unsuccessful HTTP response"))}catch(t){e=t}e?(e.original=t,e.response=r,e.status=r.status,n.callback(e,r)):n.callback(null,r)}))}function _(e,t,n){var r=h("DELETE",e);return"function"==typeof t&&(n=t,t=null),t&&r.send(t),n&&r.end(n),r}h.serializeObject=d,h.parseString=y,h.types={html:"text/html",json:"application/json",xml:"text/xml",urlencoded:"application/x-www-form-urlencoded",form:"application/x-www-form-urlencoded","form-data":"application/x-www-form-urlencoded"},h.serialize={"application/x-www-form-urlencoded":s.stringify,"application/json":o},h.parse={"application/x-www-form-urlencoded":y,"application/json":JSON.parse},c(v.prototype),v.prototype._parseBody=function(e){var t=h.parse[this.type];return this.req._parser?this.req._parser(this,e):(!t&&b(this.type)&&(t=h.parse["application/json"]),t&&e&&(e.length>0||e instanceof Object)?t(e):null)},v.prototype.toError=function(){var e=this.req,t=e.method,n=e.url,r="cannot ".concat(t," ").concat(n," (").concat(this.status,")"),i=new Error(r);return i.status=this.status,i.method=t,i.url=n,i},h.Response=v,i(m.prototype),a(m.prototype),m.prototype.type=function(e){return this.set("Content-Type",h.types[e]||e),this},m.prototype.accept=function(e){return this.set("Accept",h.types[e]||e),this},m.prototype.auth=function(e,t,r){1===arguments.length&&(t=""),"object"===n(t)&&null!==t&&(r=t,t=""),r||(r={type:"function"==typeof btoa?"basic":"auto"});var i=function(e){if("function"==typeof btoa)return btoa(e);throw new Error("Cannot use basic auth, btoa is not a function")};return this._auth(e,t,r,i)},m.prototype.query=function(e){return"string"!=typeof e&&(e=d(e)),e&&this._query.push(e),this},m.prototype.attach=function(e,t,n){if(t){if(this._data)throw new Error("superagent can't mix .send() and .attach()");this._getFormData().append(e,t,n||t.name)}return this},m.prototype._getFormData=function(){return this._formData||(this._formData=new r.FormData),this._formData},m.prototype.callback=function(e,t){if(this._shouldRetry(e,t))return this._retry();var n=this._callback;this.clearTimeout(),e&&(this._maxRetries&&(e.retries=this._retries-1),this.emit("error",e)),n(e,t)},m.prototype.crossDomainError=function(){var e=new Error("Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.");e.crossDomain=!0,e.status=this.status,e.method=this.method,e.url=this.url,this.callback(e)},m.prototype.agent=function(){return console.warn("This is not supported in browser version of superagent"),this},m.prototype.ca=m.prototype.agent,m.prototype.buffer=m.prototype.ca,m.prototype.write=function(){throw new Error("Streaming is not supported in browser version of superagent")},m.prototype.pipe=m.prototype.write,m.prototype._isHost=function(e){return e&&"object"===n(e)&&!Array.isArray(e)&&"[object Object]"!==Object.prototype.toString.call(e)},m.prototype.end=function(e){this._endCalled&&console.warn("Warning: .end() was called twice. This is not supported in superagent"),this._endCalled=!0,this._callback=e||p,this._finalizeQueryString(),this._end()},m.prototype._setUploadTimeout=function(){var e=this;this._uploadTimeout&&!this._uploadTimeoutTimer&&(this._uploadTimeoutTimer=setTimeout((function(){e._timeoutError("Upload timeout of ",e._uploadTimeout,"ETIMEDOUT")}),this._uploadTimeout))},m.prototype._end=function(){if(this._aborted)return this.callback(new Error("The request has been aborted even before .end() was called"));var e=this;this.xhr=h.getXHR();var t=this.xhr,n=this._formData||this._data;this._setTimeouts(),t.onreadystatechange=function(){var n=t.readyState;if(n>=2&&e._responseTimeoutTimer&&clearTimeout(e._responseTimeoutTimer),4===n){var r;try{r=t.status}catch(e){r=0}if(!r){if(e.timedout||e._aborted)return;return e.crossDomainError()}e.emit("end")}};var r=function(t,n){n.total>0&&(n.percent=n.loaded/n.total*100,100===n.percent&&clearTimeout(e._uploadTimeoutTimer)),n.direction=t,e.emit("progress",n)};if(this.hasListeners("progress"))try{t.addEventListener("progress",r.bind(null,"download")),t.upload&&t.upload.addEventListener("progress",r.bind(null,"upload"))}catch(e){}t.upload&&this._setUploadTimeout();try{this.username&&this.password?t.open(this.method,this.url,!0,this.username,this.password):t.open(this.method,this.url,!0)}catch(e){return this.callback(e)}if(this._withCredentials&&(t.withCredentials=!0),!this._formData&&"GET"!==this.method&&"HEAD"!==this.method&&"string"!=typeof n&&!this._isHost(n)){var i=this._header["content-type"],o=this._serializer||h.serialize[i?i.split(";")[0]:""];!o&&b(i)&&(o=h.serialize["application/json"]),o&&(n=o(n))}for(var s in this.header)null!==this.header[s]&&Object.prototype.hasOwnProperty.call(this.header,s)&&t.setRequestHeader(s,this.header[s]);this._responseType&&(t.responseType=this._responseType),this.emit("request",this),t.send(void 0===n?null:n)},h.agent=function(){return new l},["GET","POST","OPTIONS","PATCH","PUT","DELETE"].forEach((function(e){l.prototype[e.toLowerCase()]=function(t,n){var r=new h.Request(e,t);return this._setDefaults(r),n&&r.end(n),r}})),l.prototype.del=l.prototype.delete,h.get=function(e,t,n){var r=h("GET",e);return"function"==typeof t&&(n=t,t=null),t&&r.query(t),n&&r.end(n),r},h.head=function(e,t,n){var r=h("HEAD",e);return"function"==typeof t&&(n=t,t=null),t&&r.query(t),n&&r.end(n),r},h.options=function(e,t,n){var r=h("OPTIONS",e);return"function"==typeof t&&(n=t,t=null),t&&r.send(t),n&&r.end(n),r},h.del=_,h.delete=_,h.patch=function(e,t,n){var r=h("PATCH",e);return"function"==typeof t&&(n=t,t=null),t&&r.send(t),n&&r.end(n),r},h.post=function(e,t,n){var r=h("POST",e);return"function"==typeof t&&(n=t,t=null),t&&r.send(t),n&&r.end(n),r},h.put=function(e,t,n){var r=h("PUT",e);return"function"==typeof t&&(n=t,t=null),t&&r.send(t),n&&r.end(n),r}}(Ft,Ft.exports);var $n=Ft.exports;function Qn(e){var t=(new Date).getTime(),n=(new Date).toISOString(),r=console&&console.log?console:window&&window.console&&window.console.log?window.console:console;r.log("<<<<<"),r.log("[".concat(n,"]"),"\n",e.url,"\n",e.qs),r.log("-----"),e.on("response",(function(n){var i=(new Date).getTime()-t,o=(new Date).toISOString();r.log(">>>>>>"),r.log("[".concat(o," / ").concat(i,"]"),"\n",e.url,"\n",e.qs,"\n",n.text),r.log("-----")}))}function Yn(e,t,n){var r=this;this._config.logVerbosity&&(e=e.use(Qn)),this._config.proxy&&this._modules.proxy&&(e=this._modules.proxy.call(this,e)),this._config.keepAlive&&this._modules.keepAlive&&(e=this._modules.keepAlive(e));var i=e;if(t.abortSignal)var o=t.abortSignal.subscribe((function(){i.abort(),o()}));return!0===t.forceBuffered?i="undefined"==typeof Blob?i.buffer().responseType("arraybuffer"):i.responseType("arraybuffer"):!1===t.forceBuffered&&(i=i.buffer(!1)),(i=i.timeout(t.timeout)).on("abort",(function(){return n({category:E.PNUnknownCategory,error:!0,operation:t.operation,errorData:new Error("Aborted")},null)})),i.end((function(e,i){var o,s={};if(s.error=null!==e,s.operation=t.operation,i&&i.status&&(s.statusCode=i.status),e){if(e.response&&e.response.text&&!r._config.logVerbosity)try{s.errorData=JSON.parse(e.response.text)}catch(t){s.errorData=e}else s.errorData=e;return s.category=r._detectErrorCategory(e),n(s,null)}if(t.ignoreBody)o={headers:i.headers,redirects:i.redirects,response:i};else try{o=JSON.parse(i.text)}catch(e){return s.errorData=i,s.error=!0,n(s,null)}return o.error&&1===o.error&&o.status&&o.message&&o.service?(s.errorData=o,s.statusCode=o.status,s.error=!0,s.category=r._detectErrorCategory(s),n(s,null)):(o.error&&o.error.message&&(s.errorData=o.error),n(s,o))})),i}function Zn(e,t,n){return r(this,void 0,void 0,(function(){var r;return i(this,(function(i){switch(i.label){case 0:return r=$n.post(e),t.forEach((function(e){var t=e.key,n=e.value;r=r.field(t,n)})),r.attach("file",n,{contentType:"application/octet-stream"}),[4,r];case 1:return[2,i.sent()]}}))}))}function er(e,t,n){var r=$n.get(this.getStandardOrigin()+t.url).set(t.headers).query(e);return Yn.call(this,r,t,n)}function tr(e,t,n){var r=$n.get(this.getStandardOrigin()+t.url).set(t.headers).query(e);return Yn.call(this,r,t,n)}function nr(e,t,n,r){var i=$n.post(this.getStandardOrigin()+n.url).query(e).set(n.headers).send(t);return Yn.call(this,i,n,r)}function rr(e,t,n,r){var i=$n.patch(this.getStandardOrigin()+n.url).query(e).set(n.headers).send(t);return Yn.call(this,i,n,r)}function ir(e,t,n){var r=$n.delete(this.getStandardOrigin()+t.url).set(t.headers).query(e);return Yn.call(this,r,t,n)}function or(e,t){var n=new Uint8Array(e.byteLength+t.byteLength);return n.set(new Uint8Array(e),0),n.set(new Uint8Array(t),e.byteLength),n.buffer}var sr,ar=function(){function e(){}return Object.defineProperty(e.prototype,"algo",{get:function(){return"aes-256-cbc"},enumerable:!1,configurable:!0}),e.prototype.encrypt=function(e,t){return r(this,void 0,void 0,(function(){var n;return i(this,(function(r){switch(r.label){case 0:return[4,this.getKey(e)];case 1:if(n=r.sent(),t instanceof ArrayBuffer)return[2,this.encryptArrayBuffer(n,t)];if("string"==typeof t)return[2,this.encryptString(n,t)];throw new Error("Cannot encrypt this file. In browsers file encryption supports only string or ArrayBuffer")}}))}))},e.prototype.decrypt=function(e,t){return r(this,void 0,void 0,(function(){var n;return i(this,(function(r){switch(r.label){case 0:return[4,this.getKey(e)];case 1:if(n=r.sent(),t instanceof ArrayBuffer)return[2,this.decryptArrayBuffer(n,t)];if("string"==typeof t)return[2,this.decryptString(n,t)];throw new Error("Cannot decrypt this file. In browsers file decryption supports only string or ArrayBuffer")}}))}))},e.prototype.encryptFile=function(e,t,n){return r(this,void 0,void 0,(function(){var r,o,s;return i(this,(function(i){switch(i.label){case 0:return[4,this.getKey(e)];case 1:return r=i.sent(),[4,t.toArrayBuffer()];case 2:return o=i.sent(),[4,this.encryptArrayBuffer(r,o)];case 3:return s=i.sent(),[2,n.create({name:t.name,mimeType:"application/octet-stream",data:s})]}}))}))},e.prototype.decryptFile=function(e,t,n){return r(this,void 0,void 0,(function(){var r,o,s;return i(this,(function(i){switch(i.label){case 0:return[4,this.getKey(e)];case 1:return r=i.sent(),[4,t.toArrayBuffer()];case 2:return o=i.sent(),[4,this.decryptArrayBuffer(r,o)];case 3:return s=i.sent(),[2,n.create({name:t.name,data:s})]}}))}))},e.prototype.getKey=function(e){return r(this,void 0,void 0,(function(){var t,n,r;return i(this,(function(i){switch(i.label){case 0:return t=Buffer.from(e),[4,crypto.subtle.digest("SHA-256",t.buffer)];case 1:return n=i.sent(),r=Buffer.from(Buffer.from(n).toString("hex").slice(0,32),"utf8").buffer,[2,crypto.subtle.importKey("raw",r,"AES-CBC",!0,["encrypt","decrypt"])]}}))}))},e.prototype.encryptArrayBuffer=function(e,t){return r(this,void 0,void 0,(function(){var n,r,o;return i(this,(function(i){switch(i.label){case 0:return n=crypto.getRandomValues(new Uint8Array(16)),r=or,o=[n.buffer],[4,crypto.subtle.encrypt({name:"AES-CBC",iv:n},e,t)];case 1:return[2,r.apply(void 0,o.concat([i.sent()]))]}}))}))},e.prototype.decryptArrayBuffer=function(e,t){return r(this,void 0,void 0,(function(){var n;return i(this,(function(r){return n=t.slice(0,16),[2,crypto.subtle.decrypt({name:"AES-CBC",iv:n},e,t.slice(16))]}))}))},e.prototype.encryptString=function(e,t){return r(this,void 0,void 0,(function(){var n,r,o,s;return i(this,(function(i){switch(i.label){case 0:return n=crypto.getRandomValues(new Uint8Array(16)),r=Buffer.from(t).buffer,[4,crypto.subtle.encrypt({name:"AES-CBC",iv:n},e,r)];case 1:return o=i.sent(),s=or(n.buffer,o),[2,Buffer.from(s).toString("utf8")]}}))}))},e.prototype.decryptString=function(e,t){return r(this,void 0,void 0,(function(){var n,r,o,s;return i(this,(function(i){switch(i.label){case 0:return n=Buffer.from(t),r=n.slice(0,16),o=n.slice(16),[4,crypto.subtle.decrypt({name:"AES-CBC",iv:r},e,o)];case 1:return s=i.sent(),[2,Buffer.from(s).toString("utf8")]}}))}))},e.IV_LENGTH=16,e}(),ur=(sr=function(){function e(e){if(e instanceof File)this.data=e,this.name=this.data.name,this.mimeType=this.data.type;else if(e.data){var t=e.data;this.data=new File([t],e.name,{type:e.mimeType}),this.name=e.name,e.mimeType&&(this.mimeType=e.mimeType)}if(void 0===this.data)throw new Error("Couldn't construct a file out of supplied options.");if(void 0===this.name)throw new Error("Couldn't guess filename out of the options. Please provide one.")}return e.create=function(e){return new this(e)},e.prototype.toBuffer=function(){return r(this,void 0,void 0,(function(){return i(this,(function(e){throw new Error("This feature is only supported in Node.js environments.")}))}))},e.prototype.toStream=function(){return r(this,void 0,void 0,(function(){return i(this,(function(e){throw new Error("This feature is only supported in Node.js environments.")}))}))},e.prototype.toFileUri=function(){return r(this,void 0,void 0,(function(){return i(this,(function(e){throw new Error("This feature is only supported in react native environments.")}))}))},e.prototype.toBlob=function(){return r(this,void 0,void 0,(function(){return i(this,(function(e){return[2,this.data]}))}))},e.prototype.toArrayBuffer=function(){return r(this,void 0,void 0,(function(){var e=this;return i(this,(function(t){return[2,new Promise((function(t,n){var r=new FileReader;r.addEventListener("load",(function(){if(r.result instanceof ArrayBuffer)return t(r.result)})),r.addEventListener("error",(function(){n(r.error)})),r.readAsArrayBuffer(e.data)}))]}))}))},e.prototype.toString=function(){return r(this,void 0,void 0,(function(){var e=this;return i(this,(function(t){return[2,new Promise((function(t,n){var r=new FileReader;r.addEventListener("load",(function(){if("string"==typeof r.result)return t(r.result)})),r.addEventListener("error",(function(){n(r.error)})),r.readAsBinaryString(e.data)}))]}))}))},e.prototype.toFile=function(){return r(this,void 0,void 0,(function(){return i(this,(function(e){return[2,this.data]}))}))},e}(),sr.supportsFile="undefined"!=typeof File,sr.supportsBlob="undefined"!=typeof Blob,sr.supportsArrayBuffer="undefined"!=typeof ArrayBuffer,sr.supportsBuffer=!1,sr.supportsStream=!1,sr.supportsString=!0,sr.supportsEncryptFile=!0,sr.supportsFileUri=!1,sr);function cr(e){if(!navigator||!navigator.sendBeacon)return!1;navigator.sendBeacon(e)}function lr(e){for(var t=O.enc.Base64.parse(e).words,n=new ArrayBuffer(4*t.length),r=new Uint8Array(n),i=0,o=0,s=0;s<t.length;s+=1){var a=t[s];r[o=4*s]=(4278190080&a)>>24,r[o+1]=(16711680&a)>>16,r[o+2]=(65280&a)>>8,r[o+3]=255&a}for(var u=o+3;u>=o;u-=1)0===r[u]&&i<3&&(i+=1);return i>0?r.buffer.slice(0,r.byteLength-i):r.buffer}function pr(e){var t=function(e){return e&&"object"==typeof e&&e.constructor===Object};if(!t(e))return e;var n={};return Object.keys(e).forEach((function(r){var i=function(e){return"string"==typeof e||e instanceof String}(r),o=r,s=e[r];Array.isArray(r)||i&&r.indexOf(",")>=0?o=(i?r.split(","):r).reduce((function(e,t){return e+=String.fromCharCode(t)}),""):(function(e){return"number"==typeof e&&isFinite(e)}(r)||i&&!isNaN(r))&&(o=String.fromCharCode(i?parseInt(r,10):10));n[o]=t(s)?pr(s):s})),n}var hr=function(e){function n(t){var n=this,r=t.listenToBrowserNetworkEvents,i=void 0===r||r;return t.sdkFamily="Web",t.networking=new Gt({del:ir,get:tr,post:nr,patch:rr,sendBeacon:cr,getfile:er,postfile:Zn}),t.cbor=new Kt((function(e){return pr(l.decode(e))}),lr),t.PubNubFile=ur,t.cryptography=new ar,n=e.call(this,t)||this,i&&(window.addEventListener("offline",(function(){n.networkDownDetected()})),window.addEventListener("online",(function(){n.networkUpDetected()}))),n}return t(n,e),n}(It);return hr}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"buffer":44}],89:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],90:[function(require,module,exports){
(function (process){
// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    "use strict";

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (typeof exports === "object" && typeof module === "object") {
        module.exports = definition();

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define(definition);

    // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

    // <script>
    } else if (typeof window !== "undefined" || typeof self !== "undefined") {
        // Prefer window over self for add-on scripts. Use self for
        // non-windowed contexts.
        var global = typeof window !== "undefined" ? window : self;

        // Get the `window` object, save the previous Q global
        // and initialize Q as a global.
        var previousQ = global.Q;
        global.Q = definition();

        // Add a noConflict function so Q can be removed from the
        // global namespace.
        global.Q.noConflict = function () {
            global.Q = previousQ;
            return this;
        };

    } else {
        throw new Error("This environment was not anticipated by Q. Please file a bug.");
    }

})(function () {
"use strict";

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;
    // queue for late tasks, used by unhandled rejection tracking
    var laterQueue = [];

    function flush() {
        /* jshint loopfunc: true */
        var task, domain;

        while (head.next) {
            head = head.next;
            task = head.task;
            head.task = void 0;
            domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }
            runSingle(task, domain);

        }
        while (laterQueue.length) {
            task = laterQueue.pop();
            runSingle(task);
        }
        flushing = false;
    }
    // runs a single function in the async queue
    function runSingle(task, domain) {
        try {
            task();

        } catch (e) {
            if (isNodeJS) {
                // In node, uncaught exceptions are considered fatal errors.
                // Re-throw them synchronously to interrupt flushing!

                // Ensure continuation if the uncaught exception is suppressed
                // listening "uncaughtException" events (as domains does).
                // Continue in next event to avoid tick recursion.
                if (domain) {
                    domain.exit();
                }
                setTimeout(flush, 0);
                if (domain) {
                    domain.enter();
                }

                throw e;

            } else {
                // In browsers, uncaught exceptions are not fatal.
                // Re-throw them asynchronously to avoid slow-downs.
                setTimeout(function () {
                    throw e;
                }, 0);
            }
        }

        if (domain) {
            domain.exit();
        }
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process === "object" &&
        process.toString() === "[object process]" && process.nextTick) {
        // Ensure Q is in a real Node environment, with a `process.nextTick`.
        // To see through fake Node environments:
        // * Mocha test runner - exposes a `process` global without a `nextTick`
        // * Browserify - exposes a `process.nexTick` function that uses
        //   `setTimeout`. In this case `setImmediate` is preferred because
        //    it is faster. Browserify's `process.toString()` yields
        //   "[object Object]", while in a real Node environment
        //   `process.nextTick()` yields "[object process]".
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            setTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }
    // runs a task after all other tasks have been run
    // this is useful for unhandled rejection tracking that needs to happen
    // after all `then`d tasks have been run.
    nextTick.runAfter = function (task) {
        laterQueue.push(task);
        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };
    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you don’t need a security guarantee,
// this is just plain paranoid.
// However, this **might** have the nice side-effect of reducing the size of
// the minified code by reducing x.call() to merely x()
// See Mark Miller’s explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack &&
        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack) {
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        error.stack = filterStackString(concatedStacks);
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (value instanceof Promise) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

// enable long stacks if Q_DEBUG is set
if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
    Q.longStackSupport = true;
}

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            Q.nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    };

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;
        promise.source = newPromise;

        array_reduce(messages, function (undefined, message) {
            Q.nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            Q.nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.Promise = promise; // ES6
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

promise.race = race; // ES6
promise.all = all; // ES6
promise.reject = reject; // ES6
promise.resolve = Q; // ES6

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become settled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be settled
 */
Q.race = race;
function race(answerPs) {
    return promise(function (resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function (answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        };
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    Q.nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

Q.tap = function (promise, callback) {
    return Q(promise).tap(callback);
};

/**
 * Works almost like "finally", but not called for rejections.
 * Original resolution value is passed through callback unaffected.
 * Callback may return a promise that will be awaited for.
 * @param {Function} callback
 * @returns {Q.Promise}
 * @example
 * doSomething()
 *   .then(...)
 *   .tap(console.log)
 *   .then(...);
 */
Promise.prototype.tap = function (callback) {
    callback = Q(callback);

    return this.then(function (value) {
        return callback.fcall(value).thenResolve(value);
    });
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If it’s a fulfilled promise, the fulfillment value is nearer.
 * If it’s a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return object instanceof Promise;
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var reportedUnhandledRejections = [];
var trackUnhandledRejections = true;

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }
    if (typeof process === "object" && typeof process.emit === "function") {
        Q.nextTick.runAfter(function () {
            if (array_indexOf(unhandledRejections, promise) !== -1) {
                process.emit("unhandledRejection", reason, promise);
                reportedUnhandledRejections.push(promise);
            }
        });
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        if (typeof process === "object" && typeof process.emit === "function") {
            Q.nextTick.runAfter(function () {
                var atReport = array_indexOf(reportedUnhandledRejections, promise);
                if (atReport !== -1) {
                    process.emit("rejectionHandled", unhandledReasons[at], promise);
                    reportedUnhandledRejections.splice(atReport, 1);
                }
            });
        }
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    Q.nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;

            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
            // engine that has a deployed base of browsers that support generators.
            // However, SM's generators use the Python-inspired semantics of
            // outdated ES6 drafts.  We would like to support ES6, but we'd also
            // like to make it possible to use generators in deployed browsers, so
            // we also support Python-style generators.  At some point we can remove
            // this block.

            if (typeof StopIteration === "undefined") {
                // ES6 Generators
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return Q(result.value);
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // SpiderMonkey Generators
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return Q(exception.value);
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    Q.nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var pendingCount = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++pendingCount;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--pendingCount === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (pendingCount === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Returns the first resolved promise of an array. Prior rejected promises are
 * ignored.  Rejects only if all promises are rejected.
 * @param {Array*} an array containing values or promises for values
 * @returns a promise fulfilled with the value of the first resolved promise,
 * or a rejected promise if all promises are rejected.
 */
Q.any = any;

function any(promises) {
    if (promises.length === 0) {
        return Q.resolve();
    }

    var deferred = Q.defer();
    var pendingCount = 0;
    array_reduce(promises, function (prev, current, index) {
        var promise = promises[index];

        pendingCount++;

        when(promise, onFulfilled, onRejected, onProgress);
        function onFulfilled(result) {
            deferred.resolve(result);
        }
        function onRejected() {
            pendingCount--;
            if (pendingCount === 0) {
                deferred.reject(new Error(
                    "Can't get fulfillment value from any promise, all " +
                    "promises were rejected."
                ));
            }
        }
        function onProgress(progress) {
            deferred.notify({
                index: index,
                value: progress
            });
        }
    }, undefined);

    return deferred.promise;
}

Promise.prototype.any = function () {
    return any(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        Q.nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {Any*} custom error message or Error object (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, error) {
    return Q(object).timeout(ms, error);
};

Promise.prototype.timeout = function (ms, error) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        if (!error || "string" === typeof error) {
            error = new Error(error || "Timed out after " + ms + " ms");
            error.code = "ETIMEDOUT";
        }
        deferred.reject(error);
    }, ms);

    this.then(function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        setTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            Q.nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            Q.nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

Q.noConflict = function() {
    throw new Error("Q.noConflict only works when Q is used as a global");
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});

}).call(this,require('_process'))
},{"_process":87}],91:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],92:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],93:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":91,"./encode":92}],94:[function(require,module,exports){
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":95}],95:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":97,"./_stream_writable":99,"core-util-is":48,"inherits":76,"process-nextick-args":86}],96:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":98,"core-util-is":48,"inherits":76}],97:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_stream_duplex":95,"./internal/streams/BufferList":100,"./internal/streams/destroy":101,"./internal/streams/stream":102,"_process":87,"core-util-is":48,"events":67,"inherits":76,"isarray":77,"process-nextick-args":86,"safe-buffer":108,"string_decoder/":132,"util":43}],98:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":95,"core-util-is":48,"inherits":76}],99:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_stream_duplex":95,"./internal/streams/destroy":101,"./internal/streams/stream":102,"_process":87,"core-util-is":48,"inherits":76,"process-nextick-args":86,"safe-buffer":108,"util-deprecate":140}],100:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":108,"util":43}],101:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":86}],102:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":67}],103:[function(require,module,exports){
module.exports = require('./readable').PassThrough

},{"./readable":104}],104:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":95,"./lib/_stream_passthrough.js":96,"./lib/_stream_readable.js":97,"./lib/_stream_transform.js":98,"./lib/_stream_writable.js":99}],105:[function(require,module,exports){
module.exports = require('./readable').Transform

},{"./readable":104}],106:[function(require,module,exports){
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":99}],107:[function(require,module,exports){

/**
 * Reduce `arr` with `fn`.
 *
 * @param {Array} arr
 * @param {Function} fn
 * @param {Mixed} initial
 *
 * TODO: combatible error handling?
 */

module.exports = function(arr, fn, initial){  
  var idx = 0;
  var len = arr.length;
  var curr = arguments.length == 3
    ? initial
    : arr[idx++];

  while (idx < len) {
    curr = fn.call(null, curr, arr[idx], ++idx, arr);
  }
  
  return curr;
};
},{}],108:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":44}],109:[function(require,module,exports){

/**
 * Module dependencies.
 */

var url = require('./url');
var parser = require('socket.io-parser');
var Manager = require('./manager');
var debug = require('debug')('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup(uri, opts) {
  if (typeof uri == 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id].nsps;
  var newConnection = opts.forceNew || opts['force new connection'] ||
                      false === opts.multiplex || sameNamespace;

  var io;

  if (newConnection) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }

  return io.socket(parsed.path);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = require('./manager');
exports.Socket = require('./socket');

},{"./manager":110,"./socket":112,"./url":113,"debug":115,"socket.io-parser":119}],110:[function(require,module,exports){

/**
 * Module dependencies.
 */

var eio = require('engine.io-client');
var Socket = require('./socket');
var Emitter = require('component-emitter');
var parser = require('socket.io-parser');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:manager');
var indexOf = require('indexof');
var Backoff = require('backo2');

/**
 * IE6+ hasOwnProperty
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager(uri, opts){
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' == typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connecting = [];
  this.lastPing = null;
  this.encoding = false;
  this.packetBuffer = [];
  this.encoder = new parser.Encoder();
  this.decoder = new parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function() {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    }
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function(){
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].id = this.engine.id;
    }
  }
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function(v){
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function(v){
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function(v){
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function(v){
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function(v){
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function(v){
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function() {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};


/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function(fn){
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function() {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function(data){
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function(){
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function(){
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
};

/**
 * Called upon a ping.
 *
 * @api private
 */

Manager.prototype.onping = function(){
  this.lastPing = new Date;
  this.emitAll('ping');
};

/**
 * Called upon a packet.
 *
 * @api private
 */

Manager.prototype.onpong = function(){
  this.emitAll('pong', new Date - this.lastPing);
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function(data){
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function(packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function(err){
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function(nsp){
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connecting', onConnecting);
    socket.on('connect', function(){
      socket.id = self.engine.id;
    });

    if (this.autoConnect) {
      // manually call here since connecting evnet is fired before listening
      onConnecting();
    }
  }

  function onConnecting() {
    if (!~indexOf(self.connecting, socket)) {
      self.connecting.push(socket);
    }
  }

  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function(socket){
  var index = indexOf(this.connecting, socket);
  if (~index) this.connecting.splice(index, 1);
  if (this.connecting.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function(packet){
  debug('writing packet %j', packet);
  var self = this;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function(encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i], packet.options);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function() {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function(){
  debug('cleanup');

  var sub;
  while (sub = this.subs.shift()) sub.destroy();

  this.packetBuffer = [];
  this.encoding = false;
  this.lastPing = null;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function(){
  debug('disconnect');
  this.skipReconnect = true;
  this.reconnecting = false;
  if ('opening' == this.readyState) {
    // `onclose` will not fire because
    // an open event never happened
    this.cleanup();
  }
  this.backoff.reset();
  this.readyState = 'closed';
  if (this.engine) this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function(reason){
  debug('onclose');

  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);

  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function(){
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function(){
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function(err){
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function(){
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};

},{"./on":111,"./socket":112,"backo2":39,"component-bind":46,"component-emitter":114,"debug":115,"engine.io-client":49,"indexof":75,"socket.io-parser":119}],111:[function(require,module,exports){

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on(obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function(){
      obj.removeListener(ev, fn);
    }
  };
}

},{}],112:[function(require,module,exports){

/**
 * Module dependencies.
 */

var parser = require('socket.io-parser');
var Emitter = require('component-emitter');
var toArray = require('to-array');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:socket');
var hasBin = require('has-binary');

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  connecting: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1,
  ping: 1,
  pong: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket(io, nsp){
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
  if (this.io.autoConnect) this.open();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function() {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function(){
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' == this.io.readyState) this.onopen();
  this.emit('connecting');
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function(){
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function(ev){
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var parserType = parser.EVENT; // default
  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
  var packet = { type: parserType, data: args };

  packet.options = {};
  packet.options.compress = !this.flags || false !== this.flags.compress;

  // event ack callback
  if ('function' == typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  delete this.flags;

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function(packet){
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function(){
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' != this.nsp) {
    this.packet({ type: parser.CONNECT });
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function(reason){
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function(packet){
  if (packet.nsp != this.nsp) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function(packet){
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function(id){
  var self = this;
  var sent = false;
  return function(){
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
    self.packet({
      type: type,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function(packet){
  var ack = this.acks[packet.id];
  if ('function' == typeof ack) {
    debug('calling ack %s with %j', packet.id, packet.data);
    ack.apply(this, packet.data);
    delete this.acks[packet.id];
  } else {
    debug('bad ack %s', packet.id);
  }
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function(){
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function(){
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function(){
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function(){
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function(){
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

/**
 * Sets the compress flag.
 *
 * @param {Boolean} if `true`, compresses the sending data
 * @return {Socket} self
 * @api public
 */

Socket.prototype.compress = function(compress){
  this.flags = this.flags || {};
  this.flags.compress = compress;
  return this;
};

},{"./on":111,"component-bind":46,"component-emitter":114,"debug":115,"has-binary":70,"socket.io-parser":119,"to-array":136}],113:[function(require,module,exports){
(function (global){

/**
 * Module dependencies.
 */

var parseuri = require('parseuri');
var debug = require('debug')('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url(uri, loc){
  var obj = uri;

  // default to window.location
  var loc = loc || global.location;
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' == typeof uri) {
    if ('/' == uri.charAt(0)) {
      if ('/' == uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' != typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    }
    else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  var ipv6 = obj.host.indexOf(':') !== -1;
  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

  // define unique id
  obj.id = obj.protocol + '://' + host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + host + (loc && loc.port == obj.port ? '' : (':' + obj.port));

  return obj;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"debug":115,"parseuri":85}],114:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],115:[function(require,module,exports){
arguments[4][60][0].apply(exports,arguments)
},{"./debug":116,"dup":60}],116:[function(require,module,exports){
arguments[4][61][0].apply(exports,arguments)
},{"dup":61,"ms":117}],117:[function(require,module,exports){
arguments[4][62][0].apply(exports,arguments)
},{"dup":62}],118:[function(require,module,exports){
(function (global){
/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = require('isarray');
var isBuf = require('./is-buffer');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet){
  var buffers = [];
  var packetData = packet.data;

  function _deconstructPacket(data) {
    if (!data) return data;

    if (isBuf(data)) {
      var placeholder = { _placeholder: true, num: buffers.length };
      buffers.push(data);
      return placeholder;
    } else if (isArray(data)) {
      var newData = new Array(data.length);
      for (var i = 0; i < data.length; i++) {
        newData[i] = _deconstructPacket(data[i]);
      }
      return newData;
    } else if ('object' == typeof data && !(data instanceof Date)) {
      var newData = {};
      for (var key in data) {
        newData[key] = _deconstructPacket(data[key]);
      }
      return newData;
    }
    return data;
  }

  var pack = packet;
  pack.data = _deconstructPacket(packetData);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  var curPlaceHolder = 0;

  function _reconstructPacket(data) {
    if (data && data._placeholder) {
      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
      return buf;
    } else if (isArray(data)) {
      for (var i = 0; i < data.length; i++) {
        data[i] = _reconstructPacket(data[i]);
      }
      return data;
    } else if (data && 'object' == typeof data) {
      for (var key in data) {
        data[key] = _reconstructPacket(data[key]);
      }
      return data;
    }
    return data;
  }

  packet.data = _reconstructPacket(packet.data);
  packet.attachments = undefined; // no longer useful
  return packet;
};

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((global.Blob && obj instanceof Blob) ||
        (global.File && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./is-buffer":120,"isarray":124}],119:[function(require,module,exports){

/**
 * Module dependencies.
 */

var debug = require('debug')('socket.io-parser');
var json = require('json3');
var isArray = require('isarray');
var Emitter = require('component-emitter');
var binary = require('./binary');
var isBuf = require('./is-buffer');

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'ACK',
  'ERROR',
  'BINARY_EVENT',
  'BINARY_ACK'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    encodeAsBinary(obj, callback);
  }
  else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {
  var str = '';
  var nsp = false;

  // first is type
  str += obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    str += obj.attachments;
    str += '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' != obj.nsp) {
    nsp = true;
    str += obj.nsp;
  }

  // immediately followed by the id
  if (null != obj.id) {
    if (nsp) {
      str += ',';
      nsp = false;
    }
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    if (nsp) str += ',';
    str += json.stringify(obj.data);
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if ('string' == typeof obj) {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  }
  else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  }
  else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var p = {};
  var i = 0;

  // look up type
  p.type = Number(str.charAt(0));
  if (null == exports.types[p.type]) return error();

  // look up attachments if type binary
  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
    var buf = '';
    while (str.charAt(++i) != '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) != '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' == str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' == c) break;
      p.nsp += c;
      if (i == str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i == str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    try {
      p.data = json.parse(str.substr(i));
    } catch(e){
      return error();
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(data){
  return {
    type: exports.ERROR,
    data: 'parser error'
  };
}

},{"./binary":118,"./is-buffer":120,"component-emitter":121,"debug":122,"isarray":124,"json3":78}],120:[function(require,module,exports){
(function (global){

module.exports = isBuf;

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],121:[function(require,module,exports){
arguments[4][59][0].apply(exports,arguments)
},{"dup":59}],122:[function(require,module,exports){
arguments[4][60][0].apply(exports,arguments)
},{"./debug":123,"dup":60}],123:[function(require,module,exports){
arguments[4][61][0].apply(exports,arguments)
},{"dup":61,"ms":125}],124:[function(require,module,exports){
arguments[4][66][0].apply(exports,arguments)
},{"dup":66}],125:[function(require,module,exports){
arguments[4][62][0].apply(exports,arguments)
},{"dup":62}],126:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":67,"inherits":76,"readable-stream/duplex.js":94,"readable-stream/passthrough.js":103,"readable-stream/readable.js":104,"readable-stream/transform.js":105,"readable-stream/writable.js":106}],127:[function(require,module,exports){
var ClientRequest = require('./lib/request')
var extend = require('xtend')
var statusCodes = require('builtin-status-codes')
var url = require('url')

var http = exports

http.request = function (opts, cb) {
	if (typeof opts === 'string')
		opts = url.parse(opts)
	else
		opts = extend(opts)

	var protocol = opts.protocol || ''
	var host = opts.hostname || opts.host
	var port = opts.port
	var path = opts.path || '/'

	// Necessary for IPv6 addresses
	if (host && host.indexOf(':') !== -1)
		host = '[' + host + ']'

	// This may be a relative url. The browser should always be able to interpret it correctly.
	opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path
	opts.method = (opts.method || 'GET').toUpperCase()
	opts.headers = opts.headers || {}

	// Also valid opts.auth, opts.mode

	var req = new ClientRequest(opts)
	if (cb)
		req.on('response', cb)
	return req
}

http.get = function get (opts, cb) {
	var req = http.request(opts, cb)
	req.end()
	return req
}

http.Agent = function () {}
http.Agent.defaultMaxSockets = 4

http.STATUS_CODES = statusCodes

http.METHODS = [
	'CHECKOUT',
	'CONNECT',
	'COPY',
	'DELETE',
	'GET',
	'HEAD',
	'LOCK',
	'M-SEARCH',
	'MERGE',
	'MKACTIVITY',
	'MKCOL',
	'MOVE',
	'NOTIFY',
	'OPTIONS',
	'PATCH',
	'POST',
	'PROPFIND',
	'PROPPATCH',
	'PURGE',
	'PUT',
	'REPORT',
	'SEARCH',
	'SUBSCRIBE',
	'TRACE',
	'UNLOCK',
	'UNSUBSCRIBE'
]
},{"./lib/request":129,"builtin-status-codes":45,"url":138,"xtend":143}],128:[function(require,module,exports){
(function (global){
exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableByteStream)

exports.blobConstructor = false
try {
	new Blob([new ArrayBuffer(1)])
	exports.blobConstructor = true
} catch (e) {}

var xhr = new global.XMLHttpRequest()
// If location.host is empty, e.g. if this page/worker was loaded
// from a Blob, then use example.com to avoid an error
xhr.open('GET', global.location.host ? '/' : 'https://example.com')

function checkTypeSupport (type) {
	try {
		xhr.responseType = type
		return xhr.responseType === type
	} catch (e) {}
	return false
}

// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.
// Safari 7.1 appears to have fixed this bug.
var haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined'
var haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice)

exports.arraybuffer = haveArrayBuffer && checkTypeSupport('arraybuffer')
// These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.
exports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream')
exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&
	checkTypeSupport('moz-chunked-arraybuffer')
exports.overrideMimeType = isFunction(xhr.overrideMimeType)
exports.vbArray = isFunction(global.VBArray)

function isFunction (value) {
  return typeof value === 'function'
}

xhr = null // Help gc

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],129:[function(require,module,exports){
(function (process,global,Buffer){
// var Base64 = require('Base64')
var capability = require('./capability')
var foreach = require('foreach')
var indexOf = require('indexof')
var inherits = require('inherits')
var keys = require('object-keys')
var response = require('./response')
var stream = require('stream')

var IncomingMessage = response.IncomingMessage
var rStates = response.readyStates

function decideMode (preferBinary) {
	if (capability.fetch) {
		return 'fetch'
	} else if (capability.mozchunkedarraybuffer) {
		return 'moz-chunked-arraybuffer'
	} else if (capability.msstream) {
		return 'ms-stream'
	} else if (capability.arraybuffer && preferBinary) {
		return 'arraybuffer'
	} else if (capability.vbArray && preferBinary) {
		return 'text:vbarray'
	} else {
		return 'text'
	}
}

var ClientRequest = module.exports = function (opts) {
	var self = this
	stream.Writable.call(self)

	self._opts = opts
	self._body = []
	self._headers = {}
	if (opts.auth)
		self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'))
	foreach(keys(opts.headers), function (name) {
		self.setHeader(name, opts.headers[name])
	})

	var preferBinary
	if (opts.mode === 'prefer-streaming') {
		// If streaming is a high priority but binary compatibility and
		// the accuracy of the 'content-type' header aren't
		preferBinary = false
	} else if (opts.mode === 'allow-wrong-content-type') {
		// If streaming is more important than preserving the 'content-type' header
		preferBinary = !capability.overrideMimeType
	} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
		// Use binary if text streaming may corrupt data or the content-type header, or for speed
		preferBinary = true
	} else {
		throw new Error('Invalid value for opts.mode')
	}
	self._mode = decideMode(preferBinary)

	self.on('finish', function () {
		self._onFinish()
	})
}

inherits(ClientRequest, stream.Writable)

ClientRequest.prototype.setHeader = function (name, value) {
	var self = this
	var lowerName = name.toLowerCase()
	// This check is not necessary, but it prevents warnings from browsers about setting unsafe
	// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
	// http-browserify did it, so I will too.
	if (indexOf(unsafeHeaders, lowerName) !== -1)
		return

	self._headers[lowerName] = {
		name: name,
		value: value
	}
}

ClientRequest.prototype.getHeader = function (name) {
	var self = this
	return self._headers[name.toLowerCase()].value
}

ClientRequest.prototype.removeHeader = function (name) {
	var self = this
	delete self._headers[name.toLowerCase()]
}

ClientRequest.prototype._onFinish = function () {
	var self = this

	if (self._destroyed)
		return
	var opts = self._opts

	var headersObj = self._headers
	var body
	if (opts.method === 'POST' || opts.method === 'PUT') {
		if (capability.blobConstructor) {
			body = new global.Blob(self._body.map(function (buffer) {
				return buffer.toArrayBuffer()
			}), {
				type: (headersObj['content-type'] || {}).value || ''
			})
		} else {
			// get utf8 string
			body = Buffer.concat(self._body).toString()
		}
	}

	if (self._mode === 'fetch') {
		var headers = keys(headersObj).map(function (name) {
			return [headersObj[name].name, headersObj[name].value]
		})

		global.fetch(self._opts.url, {
			method: self._opts.method,
			headers: headers,
			body: body,
			mode: 'cors',
			credentials: opts.withCredentials ? 'include' : 'same-origin'
		}).then(function (response) {
			self._fetchResponse = response
			self._connect()
		}).then(undefined, function (reason) {
			self.emit('error', reason)
		})
	} else {
		var xhr = self._xhr = new global.XMLHttpRequest()
		try {
			xhr.open(self._opts.method, self._opts.url, true)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}

		// Can't set responseType on really old browsers
		if ('responseType' in xhr)
			xhr.responseType = self._mode.split(':')[0]

		if ('withCredentials' in xhr)
			xhr.withCredentials = !!opts.withCredentials

		if (self._mode === 'text' && 'overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain; charset=x-user-defined')

		foreach(keys(headersObj), function (name) {
			xhr.setRequestHeader(headersObj[name].name, headersObj[name].value)
		})

		self._response = null
		xhr.onreadystatechange = function () {
			switch (xhr.readyState) {
				case rStates.LOADING:
				case rStates.DONE:
					self._onXHRProgress()
					break
			}
		}
		// Necessary for streaming in Firefox, since xhr.response is ONLY defined
		// in onprogress, not in onreadystatechange with xhr.readyState = 3
		if (self._mode === 'moz-chunked-arraybuffer') {
			xhr.onprogress = function () {
				self._onXHRProgress()
			}
		}

		xhr.onerror = function () {
			if (self._destroyed)
				return
			self.emit('error', new Error('XHR error'))
		}

		try {
			xhr.send(body)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}
	}
}

/**
 * Checks if xhr.status is readable. Even though the spec says it should
 * be available in readyState 3, accessing it throws an exception in IE8
 */
function statusValid (xhr) {
	try {
		return (xhr.status !== null)
	} catch (e) {
		return false
	}
}

ClientRequest.prototype._onXHRProgress = function () {
	var self = this

	if (!statusValid(self._xhr) || self._destroyed)
		return

	if (!self._response)
		self._connect()

	self._response._onXHRProgress()
}

ClientRequest.prototype._connect = function () {
	var self = this

	if (self._destroyed)
		return

	self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode)
	self.emit('response', self._response)
}

ClientRequest.prototype._write = function (chunk, encoding, cb) {
	var self = this

	self._body.push(chunk)
	cb()
}

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {
	var self = this
	self._destroyed = true
	if (self._response)
		self._response._destroyed = true
	if (self._xhr)
		self._xhr.abort()
	// Currently, there isn't a way to truly abort a fetch.
	// If you like bikeshedding, see https://github.com/whatwg/fetch/issues/27
}

ClientRequest.prototype.end = function (data, encoding, cb) {
	var self = this
	if (typeof data === 'function') {
		cb = data
		data = undefined
	}

	stream.Writable.prototype.end.call(self, data, encoding, cb)
}

ClientRequest.prototype.flushHeaders = function () {}
ClientRequest.prototype.setTimeout = function () {}
ClientRequest.prototype.setNoDelay = function () {}
ClientRequest.prototype.setSocketKeepAlive = function () {}

// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var unsafeHeaders = [
	'accept-charset',
	'accept-encoding',
	'access-control-request-headers',
	'access-control-request-method',
	'connection',
	'content-length',
	'cookie',
	'cookie2',
	'date',
	'dnt',
	'expect',
	'host',
	'keep-alive',
	'origin',
	'referer',
	'te',
	'trailer',
	'transfer-encoding',
	'upgrade',
	'user-agent',
	'via'
]

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"./capability":128,"./response":130,"_process":87,"buffer":44,"foreach":69,"indexof":75,"inherits":76,"object-keys":80,"stream":126}],130:[function(require,module,exports){
(function (process,global,Buffer){
var capability = require('./capability')
var foreach = require('foreach')
var inherits = require('inherits')
var stream = require('stream')

var rStates = exports.readyStates = {
	UNSENT: 0,
	OPENED: 1,
	HEADERS_RECEIVED: 2,
	LOADING: 3,
	DONE: 4
}

var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode) {
	var self = this
	stream.Readable.call(self)

	self._mode = mode
	self.headers = {}
	self.rawHeaders = []
	self.trailers = {}
	self.rawTrailers = []

	// Fake the 'close' event, but only once 'end' fires
	self.on('end', function () {
		// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
		process.nextTick(function () {
			self.emit('close')
		})
	})

	if (mode === 'fetch') {
		self._fetchResponse = response

		self.statusCode = response.status
		self.statusMessage = response.statusText
		// backwards compatible version of for (<item> of <iterable>):
		// for (var <item>,_i,_it = <iterable>[Symbol.iterator](); <item> = (_i = _it.next()).value,!_i.done;)
		for (var header, _i, _it = response.headers[Symbol.iterator](); header = (_i = _it.next()).value, !_i.done;) {
			self.headers[header[0].toLowerCase()] = header[1]
			self.rawHeaders.push(header[0], header[1])
		}

		// TODO: this doesn't respect backpressure. Once WritableStream is available, this can be fixed
		var reader = response.body.getReader()
		function read () {
			reader.read().then(function (result) {
				if (self._destroyed)
					return
				if (result.done) {
					self.push(null)
					return
				}
				self.push(new Buffer(result.value))
				read()
			})
		}
		read()

	} else {
		self._xhr = xhr
		self._pos = 0

		self.statusCode = xhr.status
		self.statusMessage = xhr.statusText
		var headers = xhr.getAllResponseHeaders().split(/\r?\n/)
		foreach(headers, function (header) {
			var matches = header.match(/^([^:]+):\s*(.*)/)
			if (matches) {
				var key = matches[1].toLowerCase()
				if (self.headers[key] !== undefined)
					self.headers[key] += ', ' + matches[2]
				else
					self.headers[key] = matches[2]
				self.rawHeaders.push(matches[1], matches[2])
			}
		})

		self._charset = 'x-user-defined'
		if (!capability.overrideMimeType) {
			var mimeType = self.rawHeaders['mime-type']
			if (mimeType) {
				var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/)
				if (charsetMatch) {
					self._charset = charsetMatch[1].toLowerCase()
				}
			}
			if (!self._charset)
				self._charset = 'utf-8' // best guess
		}
	}
}

inherits(IncomingMessage, stream.Readable)

IncomingMessage.prototype._read = function () {}

IncomingMessage.prototype._onXHRProgress = function () {
	var self = this

	var xhr = self._xhr

	var response = null
	switch (self._mode) {
		case 'text:vbarray': // For IE9
			if (xhr.readyState !== rStates.DONE)
				break
			try {
				// This fails in IE8
				response = new global.VBArray(xhr.responseBody).toArray()
			} catch (e) {}
			if (response !== null) {
				self.push(new Buffer(response))
				break
			}
			// Falls through in IE8	
		case 'text':
			try { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4
				response = xhr.responseText
			} catch (e) {
				self._mode = 'text:vbarray'
				break
			}
			if (response.length > self._pos) {
				var newData = response.substr(self._pos)
				if (self._charset === 'x-user-defined') {
					var buffer = new Buffer(newData.length)
					for (var i = 0; i < newData.length; i++)
						buffer[i] = newData.charCodeAt(i) & 0xff

					self.push(buffer)
				} else {
					self.push(newData, self._charset)
				}
				self._pos = response.length
			}
			break
		case 'arraybuffer':
			if (xhr.readyState !== rStates.DONE)
				break
			response = xhr.response
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'moz-chunked-arraybuffer': // take whole
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING || !response)
				break
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'ms-stream':
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING)
				break
			var reader = new global.MSStreamReader()
			reader.onprogress = function () {
				if (reader.result.byteLength > self._pos) {
					self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))))
					self._pos = reader.result.byteLength
				}
			}
			reader.onload = function () {
				self.push(null)
			}
			// reader.onerror = ??? // TODO: this
			reader.readAsArrayBuffer(response)
			break
	}

	// The ms-stream case handles end separately in reader.onload()
	if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
		self.push(null)
	}
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"./capability":128,"_process":87,"buffer":44,"foreach":69,"inherits":76,"stream":126}],131:[function(require,module,exports){
var nargs = /\{([0-9a-zA-Z_]+)\}/g

module.exports = template

function template(string) {
    var args

    if (arguments.length === 2 && typeof arguments[1] === "object") {
        args = arguments[1]
    } else {
        args = new Array(arguments.length - 1)
        for (var i = 1; i < arguments.length; ++i) {
            args[i - 1] = arguments[i]
        }
    }

    if (!args || !args.hasOwnProperty) {
        args = {}
    }

    return string.replace(nargs, function replaceArg(match, i, index) {
        var result

        if (string[index - 1] === "{" &&
            string[index + match.length] === "}") {
            return i
        } else {
            result = args.hasOwnProperty(i) ? args[i] : null
            if (result === null || result === undefined) {
                return ""
            }

            return result
        }
    })
}

},{}],132:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":108}],133:[function(require,module,exports){
/**
 * Module dependencies.
 */

var Emitter = require('emitter');
var reduce = require('reduce');

/**
 * Root reference for iframes.
 */

var root;
if (typeof window !== 'undefined') { // Browser window
  root = window;
} else if (typeof self !== 'undefined') { // Web Worker
  root = self;
} else { // Other environments
  root = this;
}

/**
 * Noop.
 */

function noop(){};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * TODO: future proof, move to compoent land
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isHost(obj) {
  var str = {}.toString.call(obj);

  switch (str) {
    case '[object File]':
    case '[object Blob]':
    case '[object FormData]':
      return true;
    default:
      return false;
  }
}

/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest
      && (!root.location || 'file:' != root.location.protocol
          || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  return false;
};

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim
  ? function(s) { return s.trim(); }
  : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };

/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return obj === Object(obj);
}

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];
  for (var key in obj) {
    if (null != obj[key]) {
      pushEncodedKeyValuePair(pairs, key, obj[key]);
        }
      }
  return pairs.join('&');
}

/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */

function pushEncodedKeyValuePair(pairs, key, val) {
  if (Array.isArray(val)) {
    return val.forEach(function(v) {
      pushEncodedKeyValuePair(pairs, key, v);
    });
  }
  pairs.push(encodeURIComponent(key)
    + '=' + encodeURIComponent(val));
}

/**
 * Expose serialization method.
 */

 request.serializeObject = serialize;

 /**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var parts;
  var pair;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    parts = pair.split('=');
    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'application/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

 request.serialize = {
   'application/x-www-form-urlencoded': serialize,
   'application/json': JSON.stringify
 };

 /**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  lines.pop(); // trailing CRLF

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */

function isJSON(mime) {
  return /[\/+]json\b/.test(mime);
}

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function type(str){
  return str.split(/ *; */).shift();
};

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function params(str){
  return reduce(str.split(/ *; */), function(obj, str){
    var parts = str.split(/ *= */)
      , key = parts.shift()
      , val = parts.shift();

    if (key && val) obj[key] = val;
    return obj;
  }, {});
};

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req, options) {
  options = options || {};
  this.req = req;
  this.xhr = this.req.xhr;
  // responseText is accessible only if responseType is '' or 'text' and on older browsers
  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')
     ? this.xhr.responseText
     : null;
  this.statusText = this.req.xhr.statusText;
  this.setStatusProperties(this.xhr.status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this.setHeaderProperties(this.header);
  this.body = this.req.method != 'HEAD'
    ? this.parseBody(this.text ? this.text : this.xhr.response)
    : null;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

Response.prototype.get = function(field){
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

Response.prototype.setHeaderProperties = function(header){
  // content-type
  var ct = this.header['content-type'] || '';
  this.type = type(ct);

  // params
  var obj = params(ct);
  for (var key in obj) this[key] = obj[key];
};

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype.parseBody = function(str){
  var parse = request.parse[this.type];
  return parse && str && (str.length || str instanceof Object)
    ? parse(str)
    : null;
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

Response.prototype.setStatusProperties = function(status){
  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  if (status === 1223) {
    status = 204;
  }

  var type = status / 100 | 0;

  // status / class
  this.status = this.statusCode = status;
  this.statusType = type;

  // basics
  this.info = 1 == type;
  this.ok = 2 == type;
  this.clientError = 4 == type;
  this.serverError = 5 == type;
  this.error = (4 == type || 5 == type)
    ? this.toError()
    : false;

  // sugar
  this.accepted = 202 == status;
  this.noContent = 204 == status;
  this.badRequest = 400 == status;
  this.unauthorized = 401 == status;
  this.notAcceptable = 406 == status;
  this.notFound = 404 == status;
  this.forbidden = 403 == status;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  var req = this.req;
  var method = req.method;
  var url = req.url;

  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  Emitter.call(this);
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {};
  this._header = {};
  this.on('end', function(){
    var err = null;
    var res = null;

    try {
      res = new Response(self);
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
      // issue #675: return the raw response if the response parsing fails
      err.rawResponse = self.xhr && self.xhr.responseText ? self.xhr.responseText : null;
      return self.callback(err);
    }

    self.emit('response', res);

    if (err) {
      return self.callback(err, res);
    }

    if (res.status >= 200 && res.status < 300) {
      return self.callback(err, res);
    }

    var new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
    new_err.original = err;
    new_err.response = res;
    new_err.status = res.status;

    self.callback(new_err, res);
  });
}

/**
 * Mixin `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Allow for extension
 */

Request.prototype.use = function(fn) {
  fn(this);
  return this;
}

/**
 * Set timeout to `ms`.
 *
 * @param {Number} ms
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.timeout = function(ms){
  this._timeout = ms;
  return this;
};

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.clearTimeout = function(){
  this._timeout = 0;
  clearTimeout(this._timer);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */

Request.prototype.abort = function(){
  if (this.aborted) return;
  this.aborted = true;
  this.xhr.abort();
  this.clearTimeout();
  this.emit('abort');
  return this;
};

/**
 * Set header `field` to `val`, or multiple fields with one object.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.set = function(field, val){
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Get case-insensitive header `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api private
 */

Request.prototype.getHeader = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Force given parser
 *
 * Sets the body parser no matter type.
 *
 * @param {Function}
 * @api public
 */

Request.prototype.parse = function(fn){
  this._parser = fn;
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} pass
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass){
  var str = btoa(user + ':' + pass);
  this.set('Authorization', 'Basic ' + str);
  return this;
};

/**
* Add query-string `val`.
*
* Examples:
*
*   request.get('/shoes')
*     .query('size=10')
*     .query({ color: 'blue' })
*
* @param {Object|String} val
* @return {Request} for chaining
* @api public
*/

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Write the field `name` and `val` for "multipart/form-data"
 * request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 * ```
 *
 * @param {String} name
 * @param {String|Blob|File} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.field = function(name, val){
  if (!this._formData) this._formData = new root.FormData();
  this._formData.append(name, val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `filename`.
 *
 * ``` js
 * request.post('/upload')
 *   .attach(new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String} filename
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, filename){
  if (!this._formData) this._formData = new root.FormData();
  this._formData.append(field, file, filename || file.name);
  return this;
};

/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
  *      request.post('/user')
  *        .send('name=tobi')
  *        .send('species=ferret')
  *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.send = function(data){
  var obj = isObject(data);
  var type = this.getHeader('Content-Type');

  // merge
  if (obj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    if (!type) this.type('form');
    type = this.getHeader('Content-Type');
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? this._data + '&' + data
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!obj || isHost(data)) return this;
  if (!type) this.type('json');
  return this;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  var fn = this._callback;
  this.clearTimeout();
  fn(err, res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;

  err.status = this.status;
  err.method = this.method;
  err.url = this.url;

  this.callback(err);
};

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

Request.prototype.timeoutError = function(){
  var timeout = this._timeout;
  var err = new Error('timeout of ' + timeout + 'ms exceeded');
  err.timeout = timeout;
  this.callback(err);
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

Request.prototype.withCredentials = function(){
  this._withCredentials = true;
  return this;
};

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  var self = this;
  var xhr = this.xhr = request.getXHR();
  var query = this._query.join('&');
  var timeout = this._timeout;
  var data = this._formData || this._data;

  // store callback
  this._callback = fn || noop;

  // state change
  xhr.onreadystatechange = function(){
    if (4 != xhr.readyState) return;

    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"
    var status;
    try { status = xhr.status } catch(e) { status = 0; }

    if (0 == status) {
      if (self.timedout) return self.timeoutError();
      if (self.aborted) return;
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  var handleProgress = function(e){
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }
    e.direction = 'download';
    self.emit('progress', e);
  };
  if (this.hasListeners('progress')) {
    xhr.onprogress = handleProgress;
  }
  try {
    if (xhr.upload && this.hasListeners('progress')) {
      xhr.upload.onprogress = handleProgress;
    }
  } catch(e) {
    // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
    // Reported here:
    // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
  }

  // timeout
  if (timeout && !this._timer) {
    this._timer = setTimeout(function(){
      self.timedout = true;
      self.abort();
    }, timeout);
  }

  // querystring
  if (query) {
    query = request.serializeObject(query);
    this.url += ~this.url.indexOf('?')
      ? '&' + query
      : '?' + query;
  }

  // initiate request
  xhr.open(this.method, this.url, true);

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {
    // serialize stuff
    var contentType = this.getHeader('Content-Type');
    var serialize = this._parser || request.serialize[contentType ? contentType.split(';')[0] : ''];
    if (!serialize && isJSON(contentType)) serialize = request.serialize['application/json'];
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (var field in this.header) {
    if (null == this.header[field]) continue;
    xhr.setRequestHeader(field, this.header[field]);
  }

  // send stuff
  this.emit('request', this);

  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined
  xhr.send(typeof data !== 'undefined' ? data : null);
  return this;
};

/**
 * Faux promise support
 *
 * @param {Function} fulfill
 * @param {Function} reject
 * @return {Request}
 */

Request.prototype.then = function (fulfill, reject) {
  return this.end(function(err, res) {
    err ? reject(err) : fulfill(res);
  });
}

/**
 * Expose `Request`.
 */

request.Request = Request;

/**
 * Issue a request:
 *
 * Examples:
 *
 *    request('GET', '/users').end(callback)
 *    request('/users').end(callback)
 *    request('/users', callback)
 *
 * @param {String} method
 * @param {String|Function} url or callback
 * @return {Request}
 * @api public
 */

function request(method, url) {
  // callback
  if ('function' == typeof url) {
    return new Request('GET', method).end(url);
  }

  // url first
  if (1 == arguments.length) {
    return new Request('GET', method);
  }

  return new Request(method, url);
}

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.get = function(url, data, fn){
  var req = request('GET', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.head = function(url, data, fn){
  var req = request('HEAD', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

function del(url, fn){
  var req = request('DELETE', url);
  if (fn) req.end(fn);
  return req;
};

request['del'] = del;
request['delete'] = del;

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} data
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.patch = function(url, data, fn){
  var req = request('PATCH', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} data
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.post = function(url, data, fn){
  var req = request('POST', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.put = function(url, data, fn){
  var req = request('PUT', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * Expose `request`.
 */

module.exports = request;

},{"emitter":134,"reduce":107}],134:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],135:[function(require,module,exports){
(function (Buffer){
"0.50.0";
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS=CryptoJS||function(e,m){var p={},j=p.lib={},l=function(){},f=j.Base={extend:function(a){l.prototype=this;var c=new l;a&&c.mixIn(a);c.hasOwnProperty("init")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
n=j.WordArray=f.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=m?c:4*a.length},toString:function(a){return(a||h).stringify(this)},concat:function(a){var c=this.words,q=a.words,d=this.sigBytes;a=a.sigBytes;this.clamp();if(d%4)for(var b=0;b<a;b++)c[d+b>>>2]|=(q[b>>>2]>>>24-8*(b%4)&255)<<24-8*((d+b)%4);else if(65535<q.length)for(b=0;b<a;b+=4)c[d+b>>>2]=q[b>>>2];else c.push.apply(c,q);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<
32-8*(c%4);a.length=e.ceil(c/4)},clone:function(){var a=f.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],b=0;b<a;b+=4)c.push(4294967296*e.random()|0);return new n.init(c,a)}}),b=p.enc={},h=b.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var b=[],d=0;d<a;d++){var f=c[d>>>2]>>>24-8*(d%4)&255;b.push((f>>>4).toString(16));b.push((f&15).toString(16))}return b.join("")},parse:function(a){for(var c=a.length,b=[],d=0;d<c;d+=2)b[d>>>3]|=parseInt(a.substr(d,
2),16)<<24-4*(d%8);return new n.init(b,c/2)}},g=b.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var b=[],d=0;d<a;d++)b.push(String.fromCharCode(c[d>>>2]>>>24-8*(d%4)&255));return b.join("")},parse:function(a){for(var c=a.length,b=[],d=0;d<c;d++)b[d>>>2]|=(a.charCodeAt(d)&255)<<24-8*(d%4);return new n.init(b,c)}},r=b.Utf8={stringify:function(a){try{return decodeURIComponent(escape(g.stringify(a)))}catch(c){throw Error("Malformed UTF-8 data");}},parse:function(a){return g.parse(unescape(encodeURIComponent(a)))}},
k=j.BufferedBlockAlgorithm=f.extend({reset:function(){this._data=new n.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=r.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,b=c.words,d=c.sigBytes,f=this.blockSize,h=d/(4*f),h=a?e.ceil(h):e.max((h|0)-this._minBufferSize,0);a=h*f;d=e.min(4*a,d);if(a){for(var g=0;g<a;g+=f)this._doProcessBlock(b,g);g=b.splice(0,a);c.sigBytes-=d}return new n.init(g,d)},clone:function(){var a=f.clone.call(this);
a._data=this._data.clone();return a},_minBufferSize:0});j.Hasher=k.extend({cfg:f.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){k.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,b){return(new a.init(b)).finalize(c)}},_createHmacHelper:function(a){return function(b,f){return(new s.HMAC.init(a,
f)).finalize(b)}}});var s=p.algo={};return p}(Math);
(function(){var e=CryptoJS,m=e.lib,p=m.WordArray,j=m.Hasher,l=[],m=e.algo.SHA1=j.extend({_doReset:function(){this._hash=new p.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(f,n){for(var b=this._hash.words,h=b[0],g=b[1],e=b[2],k=b[3],j=b[4],a=0;80>a;a++){if(16>a)l[a]=f[n+a]|0;else{var c=l[a-3]^l[a-8]^l[a-14]^l[a-16];l[a]=c<<1|c>>>31}c=(h<<5|h>>>27)+j+l[a];c=20>a?c+((g&e|~g&k)+1518500249):40>a?c+((g^e^k)+1859775393):60>a?c+((g&e|g&k|e&k)-1894007588):c+((g^e^
k)-899497514);j=k;k=e;e=g<<30|g>>>2;g=h;h=c}b[0]=b[0]+h|0;b[1]=b[1]+g|0;b[2]=b[2]+e|0;b[3]=b[3]+k|0;b[4]=b[4]+j|0},_doFinalize:function(){var f=this._data,e=f.words,b=8*this._nDataBytes,h=8*f.sigBytes;e[h>>>5]|=128<<24-h%32;e[(h+64>>>9<<4)+14]=Math.floor(b/4294967296);e[(h+64>>>9<<4)+15]=b;f.sigBytes=4*e.length;this._process();return this._hash},clone:function(){var e=j.clone.call(this);e._hash=this._hash.clone();return e}});e.SHA1=j._createHelper(m);e.HmacSHA1=j._createHmacHelper(m)})();

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS=CryptoJS||function(h,s){var f={},t=f.lib={},g=function(){},j=t.Base={extend:function(a){g.prototype=this;var c=new g;a&&c.mixIn(a);c.hasOwnProperty("init")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
q=t.WordArray=j.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=s?c:4*a.length},toString:function(a){return(a||u).stringify(this)},concat:function(a){var c=this.words,d=a.words,b=this.sigBytes;a=a.sigBytes;this.clamp();if(b%4)for(var e=0;e<a;e++)c[b+e>>>2]|=(d[e>>>2]>>>24-8*(e%4)&255)<<24-8*((b+e)%4);else if(65535<d.length)for(e=0;e<a;e+=4)c[b+e>>>2]=d[e>>>2];else c.push.apply(c,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<
32-8*(c%4);a.length=h.ceil(c/4)},clone:function(){var a=j.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],d=0;d<a;d+=4)c.push(4294967296*h.random()|0);return new q.init(c,a)}}),v=f.enc={},u=v.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++){var e=c[b>>>2]>>>24-8*(b%4)&255;d.push((e>>>4).toString(16));d.push((e&15).toString(16))}return d.join("")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b+=2)d[b>>>3]|=parseInt(a.substr(b,
2),16)<<24-4*(b%8);return new q.init(d,c/2)}},k=v.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++)d.push(String.fromCharCode(c[b>>>2]>>>24-8*(b%4)&255));return d.join("")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b++)d[b>>>2]|=(a.charCodeAt(b)&255)<<24-8*(b%4);return new q.init(d,c)}},l=v.Utf8={stringify:function(a){try{return decodeURIComponent(escape(k.stringify(a)))}catch(c){throw Error("Malformed UTF-8 data");}},parse:function(a){return k.parse(unescape(encodeURIComponent(a)))}},
x=t.BufferedBlockAlgorithm=j.extend({reset:function(){this._data=new q.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=l.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,d=c.words,b=c.sigBytes,e=this.blockSize,f=b/(4*e),f=a?h.ceil(f):h.max((f|0)-this._minBufferSize,0);a=f*e;b=h.min(4*a,b);if(a){for(var m=0;m<a;m+=e)this._doProcessBlock(d,m);m=d.splice(0,a);c.sigBytes-=b}return new q.init(m,b)},clone:function(){var a=j.clone.call(this);
a._data=this._data.clone();return a},_minBufferSize:0});t.Hasher=x.extend({cfg:j.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){x.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,d){return(new a.init(d)).finalize(c)}},_createHmacHelper:function(a){return function(c,d){return(new w.HMAC.init(a,
d)).finalize(c)}}});var w=f.algo={};return f}(Math);
(function(h){for(var s=CryptoJS,f=s.lib,t=f.WordArray,g=f.Hasher,f=s.algo,j=[],q=[],v=function(a){return 4294967296*(a-(a|0))|0},u=2,k=0;64>k;){var l;a:{l=u;for(var x=h.sqrt(l),w=2;w<=x;w++)if(!(l%w)){l=!1;break a}l=!0}l&&(8>k&&(j[k]=v(h.pow(u,0.5))),q[k]=v(h.pow(u,1/3)),k++);u++}var a=[],f=f.SHA256=g.extend({_doReset:function(){this._hash=new t.init(j.slice(0))},_doProcessBlock:function(c,d){for(var b=this._hash.words,e=b[0],f=b[1],m=b[2],h=b[3],p=b[4],j=b[5],k=b[6],l=b[7],n=0;64>n;n++){if(16>n)a[n]=
c[d+n]|0;else{var r=a[n-15],g=a[n-2];a[n]=((r<<25|r>>>7)^(r<<14|r>>>18)^r>>>3)+a[n-7]+((g<<15|g>>>17)^(g<<13|g>>>19)^g>>>10)+a[n-16]}r=l+((p<<26|p>>>6)^(p<<21|p>>>11)^(p<<7|p>>>25))+(p&j^~p&k)+q[n]+a[n];g=((e<<30|e>>>2)^(e<<19|e>>>13)^(e<<10|e>>>22))+(e&f^e&m^f&m);l=k;k=j;j=p;p=h+r|0;h=m;m=f;f=e;e=r+g|0}b[0]=b[0]+e|0;b[1]=b[1]+f|0;b[2]=b[2]+m|0;b[3]=b[3]+h|0;b[4]=b[4]+p|0;b[5]=b[5]+j|0;b[6]=b[6]+k|0;b[7]=b[7]+l|0},_doFinalize:function(){var a=this._data,d=a.words,b=8*this._nDataBytes,e=8*a.sigBytes;
d[e>>>5]|=128<<24-e%32;d[(e+64>>>9<<4)+14]=h.floor(b/4294967296);d[(e+64>>>9<<4)+15]=b;a.sigBytes=4*d.length;this._process();return this._hash},clone:function(){var a=g.clone.call(this);a._hash=this._hash.clone();return a}});s.SHA256=g._createHelper(f);s.HmacSHA256=g._createHmacHelper(f)})(Math);

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var C_enc = C.enc;

    /**
     * Base64 encoding strategy.
     */
    var Base64 = C_enc.Base64 = {
        /**
         * Converts a word array to a Base64 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The Base64 string.
         *
         * @static
         *
         * @example
         *
         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;

            // Clamp excess bits
            wordArray.clamp();

            // Convert
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
                }
            }

            // Add padding
            var paddingChar = map.charAt(64);
            if (paddingChar) {
                while (base64Chars.length % 4) {
                    base64Chars.push(paddingChar);
                }
            }

            return base64Chars.join('');
        },

        /**
         * Converts a Base64 string to a word array.
         *
         * @param {string} base64Str The Base64 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
         */
        parse: function (base64Str) {
            // Shortcuts
            var base64StrLength = base64Str.length;
            var map = this._map;

            // Ignore padding
            var paddingChar = map.charAt(64);
            if (paddingChar) {
                var paddingIndex = base64Str.indexOf(paddingChar);
                if (paddingIndex != -1) {
                    base64StrLength = paddingIndex;
                }
            }

            // Convert
            var words = [];
            var nBytes = 0;
            for (var i = 0; i < base64StrLength; i++) {
                if (i % 4) {
                    var bits1 = map.indexOf(base64Str.charAt(i - 1)) << ((i % 4) * 2);
                    var bits2 = map.indexOf(base64Str.charAt(i)) >>> (6 - (i % 4) * 2);
                    words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
                    nBytes++;
                }
            }

            return WordArray.create(words, nBytes);
        },

        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
    };
}());

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
    // Check if typed arrays are supported
    if (typeof ArrayBuffer != 'function') {
        return;
    }

    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;

    // Reference original init
    var superInit = WordArray.init;

    // Augment WordArray.init to handle typed arrays
    var subInit = WordArray.init = function (typedArray) {
        // Convert buffers to uint8
        if (typedArray instanceof ArrayBuffer) {
            typedArray = new Uint8Array(typedArray);
        }

        // Convert other array views to uint8
        if (
            typedArray instanceof Int8Array ||
            typedArray instanceof Uint8ClampedArray ||
            typedArray instanceof Int16Array ||
            typedArray instanceof Uint16Array ||
            typedArray instanceof Int32Array ||
            typedArray instanceof Uint32Array ||
            typedArray instanceof Float32Array ||
            typedArray instanceof Float64Array
        ) {
            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
        }

        // Handle Uint8Array
        if (typedArray instanceof Uint8Array) {
            // Shortcut
            var typedArrayByteLength = typedArray.byteLength;

            // Extract bytes
            var words = [];
            for (var i = 0; i < typedArrayByteLength; i++) {
                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
            }

            // Initialize this word array
            superInit.call(this, words, typedArrayByteLength);
        } else {
            // Else call normal init
            superInit.apply(this, arguments);
        }
    };

    subInit.prototype = WordArray;
}());

/*!
    Copyright 2012 Rustici Software

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
TinCan client library

TODO:

* Add statement queueing

@module TinCan
**/
var TinCan;

(function () {
    "use strict";
    var _reservedQSParams = {
        //
        // these are TC spec reserved words that may end up in queries to the endpoint
        //
        statementId:       true,
        voidedStatementId: true,
        verb:              true,
        object:            true,
        registration:      true,
        context:           true,
        actor:             true,
        since:             true,
        until:             true,
        limit:             true,
        authoritative:     true,
        sparse:            true,
        instructor:        true,
        ascending:         true,
        continueToken:     true,
        agent:             true,
        activityId:        true,
        stateId:           true,
        profileId:         true,

        //
        // these are suggested by the LMS launch spec addition that TinCanJS consumes
        //
        activity_platform: true,
        grouping:          true,
        "Accept-Language": true
    };

    /**
    @class TinCan
    @constructor
    @param {Object} [options] Configuration used to initialize.
        @param {String} [options.url] URL for determining launch provided
            configuration options
        @param {Array} [options.recordStores] list of pre-configured LRSes
        @param {Object|TinCan.Agent} [options.actor] default actor
        @param {Object|TinCan.Activity} [options.activity] default activity
        @param {String} [options.registration] default registration
        @param {Object|TinCan.Context} [options.context] default context
    **/
    TinCan = function (cfg) {
        this.log("constructor");

        /**
        @property recordStores
        @type Array
        */
        this.recordStores = [];

        /**
        Default actor used when preparing statements that
        don't yet have an actor set, and for saving state, etc.

        @property actor
        @type Object
        */
        this.actor = null;

        /**
        Default activity, may be used as a statement 'target'
        or incorporated into 'context'

        @property activity
        @type Object
        */
        this.activity = null;

        /**
        Default registration, included in default context when
        provided, otherwise used in statement queries

        @property registration
        @type String
        */
        this.registration = null;

        /**
        Default context used when preparing statements that
        don't yet have a context set, or mixed in when one
        has been provided, properties do NOT override on mixing

        @property context
        @type Object
        */
        this.context = null;

        this.init(cfg);
    };

    TinCan.prototype = {
        LOG_SRC: "TinCan",

        /**
        Safe version of logging, only displays when .DEBUG is true, and console.log
        is available

        @method log
        @param {String} msg Message to output
        */
        log: function (msg, src) {
            /* globals console */
            if (TinCan.DEBUG && typeof console !== "undefined" && console.log) {
                src = src || this.LOG_SRC || "TinCan";

                console.log("TinCan." + src + ": " + msg);
            }
        },

        /**
        @method init
        @param {Object} [options] Configuration used to initialize (see TinCan constructor).
        */
        init: function (cfg) {
            this.log("init");
            var i;

            cfg = cfg || {};

            if (cfg.hasOwnProperty("url") && cfg.url !== "") {
                this._initFromQueryString(cfg.url);
            }

            if (cfg.hasOwnProperty("recordStores") && cfg.recordStores !== undefined) {
                for (i = 0; i < cfg.recordStores.length; i += 1) {
                    this.addRecordStore(cfg.recordStores[i]);
                }
            }
            if (cfg.hasOwnProperty("activity")) {
                if (cfg.activity instanceof TinCan.Activity) {
                    this.activity = cfg.activity;
                }
                else {
                    this.activity = new TinCan.Activity (cfg.activity);
                }
            }
            if (cfg.hasOwnProperty("actor")) {
                if (cfg.actor instanceof TinCan.Agent) {
                    this.actor = cfg.actor;
                }
                else {
                    this.actor = new TinCan.Agent (cfg.actor);
                }
            }
            if (cfg.hasOwnProperty("context")) {
                if (cfg.context instanceof TinCan.Context) {
                    this.context = cfg.context;
                }
                else {
                    this.context = new TinCan.Context (cfg.context);
                }
            }
            if (cfg.hasOwnProperty("registration")) {
                this.registration = cfg.registration;
            }
        },

        /**
        @method _initFromQueryString
        @param {String} url
        @private
        */
        _initFromQueryString: function (url) {
            this.log("_initFromQueryString");

            var i,
                prop,
                qsParams = TinCan.Utils.parseURL(url).params,
                lrsProps = ["endpoint", "auth"],
                lrsCfg = {},
                contextCfg,
                extended = null
            ;

            if (qsParams.hasOwnProperty("actor")) {
                this.log("_initFromQueryString - found actor: " + qsParams.actor);
                try {
                    this.actor = TinCan.Agent.fromJSON(qsParams.actor);
                    delete qsParams.actor;
                }
                catch (ex) {
                    this.log("_initFromQueryString - failed to set actor: " + ex);
                }
            }

            if (qsParams.hasOwnProperty("activity_id")) {
                this.activity = new TinCan.Activity (
                    {
                        id: qsParams.activity_id
                    }
                );
                delete qsParams.activity_id;
            }

            if (
                qsParams.hasOwnProperty("activity_platform") ||
                qsParams.hasOwnProperty("registration") ||
                qsParams.hasOwnProperty("grouping")
            ) {
                contextCfg = {};

                if (qsParams.hasOwnProperty("activity_platform")) {
                    contextCfg.platform = qsParams.activity_platform;
                    delete qsParams.activity_platform;
                }
                if (qsParams.hasOwnProperty("registration")) {
                    //
                    // stored in two locations cause we always want it in the default
                    // context, but we also want to be able to get to it for Statement
                    // queries
                    //
                    contextCfg.registration = this.registration = qsParams.registration;
                    delete qsParams.registration;
                }
                if (qsParams.hasOwnProperty("grouping")) {
                    contextCfg.contextActivities = {};
                    contextCfg.contextActivities.grouping = qsParams.grouping;
                    delete qsParams.grouping;
                }

                this.context = new TinCan.Context (contextCfg);
            }

            //
            // order matters here, process the URL provided LRS last because it gets
            // all the remaining parameters so that they get passed through
            //
            if (qsParams.hasOwnProperty("endpoint")) {
                for (i = 0; i < lrsProps.length; i += 1) {
                    prop = lrsProps[i];
                    if (qsParams.hasOwnProperty(prop)) {
                        lrsCfg[prop] = qsParams[prop];
                        delete qsParams[prop];
                    }
                }

                // remove our reserved params so they don't end up  in the extended object
                for (i in qsParams) {
                    if (qsParams.hasOwnProperty(i)) {
                        if (_reservedQSParams.hasOwnProperty(i)) {
                            delete qsParams[i];
                        } else {
                            extended = extended || {};
                            extended[i] = qsParams[i];
                        }
                    }
                }
                if (extended !== null) {
                    lrsCfg.extended = extended;
                }

                lrsCfg.allowFail = false;

                this.addRecordStore(lrsCfg);
            }
        },

        /**
        @method addRecordStore
        @param {Object} Configuration data

         * TODO:
         * check endpoint for trailing '/'
         * check for unique endpoints
        */
        addRecordStore: function (cfg) {
            this.log("addRecordStore");
            var lrs;
            if (cfg instanceof TinCan.LRS) {
                lrs = cfg;
            }
            else {
                lrs = new TinCan.LRS (cfg);
            }
            this.recordStores.push(lrs);
        },

        /**
        @method prepareStatement
        @param {Object|TinCan.Statement} Base statement properties or
            pre-created TinCan.Statement instance
        @return {TinCan.Statement}
        */
        prepareStatement: function (stmt) {
            this.log("prepareStatement");
            if (! (stmt instanceof TinCan.Statement)) {
                stmt = new TinCan.Statement (stmt);
            }

            if (stmt.actor === null && this.actor !== null) {
                stmt.actor = this.actor;
            }
            if (stmt.target === null && this.activity !== null) {
                stmt.target = this.activity;
            }

            if (this.context !== null) {
                if (stmt.context === null) {
                    stmt.context = this.context;
                }
                else {
                    if (stmt.context.registration === null) {
                        stmt.context.registration = this.context.registration;
                    }
                    if (stmt.context.platform === null) {
                        stmt.context.platform = this.context.platform;
                    }

                    if (this.context.contextActivities !== null) {
                        if (stmt.context.contextActivities === null) {
                            stmt.context.contextActivities = this.context.contextActivities;
                        }
                        else {
                            if (this.context.contextActivities.grouping !== null && stmt.context.contextActivities.grouping === null) {
                                stmt.context.contextActivities.grouping = this.context.contextActivities.grouping;
                            }
                            if (this.context.contextActivities.parent !== null && stmt.context.contextActivities.parent === null) {
                                stmt.context.contextActivities.parent = this.context.contextActivities.parent;
                            }
                            if (this.context.contextActivities.other !== null && stmt.context.contextActivities.other === null) {
                                stmt.context.contextActivities.other = this.context.contextActivities.other;
                            }
                        }
                    }
                }
            }

            return stmt;
        },

        /**
        Calls saveStatement on each configured LRS, provide callback to make it asynchronous

        @method sendStatement
        @param {TinCan.Statement|Object} statement Send statement to LRS
        @param {Function} [callback] Callback function to execute on completion
        */
        sendStatement: function (stmt, callback) {
            this.log("sendStatement");

            // would prefer to use .bind instead of 'self'
            var self = this,
                lrs,
                statement = this.prepareStatement(stmt),
                rsCount = this.recordStores.length,
                i,
                results = [],
                callbackWrapper,
                callbackResults = []
            ;

            if (rsCount > 0) {
                /*
                   if there is a callback that is a function then we need
                   to wrap that function with a function that becomes
                   the new callback that reduces a closure count of the
                   requests that don't have allowFail set to true and
                   when that number hits zero then the original callback
                   is executed
                */
                if (typeof callback === "function") {
                    callbackWrapper = function (err, xhr) {
                        var args;

                        self.log("sendStatement - callbackWrapper: " + rsCount);
                        if (rsCount > 1) {
                            rsCount -= 1;
                            callbackResults.push(
                                {
                                    err: err,
                                    xhr: xhr
                                }
                            );
                        }
                        else if (rsCount === 1) {
                            callbackResults.push(
                                {
                                    err: err,
                                    xhr: xhr
                                }
                            );
                            args = [
                                callbackResults,
                                statement
                            ];
                            callback.apply(this, args);
                        }
                        else {
                            self.log("sendStatement - unexpected record store count: " + rsCount);
                        }
                    };
                }

                for (i = 0; i < rsCount; i += 1) {
                    lrs = this.recordStores[i];

                    results.push(
                        lrs.saveStatement(statement, { callback: callbackWrapper })
                    );
                }
            }
            else {
                this.log("[warning] sendStatement: No LRSs added yet (statement not sent)");
                if (typeof callback === "function") {
                    callback.apply(this, [ null, statement ]);
                }
            }

            return {
                statement: statement,
                results: results
            };
        },

        /**
        Calls retrieveStatement on the first LRS, provide callback to make it asynchronous

        @method getStatement
        @param {String} [stmtId] Statement ID to get
        @param {Function} [callback] Callback function to execute on completion
        @param {Object} [cfg] Configuration data
            @param {Object} [params] Query parameters
                @param {Boolean} [attachments] Include attachments in multipart response or don't (defualt: false)
        @return {Array|Result} Array of results, or single result

        TODO: make TinCan track statements it has seen in a local cache to be returned easily
        */
        getStatement: function (stmtId, callback, cfg) {
            this.log("getStatement");

            var lrs;

            cfg = cfg || {};
            cfg.params = cfg.params || {};

            if (this.recordStores.length > 0) {
                //
                // for statements (for now) we only need to read from the first LRS
                // in the future it may make sense to get all from all LRSes and
                // compare to remove duplicates or allow inspection of them for differences?
                //
                // TODO: make this the first non-allowFail LRS but for now it should
                // be good enough to make it the first since we know the LMS provided
                // LRS is the first
                //
                lrs = this.recordStores[0];

                return lrs.retrieveStatement(stmtId, { callback: callback, params: cfg.params });
            }

            this.log("[warning] getStatement: No LRSs added yet (statement not retrieved)");
        },

        /**
        Creates a statement used for voiding the passed statement/statement ID and calls
        send statement with the voiding statement.

        @method voidStatement
        @param {TinCan.Statement|String} statement Statement or statement ID to void
        @param {Function} [callback] Callback function to execute on completion
        @param {Object} [options] Options used to build voiding statement
            @param {TinCan.Agent} [options.actor] Agent to be used as 'actor' in voiding statement
        */
        voidStatement: function (stmt, callback, options) {
            this.log("voidStatement");

            // would prefer to use .bind instead of 'self'
            var self = this,
                lrs,
                actor,
                voidingStatement,
                rsCount = this.recordStores.length,
                i,
                results = [],
                callbackWrapper,
                callbackResults = []
            ;

            if (stmt instanceof TinCan.Statement) {
                stmt = stmt.id;
            }

            if (typeof options.actor !== "undefined") {
                actor = options.actor;
            }
            else if (this.actor !== null) {
                actor = this.actor;
            }

            voidingStatement = new TinCan.Statement(
                {
                    actor: actor,
                    verb: {
                        id: "http://adlnet.gov/expapi/verbs/voided"
                    },
                    target: {
                        objectType: "StatementRef",
                        id: stmt
                    }
                }
            );

            if (rsCount > 0) {
                /*
                   if there is a callback that is a function then we need
                   to wrap that function with a function that becomes
                   the new callback that reduces a closure count of the
                   requests that don't have allowFail set to true and
                   when that number hits zero then the original callback
                   is executed
                */
                if (typeof callback === "function") {
                    callbackWrapper = function (err, xhr) {
                        var args;

                        self.log("voidStatement - callbackWrapper: " + rsCount);
                        if (rsCount > 1) {
                            rsCount -= 1;
                            callbackResults.push(
                                {
                                    err: err,
                                    xhr: xhr
                                }
                            );
                        }
                        else if (rsCount === 1) {
                            callbackResults.push(
                                {
                                    err: err,
                                    xhr: xhr
                                }
                            );
                            args = [
                                callbackResults,
                                voidingStatement
                            ];
                            callback.apply(this, args);
                        }
                        else {
                            self.log("voidStatement - unexpected record store count: " + rsCount);
                        }
                    };
                }

                for (i = 0; i < rsCount; i += 1) {
                    lrs = this.recordStores[i];

                    results.push(
                        lrs.saveStatement(voidingStatement, { callback: callbackWrapper })
                    );
                }
            }
            else {
                this.log("[warning] voidStatement: No LRSs added yet (statement not sent)");
                if (typeof callback === "function") {
                    callback.apply(this, [ null, voidingStatement ]);
                }
            }

            return {
                statement: voidingStatement,
                results: results
            };
        },

        /**
        Calls retrieveVoidedStatement on the first LRS, provide callback to make it asynchronous

        @method getVoidedStatement
        @param {String} statement Statement ID to get
        @param {Function} [callback] Callback function to execute on completion
        @return {Array|Result} Array of results, or single result

        TODO: make TinCan track voided statements it has seen in a local cache to be returned easily
        */
        getVoidedStatement: function (stmtId, callback) {
            this.log("getVoidedStatement");

            var lrs;

            if (this.recordStores.length > 0) {
                //
                // for statements (for now) we only need to read from the first LRS
                // in the future it may make sense to get all from all LRSes and
                // compare to remove duplicates or allow inspection of them for differences?
                //
                // TODO: make this the first non-allowFail LRS but for now it should
                // be good enough to make it the first since we know the LMS provided
                // LRS is the first
                //
                lrs = this.recordStores[0];

                return lrs.retrieveVoidedStatement(stmtId, { callback: callback });
            }

            this.log("[warning] getVoidedStatement: No LRSs added yet (statement not retrieved)");
        },

        /**
        Calls saveStatements with list of prepared statements

        @method sendStatements
        @param {Array} Array of statements to send
        @param {Function} Callback function to execute on completion
        */
        sendStatements: function (stmts, callback) {
            this.log("sendStatements");
            var self = this,
                lrs,
                statements = [],
                rsCount = this.recordStores.length,
                i,
                results = [],
                callbackWrapper,
                callbackResults = []
            ;
            if (stmts.length === 0) {
                if (typeof callback === "function") {
                    callback.apply(this, [ null, statements ]);
                }
            }
            else {
                for (i = 0; i < stmts.length; i += 1) {
                    statements.push(
                        this.prepareStatement(stmts[i])
                    );
                }

                if (rsCount > 0) {
                    /*
                       if there is a callback that is a function then we need
                       to wrap that function with a function that becomes
                       the new callback that reduces a closure count of the
                       requests that don't have allowFail set to true and
                       when that number hits zero then the original callback
                       is executed
                    */

                    if (typeof callback === "function") {
                        callbackWrapper = function (err, xhr) {
                            var args;

                            self.log("sendStatements - callbackWrapper: " + rsCount);
                            if (rsCount > 1) {
                                rsCount -= 1;
                                callbackResults.push(
                                    {
                                        err: err,
                                        xhr: xhr
                                    }
                                );
                            }
                            else if (rsCount === 1) {
                                callbackResults.push(
                                    {
                                        err: err,
                                        xhr: xhr
                                    }
                                );
                                args = [
                                    callbackResults,
                                    statements
                                ];
                                callback.apply(this, args);
                            }
                            else {
                                self.log("sendStatements - unexpected record store count: " + rsCount);
                            }
                        };
                    }

                    for (i = 0; i < rsCount; i += 1) {
                        lrs = this.recordStores[i];

                        results.push(
                            lrs.saveStatements(statements, { callback: callbackWrapper })
                        );
                    }
                }
                else {
                    this.log("[warning] sendStatements: No LRSs added yet (statements not sent)");
                    if (typeof callback === "function") {
                        callback.apply(this, [ null, statements ]);
                    }
                }
            }

            return {
                statements: statements,
                results: results
            };
        },

        /**
        @method getStatements
        @param {Object} [cfg] Configuration for request
            @param {Boolean} [cfg.sendActor] Include default actor in query params
            @param {Boolean} [cfg.sendActivity] Include default activity in query params
            @param {Object} [cfg.params] Parameters used to filter.
                            These are the same as those accepted by the
                            <a href="TinCan.LRS.html#method_queryStatements">LRS.queryStatements</a>
                            method.

            @param {Function} [cfg.callback] Function to run at completion

        TODO: support multiple LRSs and flag to use single
        */
        getStatements: function (cfg) {
            this.log("getStatements");
            var queryCfg = {},
                lrs,
                params
            ;
            if (this.recordStores.length > 0) {
                //
                // for get (for now) we only get from one (as they should be the same)
                // but it may make sense to long term try to merge statements, perhaps
                // by using statementId as unique
                //
                // TODO: make this the first non-allowFail LRS but for now it should
                // be good enough to make it the first since we know the LMS provided
                // LRS is the first
                //
                lrs = this.recordStores[0];

                cfg = cfg || {};

                // TODO: need a clone function?
                params = cfg.params || {};

                if (cfg.sendActor && this.actor !== null) {
                    if (lrs.version === "0.9" || lrs.version === "0.95") {
                        params.actor = this.actor;
                    }
                    else {
                        params.agent = this.actor;
                    }
                }
                if (cfg.sendActivity && this.activity !== null) {
                    if (lrs.version === "0.9" || lrs.version === "0.95") {
                        params.target = this.activity;
                    }
                    else {
                        params.activity = this.activity;
                    }
                }
                if (typeof params.registration === "undefined" && this.registration !== null) {
                    params.registration = this.registration;
                }

                queryCfg = {
                    params: params
                };
                if (typeof cfg.callback !== "undefined") {
                    queryCfg.callback = cfg.callback;
                }

                return lrs.queryStatements(queryCfg);
            }

            this.log("[warning] getStatements: No LRSs added yet (statements not read)");
        },

        /**
        @method getState
        @param {String} key Key to retrieve from the state
        @param {Object} [cfg] Configuration for request
            @param {Object} [cfg.agent] Agent used in query,
                defaults to 'actor' property if empty
            @param {Object} [cfg.activity] Activity used in query,
                defaults to 'activity' property if empty
            @param {Object} [cfg.registration] Registration used in query,
                defaults to 'registration' property if empty
            @param {Function} [cfg.callback] Function to run with state
        */
        getState: function (key, cfg) {
            this.log("getState");
            var queryCfg,
                lrs
            ;

            if (this.recordStores.length > 0) {
                //
                // for state (for now) we are only going to store to the first LRS
                // so only get from there too
                //
                // TODO: make this the first non-allowFail LRS but for now it should
                // be good enough to make it the first since we know the LMS provided
                // LRS is the first
                //
                lrs = this.recordStores[0];

                cfg = cfg || {};

                queryCfg = {
                    agent: (typeof cfg.agent !== "undefined" ? cfg.agent : this.actor),
                    activity: (typeof cfg.activity !== "undefined" ? cfg.activity : this.activity)
                };
                if (typeof cfg.registration !== "undefined") {
                    queryCfg.registration = cfg.registration;
                }
                else if (this.registration !== null) {
                    queryCfg.registration = this.registration;
                }
                if (typeof cfg.callback !== "undefined") {
                    queryCfg.callback = cfg.callback;
                }

                return lrs.retrieveState(key, queryCfg);
            }

            this.log("[warning] getState: No LRSs added yet (state not retrieved)");
        },

        /**
        @method setState
        @param {String} key Key to store into the state
        @param {String|Object} val Value to store into the state, objects will be stringified to JSON
        @param {Object} [cfg] Configuration for request
            @param {Object} [cfg.agent] Agent used in query,
                defaults to 'actor' property if empty
            @param {Object} [cfg.activity] Activity used in query,
                defaults to 'activity' property if empty
            @param {Object} [cfg.registration] Registration used in query,
                defaults to 'registration' property if empty
            @param {String} [cfg.lastSHA1] SHA1 of the previously seen existing state
            @param {String} [cfg.contentType] Content-Type to specify in headers
            @param {Boolean} [cfg.overwriteJSON] If the Content-Type is JSON, should a PUT be used? 
            @param {Function} [cfg.callback] Function to run with state
        */
        setState: function (key, val, cfg) {
            this.log("setState");
            var queryCfg,
                lrs
            ;

            if (this.recordStores.length > 0) {
                //
                // for state (for now) we are only going to store to the first LRS
                // so only get from there too
                //
                // TODO: make this the first non-allowFail LRS but for now it should
                // be good enough to make it the first since we know the LMS provided
                // LRS is the first
                //
                lrs = this.recordStores[0];

                cfg = cfg || {};

                queryCfg = {
                    agent: (typeof cfg.agent !== "undefined" ? cfg.agent : this.actor),
                    activity: (typeof cfg.activity !== "undefined" ? cfg.activity : this.activity)
                };
                if (typeof cfg.registration !== "undefined") {
                    queryCfg.registration = cfg.registration;
                }
                else if (this.registration !== null) {
                    queryCfg.registration = this.registration;
                }
                if (typeof cfg.lastSHA1 !== "undefined") {
                    queryCfg.lastSHA1 = cfg.lastSHA1;
                }
                if (typeof cfg.contentType !== "undefined") {
                    queryCfg.contentType = cfg.contentType;
                    if ((typeof cfg.overwriteJSON !== "undefined") && (! cfg.overwriteJSON) && (TinCan.Utils.isApplicationJSON(cfg.contentType))) {
                        queryCfg.method = "POST";
                    }
                }
                if (typeof cfg.callback !== "undefined") {
                    queryCfg.callback = cfg.callback;
                }

                return lrs.saveState(key, val, queryCfg);
            }

            this.log("[warning] setState: No LRSs added yet (state not saved)");
        },

        /**
        @method deleteState
        @param {String|null} key Key to remove from the state, or null to clear all
        @param {Object} [cfg] Configuration for request
            @param {Object} [cfg.agent] Agent used in query,
                defaults to 'actor' property if empty
            @param {Object} [cfg.activity] Activity used in query,
                defaults to 'activity' property if empty
            @param {Object} [cfg.registration] Registration used in query,
                defaults to 'registration' property if empty
            @param {Function} [cfg.callback] Function to run with state
        */
        deleteState: function (key, cfg) {
            this.log("deleteState");
            var queryCfg,
                lrs
            ;

            if (this.recordStores.length > 0) {
                //
                // for state (for now) we are only going to store to the first LRS
                // so only get from there too
                //
                // TODO: make this the first non-allowFail LRS but for now it should
                // be good enough to make it the first since we know the LMS provided
                // LRS is the first
                //
                lrs = this.recordStores[0];

                cfg = cfg || {};

                queryCfg = {
                    agent: (typeof cfg.agent !== "undefined" ? cfg.agent : this.actor),
                    activity: (typeof cfg.activity !== "undefined" ? cfg.activity : this.activity)
                };
                if (typeof cfg.registration !== "undefined") {
                    queryCfg.registration = cfg.registration;
                }
                else if (this.registration !== null) {
                    queryCfg.registration = this.registration;
                }
                if (typeof cfg.callback !== "undefined") {
                    queryCfg.callback = cfg.callback;
                }

                return lrs.dropState(key, queryCfg);
            }

            this.log("[warning] deleteState: No LRSs added yet (state not deleted)");
        },

        /**
        @method getActivityProfile
        @param {String} key Key to retrieve from the profile
        @param {Object} [cfg] Configuration for request
            @param {Object} [cfg.activity] Activity used in query,
                defaults to 'activity' property if empty
            @param {Function} [cfg.callback] Function to run with activity profile
        */
        getActivityProfile: function (key, cfg) {
            this.log("getActivityProfile");
            var queryCfg,
                lrs
            ;

            if (this.recordStores.length > 0) {
                //
                // for activity profiles (for now) we are only going to store to the first LRS
                // so only get from there too
                //
                // TODO: make this the first non-allowFail LRS but for now it should
                // be good enough to make it the first since we know the LMS provided
                // LRS is the first
                //
                lrs = this.recordStores[0];

                cfg = cfg || {};

                queryCfg = {
                    activity: (typeof cfg.activity !== "undefined" ? cfg.activity : this.activity)
                };
                if (typeof cfg.callback !== "undefined") {
                    queryCfg.callback = cfg.callback;
                }

                return lrs.retrieveActivityProfile(key, queryCfg);
            }

            this.log("[warning] getActivityProfile: No LRSs added yet (activity profile not retrieved)");
        },

        /**
        @method setActivityProfile
        @param {String} key Key to store into the activity profile
        @param {String|Object} val Value to store into the activity profile, objects will be stringified to JSON
        @param {Object} [cfg] Configuration for request
            @param {Object} [cfg.activity] Activity used in query,
                defaults to 'activity' property if empty
            @param {String} [cfg.lastSHA1] SHA1 of the previously seen existing profile
            @param {String} [cfg.contentType] Content-Type to specify in headers
            @param {Boolean} [cfg.overwriteJSON] If the Content-Type is JSON, should a PUT be used?
            @param {Function} [cfg.callback] Function to run with activity profile
        */
        setActivityProfile: function (key, val, cfg) {
            this.log("setActivityProfile");
            var queryCfg,
                lrs
            ;

            if (this.recordStores.length > 0) {
                //
                // for activity profile (for now) we are only going to store to the first LRS
                // so only get from there too
                //
                // TODO: make this the first non-allowFail LRS but for now it should
                // be good enough to make it the first since we know the LMS provided
                // LRS is the first
                //
                lrs = this.recordStores[0];

                cfg = cfg || {};

                queryCfg = {
                    activity: (typeof cfg.activity !== "undefined" ? cfg.activity : this.activity)
                };
                if (typeof cfg.callback !== "undefined") {
                    queryCfg.callback = cfg.callback;
                }
                if (typeof cfg.lastSHA1 !== "undefined") {
                    queryCfg.lastSHA1 = cfg.lastSHA1;
                }
                if (typeof cfg.contentType !== "undefined") {
                    queryCfg.contentType = cfg.contentType;
                    if ((typeof cfg.overwriteJSON !== "undefined") && (! cfg.overwriteJSON) && (TinCan.Utils.isApplicationJSON(cfg.contentType))) {
                        queryCfg.method = "POST";
                    }
                }

                return lrs.saveActivityProfile(key, val, queryCfg);
            }

            this.log("[warning] setActivityProfile: No LRSs added yet (activity profile not saved)");
        },

        /**
        @method deleteActivityProfile
        @param {String|null} key Key to remove from the activity profile, or null to clear all
        @param {Object} [cfg] Configuration for request
            @param {Object} [cfg.activity] Activity used in query,
                defaults to 'activity' property if empty
            @param {Function} [cfg.callback] Function to run with activity profile
        */
        deleteActivityProfile: function (key, cfg) {
            this.log("deleteActivityProfile");
            var queryCfg,
                lrs
            ;

            if (this.recordStores.length > 0) {
                //
                // for activity profile (for now) we are only going to store to the first LRS
                // so only get from there too
                //
                // TODO: make this the first non-allowFail LRS but for now it should
                // be good enough to make it the first since we know the LMS provided
                // LRS is the first
                //
                lrs = this.recordStores[0];

                cfg = cfg || {};

                queryCfg = {
                    activity: (typeof cfg.activity !== "undefined" ? cfg.activity : this.activity)
                };
                if (typeof cfg.callback !== "undefined") {
                    queryCfg.callback = cfg.callback;
                }

                return lrs.dropActivityProfile(key, queryCfg);
            }

            this.log("[warning] deleteActivityProfile: No LRSs added yet (activity profile not deleted)");
        },

        /**
        @method getAgentProfile
        @param {String} key Key to retrieve from the profile
        @param {Object} [cfg] Configuration for request
            @param {Object} [cfg.agent] Agent used in query,
                defaults to 'actor' property if empty
            @param {Function} [cfg.callback] Function to run with agent profile
        */
        getAgentProfile: function (key, cfg) {
            this.log("getAgentProfile");
            var queryCfg,
                lrs
            ;

            if (this.recordStores.length > 0) {
                //
                // for agent profiles (for now) we are only going to store to the first LRS
                // so only get from there too
                //
                // TODO: make this the first non-allowFail LRS but for now it should
                // be good enough to make it the first since we know the LMS provided
                // LRS is the first
                //
                lrs = this.recordStores[0];

                cfg = cfg || {};

                queryCfg = {
                    agent: (typeof cfg.agent !== "undefined" ? cfg.agent : this.actor)
                };
                if (typeof cfg.callback !== "undefined") {
                    queryCfg.callback = cfg.callback;
                }

                return lrs.retrieveAgentProfile(key, queryCfg);
            }

            this.log("[warning] getAgentProfile: No LRSs added yet (agent profile not retrieved)");
        },

        /**
        @method setAgentProfile
        @param {String} key Key to store into the agent profile
        @param {String|Object} val Value to store into the agent profile, objects will be stringified to JSON
        @param {Object} [cfg] Configuration for request
            @param {Object} [cfg.agent] Agent used in query,
                defaults to 'actor' property if empty
            @param {String} [cfg.lastSHA1] SHA1 of the previously seen existing profile
            @param {String} [cfg.contentType] Content-Type to specify in headers
            @param {Boolean} [cfg.overwriteJSON] If the Content-Type is JSON, should a PUT be used?
            @param {Function} [cfg.callback] Function to run with agent profile
        */
        setAgentProfile: function (key, val, cfg) {
            this.log("setAgentProfile");
            var queryCfg,
                lrs
            ;

            if (this.recordStores.length > 0) {
                //
                // for agent profile (for now) we are only going to store to the first LRS
                // so only get from there too
                //
                // TODO: make this the first non-allowFail LRS but for now it should
                // be good enough to make it the first since we know the LMS provided
                // LRS is the first
                //
                lrs = this.recordStores[0];

                cfg = cfg || {};

                queryCfg = {
                    agent: (typeof cfg.agent !== "undefined" ? cfg.agent : this.actor)
                };
                if (typeof cfg.callback !== "undefined") {
                    queryCfg.callback = cfg.callback;
                }
                if (typeof cfg.lastSHA1 !== "undefined") {
                    queryCfg.lastSHA1 = cfg.lastSHA1;
                }
                if (typeof cfg.contentType !== "undefined") {
                    queryCfg.contentType = cfg.contentType;
                    if ((typeof cfg.overwriteJSON !== "undefined") && (! cfg.overwriteJSON) && (TinCan.Utils.isApplicationJSON(cfg.contentType))) {
                        queryCfg.method = "POST";
                    }
                }

                return lrs.saveAgentProfile(key, val, queryCfg);
            }

            this.log("[warning] setAgentProfile: No LRSs added yet (agent profile not saved)");
        },

        /**
        @method deleteAgentProfile
        @param {String|null} key Key to remove from the agent profile, or null to clear all
        @param {Object} [cfg] Configuration for request
            @param {Object} [cfg.agent] Agent used in query,
                defaults to 'actor' property if empty
            @param {Function} [cfg.callback] Function to run with agent profile
        */
        deleteAgentProfile: function (key, cfg) {
            this.log("deleteAgentProfile");
            var queryCfg,
                lrs
            ;

            if (this.recordStores.length > 0) {
                //
                // for agent profile (for now) we are only going to store to the first LRS
                // so only get from there too
                //
                // TODO: make this the first non-allowFail LRS but for now it should
                // be good enough to make it the first since we know the LMS provided
                // LRS is the first
                //
                lrs = this.recordStores[0];

                cfg = cfg || {};

                queryCfg = {
                    agent: (typeof cfg.agent !== "undefined" ? cfg.agent : this.actor)
                };
                if (typeof cfg.callback !== "undefined") {
                    queryCfg.callback = cfg.callback;
                }

                return lrs.dropAgentProfile(key, queryCfg);
            }

            this.log("[warning] deleteAgentProfile: No LRSs added yet (agent profile not deleted)");
        }
    };

    /**
    @property DEBUG
    @static
    @default false
    */
    TinCan.DEBUG = false;

    /**
    Turn on debug logging

    @method enableDebug
    @static
    */
    TinCan.enableDebug = function () {
        TinCan.DEBUG = true;
    };

    /**
    Turn off debug logging

    @method disableDebug
    @static
    */
    TinCan.disableDebug = function () {
        TinCan.DEBUG = false;
    };

    /**
    @method versions
    @return {Array} Array of supported version numbers
    @static
    */
    TinCan.versions = function () {
        // newest first so we can use the first as the default
        return [
            "1.0.2",
            "1.0.1",
            "1.0.0",
            "0.95",
            "0.9"
        ];
    };

    /*global module*/
    // Support the CommonJS method for exporting our single global
    if (typeof module === "object") {
        module.exports = TinCan;
    }
}());

/*
    Copyright 2012 Rustici Software

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
TinCan client library

@module TinCan
@submodule TinCan.Utils
**/
(function () {
    "use strict";

    /**
    @class TinCan.Utils
    */
    TinCan.Utils = {
        defaultEncoding: "utf8",

        /**
        Generates a UUIDv4 compliant string that should be reasonably unique

        @method getUUID
        @return {String} UUID
        @static

        Excerpt from: http://www.broofa.com/Tools/Math.uuid.js (v1.4)
        http://www.broofa.com
        mailto:robert@broofa.com
        Copyright (c) 2010 Robert Kieffer
        Dual licensed under the MIT and GPL licenses.
        */
        getUUID: function () {
            /*jslint bitwise: true, eqeq: true */
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
                /[xy]/g,
                function (c) {
                    var r = Math.random() * 16|0, v = c == "x" ? r : (r&0x3|0x8);
                    return v.toString(16);
                }
            );
        },

        /**
        @method getISODateString
        @static
        @param {Date} date Date to stringify
        @return {String} ISO date String
        */
        getISODateString: function (d) {
            function pad (val, n) {
                var padder,
                    tempVal;
                if (typeof val === "undefined" || val === null) {
                    val = 0;
                }
                if (typeof n === "undefined" || n === null) {
                    n = 2;
                }
                padder = Math.pow(10, n-1);
                tempVal = val.toString();

                while (val < padder && padder > 1) {
                    tempVal = "0" + tempVal;
                    padder = padder / 10;
                }

                return tempVal;
            }

            return d.getUTCFullYear() + "-" +
                pad(d.getUTCMonth() + 1) + "-" +
                pad(d.getUTCDate()) + "T" +
                pad(d.getUTCHours()) + ":" +
                pad(d.getUTCMinutes()) + ":" +
                pad(d.getUTCSeconds()) + "." +
                pad(d.getUTCMilliseconds(), 3) + "Z";
        },

        /**
        @method convertISO8601DurationToMilliseconds
        @static
        @param {String} ISO8601Duration Duration in ISO8601 format
        @return {Int} Duration in milliseconds

        Note: does not handle input strings with years, months and days
        */
        convertISO8601DurationToMilliseconds: function (ISO8601Duration) {
            var isValueNegative = (ISO8601Duration.indexOf("-") >= 0),
                indexOfT = ISO8601Duration.indexOf("T"),
                indexOfH = ISO8601Duration.indexOf("H"),
                indexOfM = ISO8601Duration.indexOf("M"),
                indexOfS = ISO8601Duration.indexOf("S"),
                hours,
                minutes,
                seconds,
                durationInMilliseconds;

            if ((indexOfT === -1) || ((indexOfM !== -1) && (indexOfM < indexOfT)) || (ISO8601Duration.indexOf("D") !== -1) || (ISO8601Duration.indexOf("Y") !== -1)) {
                throw new Error("ISO 8601 timestamps including years, months and/or days are not currently supported");
            }

            if (indexOfH === -1) {
                indexOfH = indexOfT;
                hours = 0;
            }
            else {
                hours = parseInt(ISO8601Duration.slice(indexOfT + 1, indexOfH), 10);
            }

            if (indexOfM === -1) {
                indexOfM = indexOfT;
                minutes = 0;
            }
            else {
                minutes = parseInt(ISO8601Duration.slice(indexOfH + 1, indexOfM), 10);
            }

            seconds = parseFloat(ISO8601Duration.slice(indexOfM + 1, indexOfS));

            durationInMilliseconds = parseInt((((((hours * 60) + minutes) * 60) + seconds) * 1000), 10);
            if (isNaN(durationInMilliseconds)){
                durationInMilliseconds = 0;
            }
            if (isValueNegative) {
                durationInMilliseconds = durationInMilliseconds * -1;
            }

            return durationInMilliseconds;
        },

        /**
        @method convertMillisecondsToISO8601Duration
        @static
        @param {Int} inputMilliseconds Duration in milliseconds
        @return {String} Duration in ISO8601 format
        */
        convertMillisecondsToISO8601Duration: function (inputMilliseconds) {
            var hours,
                minutes,
                seconds,
                i_inputMilliseconds = parseInt(inputMilliseconds, 10),
                i_inputCentiseconds,
                inputIsNegative = "",
                rtnStr = "";

            //round to nearest 0.01 seconds
            i_inputCentiseconds = Math.round(i_inputMilliseconds / 10);

            if (i_inputCentiseconds < 0) {
                inputIsNegative = "-";
                i_inputCentiseconds = i_inputCentiseconds * -1;
            }

            hours = parseInt(((i_inputCentiseconds) / 360000), 10);
            minutes = parseInt((((i_inputCentiseconds) % 360000) / 6000), 10);
            seconds = (((i_inputCentiseconds) % 360000) % 6000) / 100;

            rtnStr = inputIsNegative + "PT";
            if (hours > 0) {
                rtnStr += hours + "H";
            }

            if (minutes > 0) {
                rtnStr += minutes + "M";
            }

            rtnStr += seconds + "S";

            return rtnStr;
        },

        /**
        @method getSHA1String
        @static
        @param {String} str Content to hash
        @return {String} SHA1 for contents
        */
        getSHA1String: function (str) {
            /*global CryptoJS*/

            return CryptoJS.SHA1(str).toString(CryptoJS.enc.Hex);
        },

        /**
        @method getSHA256String
        @static
        @param {ArrayBuffer|String} content Content to hash
        @return {String} SHA256 for contents
        */
        getSHA256String: function (content) {
            /*global CryptoJS*/

            if (Object.prototype.toString.call(content) === "[object ArrayBuffer]") {
                content = CryptoJS.lib.WordArray.create(content);
            }
            return CryptoJS.SHA256(content).toString(CryptoJS.enc.Hex);
        },

        /**
        @method getBase64String
        @static
        @param {String} str Content to encode
        @return {String} Base64 encoded contents
        */
        getBase64String: function (str) {
            /*global CryptoJS*/

            return CryptoJS.enc.Base64.stringify(
                CryptoJS.enc.Latin1.parse(str)
            );
        },

        /**
        Intended to be inherited by objects with properties that store
        display values in a language based "dictionary"

        @method getLangDictionaryValue
        @param {String} prop Property name storing the dictionary
        @param {String} [lang] Language to return
        @return {String}
        */
        getLangDictionaryValue: function (prop, lang) {
            var langDict = this[prop],
                key;

            if (typeof lang !== "undefined" && typeof langDict[lang] !== "undefined") {
                return langDict[lang];
            }
            if (typeof langDict.und !== "undefined") {
                return langDict.und;
            }
            if (typeof langDict["en-US"] !== "undefined") {
                return langDict["en-US"];
            }
            for (key in langDict) {
                if (langDict.hasOwnProperty(key)) {
                    return langDict[key];
                }
            }

            return "";
        },

        /**
        @method parseURL
        @param {String} url
        @param {Object} [options]
            @param {Boolean} [options.allowRelative] Option to allow relative URLs
        @return {Object} Object of values
        @private
        */
        parseURL: function (url, cfg) {
            //
            // see http://stackoverflow.com/a/21553982
            // and http://stackoverflow.com/a/2880929
            //
            var isRelative = url.charAt(0) === "/",
                _reURLInformation = [
                    "(/[^?#]*)", // pathname
                    "(\\?[^#]*|)", // search
                    "(#.*|)$" // hash
                ],
                reURLInformation,
                match,
                result,
                paramMatch,
                pl     = /\+/g,  // Regex for replacing addition symbol with a space
                search = /([^&=]+)=?([^&]*)/g,
                decode = function (s) { return decodeURIComponent(s.replace(pl, " ")); };

            cfg = cfg || {};

            //
            // this method in an earlier version supported relative URLs, mostly to provide
            // support to the `LRS.moreStatements` method, that functionality was removed and
            // subsequently restored but with the addition of the option for allowing relative
            // URLs to be accepted which is the reason for the "helpful" exception message here
            //
            if (! isRelative) {
                //
                // not relative so make sure they have a scheme, host, etc.
                //
                _reURLInformation.unshift(
                    "^(https?:)//", // scheme
                    "(([^:/?#]*)(?::([0-9]+))?)" // host (hostname and port)
                );

                //
                // our regex requires there to be a '/' for the detection of the start
                // of the path, we can detect a '/' using indexOf beyond the part of the
                // scheme, since we've restricted scheme to 'http' or 'https' and because
                // a hostname is guaranteed to be there we can detect beyond the '://'
                // based on position, then tack on a trailing '/' because it can't be
                // part of the path
                //
                if (url.indexOf("/", 8) === -1) {
                    url = url + "/";
                }
            }
            else {
                //
                // relative so make sure they allow that explicitly
                //
                if (typeof cfg.allowRelative === "undefined" || ! cfg.allowRelative) {
                    throw new Error("Refusing to parse relative URL without 'allowRelative' option");
                }
            }

            reURLInformation = new RegExp(_reURLInformation.join(""));
            match = url.match(reURLInformation);
            if (match === null) {
                throw new Error("Unable to parse URL regular expression did not match: '" + url + "'");
            }

            // 'path' is for backwards compatibility
            if (isRelative) {
                result = {
                    protocol: null,
                    host: null,
                    hostname: null,
                    port: null,
                    path: null,
                    pathname: match[1],
                    search: match[2],
                    hash: match[3],
                    params: {}
                };

                result.path = result.pathname;
            }
            else {
                result = {
                    protocol: match[1],
                    host: match[2],
                    hostname: match[3],
                    port: match[4],
                    pathname: match[5],
                    search: match[6],
                    hash: match[7],
                    params: {}
                };

                result.path = result.protocol + "//" + result.host + result.pathname;
            }

            if (result.search !== "") {
                // extra parens to let jshint know this is an expression
                while ((paramMatch = search.exec(result.search.substring(1)))) {
                    result.params[decode(paramMatch[1])] = decode(paramMatch[2]);
                }
            }

            return result;
        },

        /**
        @method getServerRoot
        @param {String} absoluteUrl
        @return {String} server root of url
        @private
        */
        getServerRoot: function (absoluteUrl) {
            var urlParts = absoluteUrl.split("/");
            return urlParts[0] + "//" + urlParts[2];
        },

        /**
        @method getContentTypeFromHeader
        @static
        @param {String} header Content-Type header value
        @return {String} Primary value from Content-Type
        */
        getContentTypeFromHeader: function (header) {
            return (String(header).split(";"))[0];
        },

        /**
        @method isApplicationJSON
        @static
        @param {String} header Content-Type header value
        @return {Boolean} whether "application/json" was matched
        */
        isApplicationJSON: function (header) {
            return TinCan.Utils.getContentTypeFromHeader(header).toLowerCase().indexOf("application/json") === 0;
        },

        /**
        @method stringToArrayBuffer
        @static
        @param {String} content String of content to convert to an ArrayBuffer
        @param {String} [encoding] Encoding to use for conversion
        @return {ArrayBuffer} Converted content
        */
        stringToArrayBuffer: function () {
            TinCan.prototype.log("stringToArrayBuffer not overloaded - no environment loaded?");
        },

        /**
        @method stringFromArrayBuffer
        @static
        @param {ArrayBuffer} content ArrayBuffer of content to convert to a String
        @param {String} [encoding] Encoding to use for conversion
        @return {String} Converted content
        */
        stringFromArrayBuffer: function () {
            TinCan.prototype.log("stringFromArrayBuffer not overloaded - no environment loaded?");
        }
    };
}());

/*
    Copyright 2012-2013 Rustici Software

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
TinCan client library

@module TinCan
@submodule TinCan.LRS
**/
(function () {
    "use strict";
    /**
    @class TinCan.LRS
    @constructor
    */
    var LRS = TinCan.LRS = function (cfg) {
        this.log("constructor");

        /**
        @property endpoint
        @type String
        */
        this.endpoint = null;

        /**
        @property version
        @type String
        */
        this.version = null;

        /**
        @property auth
        @type String
        */
        this.auth = null;

        /**
        @property allowFail
        @type Boolean
        @default true
        */
        this.allowFail = true;

        /**
        @property extended
        @type Object
        */
        this.extended = null;

        this.init(cfg);
    };
    LRS.prototype = {
        /**
        @property LOG_SRC
        */
        LOG_SRC: "LRS",

        /**
        @method log
        */
        log: TinCan.prototype.log,

        /**
        @method init
        */
        init: function (cfg) {
            this.log("init");

            var versions = TinCan.versions(),
                versionMatch = false,
                i
            ;

            cfg = cfg || {};

            if (cfg.hasOwnProperty("alertOnRequestFailure")) {
                this.log("'alertOnRequestFailure' is deprecated (alerts have been removed) no need to set it now");
            }

            if (! cfg.hasOwnProperty("endpoint") || cfg.endpoint === null || cfg.endpoint === "") {
                this.log("[error] LRS invalid: no endpoint");
                throw {
                    code: 3,
                    mesg: "LRS invalid: no endpoint"
                };
            }

            this.endpoint = String(cfg.endpoint);
            if (this.endpoint.slice(-1) !== "/") {
                this.log("adding trailing slash to endpoint");
                this.endpoint += "/";
            }

            if (cfg.hasOwnProperty("allowFail")) {
                this.allowFail = cfg.allowFail;
            }

            if (cfg.hasOwnProperty("auth")) {
                this.auth = cfg.auth;
            }
            else if (cfg.hasOwnProperty("username") && cfg.hasOwnProperty("password")) {
                this.auth = "Basic " + TinCan.Utils.getBase64String(cfg.username + ":" + cfg.password);
            }

            if (cfg.hasOwnProperty("extended")) {
                this.extended = cfg.extended;
            }

            //
            // provide a hook method that environments can override
            // to handle anything necessary in the initialization
            // process that is customized to them, such as cross domain
            // setup in browsers, default implementation is empty
            //
            // this hook must run prior to version detection so that
            // request handling can be set up before requesting the
            // LRS version via the /about resource
            //
            this._initByEnvironment(cfg);

            if (typeof cfg.version !== "undefined") {
                this.log("version: " + cfg.version);
                for (i = 0; i < versions.length; i += 1) {
                    if (versions[i] === cfg.version) {
                        versionMatch = true;
                        break;
                    }
                }
                if (! versionMatch) {
                    this.log("[error] LRS invalid: version not supported (" + cfg.version + ")");
                    throw {
                        code: 5,
                        mesg: "LRS invalid: version not supported (" + cfg.version + ")"
                    };
                }
                this.version = cfg.version;
            }
            else {
                //
                // assume max supported when not specified,
                // TODO: add detection of LRS from call to endpoint
                //
                this.version = versions[0];
            }
        },

        /**
        Creates and returns a boundary for separating parts in
        requests where the statement has an attachment

        @method _getBoundary
        @private
        */
        _getBoundary: function () {
            return TinCan.Utils.getUUID().replace(/-/g, "");
        },

        /**
        Method should be overloaded by an environment to do per
        environment specifics such that the LRS can make a call
        to set the version if not provided

        @method _initByEnvironment
        @private
        */
        _initByEnvironment: function () {
            this.log("_initByEnvironment not overloaded - no environment loaded?");
        },

        /**
        Method should be overloaded by an environment to do per
        environment specifics for sending requests to the LRS

        @method _makeRequest
        @private
        */
        _makeRequest: function () {
            this.log("_makeRequest not overloaded - no environment loaded?");
        },

        /**
        Method should be overloaded by an environment to do per
        environment specifics for building multipart request data

        @method _getMultipartRequestData
        @private
        */
        _getMultipartRequestData: function () {
            this.log("_getMultipartRequestData not overloaded - no environment loaded?");
        },

        /**
        Method is overloaded by the browser environment in order to test converting an
        HTTP request that is greater than a defined length

        @method _IEModeConversion
        @private
        */
        _IEModeConversion: function () {
            this.log("_IEModeConversion not overloaded - browser environment not loaded.");
        },

        _processGetStatementResult: function (xhr, params) {
            var boundary,
                parsedResponse,
                statement,
                attachmentMap = {},
                i;

            if (! params.attachments) {
                return TinCan.Statement.fromJSON(xhr.responseText);
            }

            boundary = xhr.getResponseHeader("Content-Type").split("boundary=")[1];

            parsedResponse = this._parseMultipart(boundary, xhr.response);
            statement = JSON.parse(parsedResponse[0].body);
            for (i = 1; i < parsedResponse.length; i += 1) {
                attachmentMap[parsedResponse[i].headers["X-Experience-API-Hash"]] = parsedResponse[i].body;
            }

            this._assignAttachmentContent([statement], attachmentMap);

            return new TinCan.Statement(statement);
        },

        /**
        Method used to send a request via browser objects to the LRS

        @method sendRequest
        @param {Object} cfg Configuration for request
            @param {String} cfg.url URL portion to add to endpoint
            @param {String} [cfg.method] GET, PUT, POST, etc.
            @param {Object} [cfg.params] Parameters to set on the querystring
            @param {String|ArrayBuffer} [cfg.data] Body content as a String or ArrayBuffer
            @param {Object} [cfg.headers] Additional headers to set in the request
            @param {Function} [cfg.callback] Function to run at completion
                @param {String|Null} cfg.callback.err If an error occurred, this parameter will contain the HTTP status code.
                    If the operation succeeded, err will be null.
                @param {Object} cfg.callback.xhr XHR object
            @param {Boolean} [cfg.ignore404] Whether 404 status codes should be considered an error
            @param {Boolean} [cfg.expectMultipart] Whether to expect the response to be a multipart response
        @return {Object} XHR if called in a synchronous way (in other words no callback)
        */
        sendRequest: function (cfg) {
            this.log("sendRequest");
            var fullUrl = this.endpoint + cfg.url,
                headers = {},
                prop
            ;

            // respect absolute URLs passed in
            if (cfg.url.indexOf("http") === 0) {
                fullUrl = cfg.url;
            }

            // add extended LMS-specified values to the params
            if (this.extended !== null) {
                cfg.params = cfg.params || {};

                for (prop in this.extended) {
                    if (this.extended.hasOwnProperty(prop)) {
                        // don't overwrite cfg.params values that have already been added to the request with our extended params
                        if (! cfg.params.hasOwnProperty(prop)) {
                            if (this.extended[prop] !== null) {
                                cfg.params[prop] = this.extended[prop];
                            }
                        }
                    }
                }
            }

            // consolidate headers
            headers.Authorization = this.auth;
            if (this.version !== "0.9") {
                headers["X-Experience-API-Version"] = this.version;
            }

            for (prop in cfg.headers) {
                if (cfg.headers.hasOwnProperty(prop)) {
                    headers[prop] = cfg.headers[prop];
                }
            }

            return this._makeRequest(fullUrl, headers, cfg);
        },

        /**
        Method used to determine the LRS version

        @method about
        @param {Object} cfg Configuration object for the about request
            @param {Function} [cfg.callback] Callback to execute upon receiving a response
            @param {Object} [cfg.params] this is needed, but can be empty
        @return {Object} About which holds the version, or asyncrhonously calls a specified callback
        */
        about: function (cfg) {
            this.log("about");
            var requestCfg,
                requestResult,
                callbackWrapper;

            cfg = cfg || {};

            requestCfg = {
                url: "about",
                method: "GET",
                params: {}
            };
            if (typeof cfg.callback !== "undefined") {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err === null) {
                        result = TinCan.About.fromJSON(xhr.responseText);
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }

            requestResult = this.sendRequest(requestCfg);

            if (callbackWrapper) {
                return;
            }

            if (requestResult.err === null) {
                requestResult.xhr = TinCan.About.fromJSON(requestResult.xhr.responseText);
            }
            return requestResult;
        },

        /**
        Save a statement, when used from a browser sends to the endpoint using the RESTful interface.
        Use a callback to make the call asynchronous.

        @method saveStatement
        @param {TinCan.Statement} statement to send
        @param {Object} [cfg] Configuration used when saving
            @param {Function} [cfg.callback] Callback to execute on completion
        */
        saveStatement: function (stmt, cfg) {
            this.log("saveStatement");
            var requestCfg = {
                    url: "statements",
                    headers: {}
                },
                versionedStatement,
                requestAttachments = [],
                boundary,
                i;

            cfg = cfg || {};

            try {
                versionedStatement = stmt.asVersion( this.version );
            }
            catch (ex) {
                if (this.allowFail) {
                    this.log("[warning] statement could not be serialized in version (" + this.version + "): " + ex);
                    if (typeof cfg.callback !== "undefined") {
                        cfg.callback(null, null);
                        return;
                    }
                    return {
                        err: null,
                        xhr: null
                    };
                }

                this.log("[error] statement could not be serialized in version (" + this.version + "): " + ex);
                if (typeof cfg.callback !== "undefined") {
                    cfg.callback(ex, null);
                    return;
                }
                return {
                    err: ex,
                    xhr: null
                };
            }

            if (versionedStatement.hasOwnProperty("attachments") && stmt.hasAttachmentWithContent()) {
                boundary = this._getBoundary();

                requestCfg.headers["Content-Type"] = "multipart/mixed; boundary=" + boundary;

                for (i = 0; i < stmt.attachments.length; i += 1) {
                    if (stmt.attachments[i].content !== null) {
                        requestAttachments.push(stmt.attachments[i]);
                    }
                }

                try {
                    requestCfg.data = this._getMultipartRequestData(boundary, versionedStatement, requestAttachments);
                }
                catch (ex) {
                    if (this.allowFail) {
                        this.log("[warning] multipart request data could not be created (attachments probably not supported): " + ex);
                        if (typeof cfg.callback !== "undefined") {
                            cfg.callback(null, null);
                            return;
                        }
                        return {
                            err: null,
                            xhr: null
                        };
                    }

                    this.log("[error] multipart request data could not be created (attachments probably not supported): " + ex);
                    if (typeof cfg.callback !== "undefined") {
                        cfg.callback(ex, null);
                        return;
                    }
                    return {
                        err: ex,
                        xhr: null
                    };
                }
            }
            else {
                requestCfg.headers["Content-Type"] = "application/json";
                requestCfg.data = JSON.stringify(versionedStatement);
            }
            if (stmt.id !== null) {
                requestCfg.method = "PUT";
                requestCfg.params = {
                    statementId: stmt.id
                };
            }
            else {
                requestCfg.method = "POST";
            }

            if (typeof cfg.callback !== "undefined") {
                requestCfg.callback = cfg.callback;
            }

            return this.sendRequest(requestCfg);
        },

        /**
        Retrieve a statement, when used from a browser sends to the endpoint using the RESTful interface.

        @method retrieveStatement
        @param {String} ID of statement to retrieve
        @param {Object} [cfg] Configuration options
            @param {Object} [cfg.params] Query parameters
                @param {Boolean} [cfg.params.attachments] Include attachments in multipart response or don't (default: false)
            @param {Function} [cfg.callback] Callback to execute on completion
        @return {TinCan.Statement} Statement retrieved
        */
        retrieveStatement: function (stmtId, cfg) {
            this.log("retrieveStatement");
            var requestCfg,
                requestResult,
                callbackWrapper,
                lrs = this;

            cfg = cfg || {};
            cfg.params = cfg.params || {};

            requestCfg = {
                url: "statements",
                method: "GET",
                params: {
                    statementId: stmtId
                }
            };
            if (cfg.params.attachments) {
                requestCfg.params.attachments = true;
                requestCfg.expectMultipart = true;
            }
            if (typeof cfg.callback !== "undefined") {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err === null) {
                        result = lrs._processGetStatementResult(xhr, cfg.params);
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }

            requestResult = this.sendRequest(requestCfg);
            if (! callbackWrapper) {
                requestResult.statement = null;
                if (requestResult.err === null) {
                    requestResult.statement = lrs._processGetStatementResult(requestResult.xhr, cfg.params);
                }
            }

            return requestResult;
        },

        /**
        Retrieve a voided statement, when used from a browser sends to the endpoint using the RESTful interface.

        @method retrieveVoidedStatement
        @param {String} ID of voided statement to retrieve
        @param {Object} [cfg] Configuration options
            @param {Object} [cfg.params] Query parameters
                @param {Boolean} [cfg.params.attachments] Include attachments in multipart response or don't (default: false)
            @param {Function} [cfg.callback] Callback to execute on completion
        @return {TinCan.Statement} Statement retrieved
        */
        retrieveVoidedStatement: function (stmtId, cfg) {
            this.log("retrieveVoidedStatement");
            var requestCfg,
                requestResult,
                callbackWrapper,
                lrs = this;

            cfg = cfg || {};
            cfg.params = cfg.params || {};

            requestCfg = {
                url: "statements",
                method: "GET",
                params: {}
            };
            if (this.version === "0.9" || this.version === "0.95") {
                requestCfg.params.statementId = stmtId;
            }
            else {
                requestCfg.params.voidedStatementId = stmtId;
                if (cfg.params.attachments) {
                    requestCfg.params.attachments = true;
                    requestCfg.expectMultipart = true;
                }
            }

            if (typeof cfg.callback !== "undefined") {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err === null) {
                        result = lrs._processGetStatementResult(xhr, cfg.params);
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }

            requestResult = this.sendRequest(requestCfg);
            if (! callbackWrapper) {
                requestResult.statement = null;
                if (requestResult.err === null) {
                    requestResult.statement = lrs._processGetStatementResult(requestResult.xhr, cfg.params);
                }
            }

            return requestResult;
        },

        /**
        Save a set of statements, when used from a browser sends to the endpoint using the RESTful interface.
        Use a callback to make the call asynchronous.

        @method saveStatements
        @param {Array} Array of statements or objects convertable to statements
        @param {Object} [cfg] Configuration used when saving
            @param {Function} [cfg.callback] Callback to execute on completion
        */
        saveStatements: function (stmts, cfg) {
            this.log("saveStatements");
            var requestCfg = {
                    url: "statements",
                    method: "POST",
                    headers: {}
                },
                versionedStatement,
                versionedStatements = [],
                requestAttachments = [],
                boundary,
                i,
                j;

            cfg = cfg || {};

            if (stmts.length === 0) {
                if (typeof cfg.callback !== "undefined") {
                    cfg.callback(new Error("no statements"), null);
                    return;
                }
                return {
                    err: new Error("no statements"),
                    xhr: null
                };
            }

            for (i = 0; i < stmts.length; i += 1) {
                try {
                    versionedStatement = stmts[i].asVersion( this.version );
                }
                catch (ex) {
                    if (this.allowFail) {
                        this.log("[warning] statement could not be serialized in version (" + this.version + "): " + ex);
                        if (typeof cfg.callback !== "undefined") {
                            cfg.callback(null, null);
                            return;
                        }
                        return {
                            err: null,
                            xhr: null
                        };
                    }

                    this.log("[error] statement could not be serialized in version (" + this.version + "): " + ex);
                    if (typeof cfg.callback !== "undefined") {
                        cfg.callback(ex, null);
                        return;
                    }
                    return {
                        err: ex,
                        xhr: null
                    };
                }

                if (stmts[i].hasAttachmentWithContent()) {
                    for (j = 0; j < stmts[i].attachments.length; j += 1) {
                        if (stmts[i].attachments[j].content !== null) {
                            requestAttachments.push(stmts[i].attachments[j]);
                        }
                    }
                }

                versionedStatements.push(versionedStatement);
            }

            if (requestAttachments.length !== 0) {
                boundary = this._getBoundary();

                requestCfg.headers["Content-Type"] = "multipart/mixed; boundary=" + boundary;

                try {
                    requestCfg.data = this._getMultipartRequestData(boundary, versionedStatements, requestAttachments);
                }
                catch (ex) {
                    if (this.allowFail) {
                        this.log("[warning] multipart request data could not be created (attachments probably not supported): " + ex);
                        if (typeof cfg.callback !== "undefined") {
                            cfg.callback(null, null);
                            return;
                        }
                        return {
                            err: null,
                            xhr: null
                        };
                    }

                    this.log("[error] multipart request data could not be created (attachments probably not supported): " + ex);
                    if (typeof cfg.callback !== "undefined") {
                        cfg.callback(ex, null);
                        return;
                    }
                    return {
                        err: ex,
                        xhr: null
                    };
                }
            }
            else {
                requestCfg.headers["Content-Type"] = "application/json";
                requestCfg.data = JSON.stringify(versionedStatements);
            }

            if (typeof cfg.callback !== "undefined") {
                requestCfg.callback = cfg.callback;
            }

            return this.sendRequest(requestCfg);
        },

        /**
        Fetch a set of statements, when used from a browser sends to the endpoint using the
        RESTful interface.  Use a callback to make the call asynchronous.

        @method queryStatements
        @param {Object} [cfg] Configuration used to query
            @param {Object} [cfg.params] Query parameters
                @param {TinCan.Agent|TinCan.Group} [cfg.params.agent] Agent matches 'actor' or 'object'
                @param {TinCan.Verb|String} [cfg.params.verb] Verb (or verb ID) to query on
                @param {TinCan.Activity|String} [cfg.params.activity] Activity (or activity ID) to query on
                @param {String} [cfg.params.registration] Registration UUID
                @param {Boolean} [cfg.params.related_activities] Match related activities
                @param {Boolean} [cfg.params.related_agents] Match related agents
                @param {String} [cfg.params.since] Match statements stored since specified timestamp
                @param {String} [cfg.params.until] Match statements stored at or before specified timestamp
                @param {Integer} [cfg.params.limit] Number of results to retrieve
                @param {String} [cfg.params.format] One of "ids", "exact", "canonical" (default: "exact")
                @param {Boolean} [cfg.params.ascending] Return results in ascending order of stored time

                @param {TinCan.Agent} [cfg.params.actor] (Removed in 1.0.0, use 'agent' instead) Agent matches 'actor'
                @param {TinCan.Activity|TinCan.Agent|TinCan.Statement} [cfg.params.target] (Removed in 1.0.0, use 'activity' or 'agent' instead) Activity, Agent, or Statement matches 'object'
                @param {TinCan.Agent} [cfg.params.instructor] (Removed in 1.0.0, use 'agent' + 'related_agents' instead) Agent matches 'context:instructor'
                @param {Boolean} [cfg.params.context] (Removed in 1.0.0, use 'activity' instead) When filtering on target, include statements with matching context
                @param {Boolean} [cfg.params.authoritative] (Removed in 1.0.0) Get authoritative results
                @param {Boolean} [cfg.params.sparse] (Removed in 1.0.0, use 'format' instead) Get sparse results

            @param {Function} [cfg.callback] Callback to execute on completion
                @param {String|null} cfg.callback.err Error status or null if succcess
                @param {TinCan.StatementsResult|XHR} cfg.callback.response Receives a StatementsResult argument
        @return {Object} Request result
        */
        queryStatements: function (cfg) {
            this.log("queryStatements");
            var requestCfg,
                requestResult,
                callbackWrapper,
                lrs = this;

            cfg = cfg || {};
            cfg.params = cfg.params || {};

            //
            // if they misconfigured (possibly due to version mismatches) the
            // query then don't try to send a request at all, rather than give
            // them invalid results
            //
            try {
                requestCfg = this._queryStatementsRequestCfg(cfg);

                if (cfg.params.attachments) {
                    requestCfg.expectMultipart = true;
                }
            }
            catch (ex) {
                this.log("[error] Query statements failed - " + ex);
                if (typeof cfg.callback !== "undefined") {
                    cfg.callback(ex, {});
                }

                return {
                    err: ex,
                    statementsResult: null
                };
            }

            if (typeof cfg.callback !== "undefined") {
                callbackWrapper = function (err, xhr) {
                    var result = xhr,
                        parsedResponse,
                        boundary,
                        statements,
                        attachmentMap = {},
                        i;

                    if (err === null) {
                        if (! cfg.params.attachments) {
                            result = TinCan.StatementsResult.fromJSON(xhr.responseText);
                        }
                        else {
                            boundary = xhr.getResponseHeader("Content-Type").split("boundary=")[1];

                            parsedResponse = lrs._parseMultipart(boundary, xhr.response);
                            statements = JSON.parse(parsedResponse[0].body);
                            for (i = 1; i < parsedResponse.length; i += 1) {
                                attachmentMap[parsedResponse[i].headers["X-Experience-API-Hash"]] = parsedResponse[i].body;
                            }

                            lrs._assignAttachmentContent(statements.statements, attachmentMap);
                            result = new TinCan.StatementsResult({ statements: statements.statements });

                            for (i = 0; i < result.statements.length; i += 1) {
                                if (! (result.statements[i] instanceof TinCan.Statement)) {
                                    result.statements[i] = new TinCan.Statement(result.statements[i]);
                                }
                            }
                        }
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }

            requestResult = this.sendRequest(requestCfg);
            requestResult.config = requestCfg;

            if (! callbackWrapper) {
                requestResult.statementsResult = null;
                if (requestResult.err === null) {
                    requestResult.statementsResult = TinCan.StatementsResult.fromJSON(requestResult.xhr.responseText);
                }
            }

            return requestResult;
        },

        /**
        Build a request config object that can be passed to sendRequest() to make a query request

        @method _queryStatementsRequestCfg
        @private
        @param {Object} [cfg] See configuration for {{#crossLink "TinCan.LRS/queryStatements"}}{{/crossLink}}
        @return {Object} Request configuration object
        */
        _queryStatementsRequestCfg: function (cfg) {
            this.log("_queryStatementsRequestCfg");
            var params = {},
                returnCfg = {
                    url: "statements",
                    method: "GET",
                    params: params
                },
                jsonProps = [
                    "agent",
                    "actor",
                    "object",
                    "instructor"
                ],
                idProps = [
                    "verb",
                    "activity"
                ],
                valProps = [
                    "registration",
                    "context",
                    "since",
                    "until",
                    "limit",
                    "authoritative",
                    "sparse",
                    "ascending",
                    "related_activities",
                    "related_agents",
                    "format",
                    "attachments"
                ],
                i,
                prop,
                //
                // list of parameters that are supported in all versions (supported by
                // this library) of the spec
                //
                universal = {
                    verb: true,
                    registration: true,
                    since: true,
                    until: true,
                    limit: true,
                    ascending: true
                },
                //
                // future proofing here, "supported" is an object so that
                // in the future we can support a "deprecated" list to
                // throw warnings, hopefully the spec uses deprecation phases
                // for the removal of these things
                //
                compatibility = {
                    "0.9": {
                        supported: {
                            actor: true,
                            instructor: true,
                            target: true,
                            object: true,
                            context: true,
                            authoritative: true,
                            sparse: true
                        }
                    },
                    "1.0.0": {
                        supported: {
                            agent: true,
                            activity: true,
                            related_activities: true,
                            related_agents: true,
                            format: true,
                            attachments: true
                        }
                    }
                };

            compatibility["0.95"] = compatibility["0.9"];
            compatibility["1.0.1"] = compatibility["1.0.0"];
            compatibility["1.0.2"] = compatibility["1.0.0"];

            if (cfg.params.hasOwnProperty("target")) {
                cfg.params.object = cfg.params.target;
            }

            //
            // check compatibility tables, either the configured parameter is in
            // the universal list or the specific version, if not then throw an
            // error which at least for .queryStatements will prevent the request
            // and potentially alert the user
            //
            for (prop in cfg.params) {
                if (cfg.params.hasOwnProperty(prop)) {
                    if (typeof universal[prop] === "undefined" && typeof compatibility[this.version].supported[prop] === "undefined") {
                        throw "Unrecognized query parameter configured: " + prop;
                    }
                }
            }

            //
            // getting here means that all parameters are valid for this version
            // to make handling the output formats easier
            //

            for (i = 0; i < jsonProps.length; i += 1) {
                if (typeof cfg.params[jsonProps[i]] !== "undefined") {
                    params[jsonProps[i]] = JSON.stringify(cfg.params[jsonProps[i]].asVersion(this.version));
                }
            }

            for (i = 0; i < idProps.length; i += 1) {
                if (typeof cfg.params[idProps[i]] !== "undefined") {
                    if (typeof cfg.params[idProps[i]].id === "undefined") {
                        params[idProps[i]] = cfg.params[idProps[i]];
                    }
                    else {
                        params[idProps[i]] = cfg.params[idProps[i]].id;
                    }
                }
            }

            for (i = 0; i < valProps.length; i += 1) {
                if (typeof cfg.params[valProps[i]] !== "undefined" && cfg.params[valProps[i]] !== null) {
                    params[valProps[i]] = cfg.params[valProps[i]];
                }
            }

            return returnCfg;
        },

        /**
        Assigns attachment content to the correct attachment to create a StatementsResult object that is sent
        to the callback of queryStatements()

        @method _assignAttachmentContent
        @private
        @param {Array} [stmts] Array of TinCan.Statement JSON objects
        @param {Object} [attachmentMap] Map of the content to place into its attachment
        @return {Array} Array of TinCan.Statement JSON objects with correctly assigned attachment content
        */
        _assignAttachmentContent: function (stmts, attachmentMap) {
            var i,
                j;

            for (i = 0; i < stmts.length; i += 1) {
                if (stmts[i].hasOwnProperty("attachments") && stmts[i].attachments !== null) {
                    for (j = 0; j < stmts[i].attachments.length; j += 1) {
                        if (attachmentMap.hasOwnProperty(stmts[i].attachments[j].sha2)) {
                            stmts[i].attachments[j].content = attachmentMap[stmts[i].attachments[j].sha2];
                        }
                    }
                }
            }
        },

        /**
        Parses the different sections of a multipart/mixed response

        @method _parseMultipart
        @private
        @param {String} [boundary] Boundary used to mark off the sections of the response
        @param {ArrayBuffer} [response] Body of the response
        @return {Array} Array of objects containing the parsed headers and body of each part
        */
        _parseMultipart: function (boundary, response) {
            /* global Uint8Array */
            var __boundary = "--" + boundary,
                byteArray,
                bodyEncodedInString,
                fullBodyEnd,
                sliceStart,
                sliceEnd,
                headerStart,
                headerEnd,
                bodyStart,
                bodyEnd,
                headers,
                body,
                parts = [],
                CRLF = 2;

            //
            // treating the reponse as a stream of bytes and assuming that headers
            // and related mime boundaries are all US-ASCII (which is a safe assumption)
            // allows us to treat the whole response as a string when looking for offsets
            // but then slice on the raw array buffer
            //
            byteArray = new Uint8Array(response);
            bodyEncodedInString = this.__uint8ToString(byteArray);

            fullBodyEnd = bodyEncodedInString.indexOf(__boundary + "--");

            sliceStart = bodyEncodedInString.indexOf(__boundary);
            while (sliceStart !== -1) {
                sliceEnd = bodyEncodedInString.indexOf(__boundary, sliceStart + __boundary.length);

                headerStart = sliceStart + __boundary.length + CRLF;
                headerEnd = bodyEncodedInString.indexOf("\r\n\r\n", sliceStart);
                bodyStart = headerEnd + CRLF + CRLF;
                bodyEnd = sliceEnd - 2;

                headers = this._parseHeaders(
                    this.__uint8ToString(
                        new Uint8Array( response.slice(headerStart, headerEnd) )
                    )
                );
                body = response.slice(bodyStart, bodyEnd);

                //
                // we know the first slice is the statement, and we know it is a string in UTF-8 (spec requirement)
                //
                if (parts.length === 0) {
                    body = TinCan.Utils.stringFromArrayBuffer(body);
                }

                parts.push(
                    {
                        headers: headers,
                        body: body
                    }
                );

                if (sliceEnd === fullBodyEnd) {
                    sliceStart = -1;
                }
                else {
                    sliceStart = sliceEnd;
                }
            }

            return parts;
        },

        //
        // implemented as a function to avoid 'RangeError: Maximum call stack size exceeded'
        // when calling .fromCharCode on the full byteArray which results in a too long
        // argument list for large arrays
        //
        __uint8ToString: function (byteArray) {
            var result = "",
                len = byteArray.byteLength,
                i;

            for (i = 0; i < len; i += 1) {
                result += String.fromCharCode(byteArray[i]);
            }
            return result;
        },

        /**
        Parses the headers of a multipart/mixed response section

        @method _parseHeaders
        @private
        @param {String} [rawHeaders] String containing all the headers
        @return {Object} Map of the headers
        */
        _parseHeaders: function (rawHeaders) {
            var headers = {},
                headerList,
                key,
                h,
                i;

            headerList = rawHeaders.split("\n");
            for (i = 0; i < headerList.length; i += 1) {
                h = headerList[i].split(":", 2);

                if (h[1] !== null) {
                    headers[h[0]] = h[1].replace(/^\s+|\s+$/g, "");

                    key = h[0];
                }
                else {
                    if (h[0].substring(0, 1) === "\t") {
                        headers[h[0]] = h[1].replace(/^\s+|\s+$/g, "");
                    }
                }
            }

            return headers;
        },

        /**
        Fetch more statements from a previous query, when used from a browser sends to the endpoint using the
        RESTful interface.  Use a callback to make the call asynchronous.

        @method moreStatements
        @param {Object} [cfg] Configuration used to query
            @param {String} [cfg.url] More URL
            @param {Function} [cfg.callback] Callback to execute on completion
                @param {String|null} cfg.callback.err Error status or null if succcess
                @param {TinCan.StatementsResult|XHR} cfg.callback.response Receives a StatementsResult argument
        @return {Object} Request result
        */
        moreStatements: function (cfg) {
            this.log("moreStatements: " + cfg.url);
            var requestCfg,
                requestResult,
                callbackWrapper,
                parsedURL,
                serverRoot;

            cfg = cfg || {};

            // to support our interface (to support IE) we need to break apart
            // the more URL query params so that the request can be made properly later
            parsedURL = TinCan.Utils.parseURL(cfg.url, { allowRelative: true });

            // Respect a more URL that is relative to either the server root
            // or endpoint (though only the former is allowed in the spec)
            serverRoot = TinCan.Utils.getServerRoot(this.endpoint);
            if (parsedURL.path.indexOf("/statements") === 0){
                parsedURL.path = this.endpoint.replace(serverRoot, "") + parsedURL.path;
                this.log("converting non-standard more URL to " + parsedURL.path);
            }

            // The more relative URL might not start with a slash, add it if not
            if (parsedURL.path.indexOf("/") !== 0) {
                parsedURL.path = "/" + parsedURL.path;
            }

            requestCfg = {
                method: "GET",
                // For arbitrary more URLs to work, we need to make the URL absolute here
                url: serverRoot + parsedURL.path,
                params: parsedURL.params
            };
            if (typeof cfg.callback !== "undefined") {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err === null) {
                        result = TinCan.StatementsResult.fromJSON(xhr.responseText);
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }

            requestResult = this.sendRequest(requestCfg);
            requestResult.config = requestCfg;

            if (! callbackWrapper) {
                requestResult.statementsResult = null;
                if (requestResult.err === null) {
                    requestResult.statementsResult = TinCan.StatementsResult.fromJSON(requestResult.xhr.responseText);
                }
            }

            return requestResult;
        },

        /**
        Retrieve a state value, when used from a browser sends to the endpoint using the RESTful interface.

        @method retrieveState
        @param {String} key Key of state to retrieve
        @param {Object} cfg Configuration options
            @param {TinCan.Activity} cfg.activity Activity in document identifier
            @param {TinCan.Agent} cfg.agent Agent in document identifier
            @param {String} [cfg.registration] Registration
            @param {Function} [cfg.callback] Callback to execute on completion
                @param {Object|Null} cfg.callback.error
                @param {TinCan.State|null} cfg.callback.result null if state is 404
            @param {Object} [cfg.requestHeaders] Object containing additional headers to add to request
        @return {TinCan.State|Object} TinCan.State retrieved when synchronous, or result from sendRequest
        */
        retrieveState: function (key, cfg) {
            this.log("retrieveState");
            var requestParams = {},
                requestCfg = {},
                requestResult,
                callbackWrapper,
                requestHeaders,
                self = this;

            requestHeaders = cfg.requestHeaders || {};

            requestParams = {
                stateId: key,
                activityId: cfg.activity.id
            };
            if (this.version === "0.9") {
                requestParams.actor = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            else {
                requestParams.agent = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            if ((typeof cfg.registration !== "undefined") && (cfg.registration !== null)) {
                if (this.version === "0.9") {
                    requestParams.registrationId = cfg.registration;
                }
                else {
                    requestParams.registration = cfg.registration;
                }
            }

            requestCfg = {
                url: "activities/state",
                method: "GET",
                params: requestParams,
                ignore404: true,
                headers: requestHeaders
            };

            if (typeof cfg.callback !== "undefined") {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err === null) {
                        if (xhr.status === 404) {
                            result = null;
                        }
                        else {
                            result = new TinCan.State(
                                {
                                    id: key,
                                    contents: xhr.responseText
                                }
                            );
                            if (typeof xhr.getResponseHeader !== "undefined" && xhr.getResponseHeader("ETag") !== null && xhr.getResponseHeader("ETag") !== "") {
                                result.etag = xhr.getResponseHeader("ETag");
                            }
                            else {
                                //
                                // either XHR didn't have getResponseHeader (probably cause it is an IE
                                // XDomainRequest object which doesn't) or not populated by LRS so create
                                // the hash ourselves
                                //
                                // the LRS is responsible for quoting the Etag value so we need to mimic
                                // that behavior here as well
                                //
                                result.etag = "\"" + TinCan.Utils.getSHA1String(xhr.responseText) + "\"";
                            }

                            if (typeof xhr.contentType !== "undefined") {
                                // most likely an XDomainRequest which has .contentType,
                                // for the ones that it supports
                                result.contentType = xhr.contentType;
                            }
                            else if (typeof xhr.getResponseHeader !== "undefined" && xhr.getResponseHeader("Content-Type") !== null && xhr.getResponseHeader("Content-Type") !== "") {
                                result.contentType = xhr.getResponseHeader("Content-Type");
                            }

                            if (TinCan.Utils.isApplicationJSON(result.contentType)) {
                                try {
                                    result.contents = JSON.parse(result.contents);
                                } catch (ex) {
                                    self.log("retrieveState - failed to deserialize JSON: " + ex);
                                }
                            }
                        }
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }

            requestResult = this.sendRequest(requestCfg);
            if (! callbackWrapper) {
                requestResult.state = null;
                if (requestResult.err === null && requestResult.xhr.status !== 404) {
                    requestResult.state = new TinCan.State(
                        {
                            id: key,
                            contents: requestResult.xhr.responseText
                        }
                    );
                    if (typeof requestResult.xhr.getResponseHeader !== "undefined" && requestResult.xhr.getResponseHeader("ETag") !== null && requestResult.xhr.getResponseHeader("ETag") !== "") {
                        requestResult.state.etag = requestResult.xhr.getResponseHeader("ETag");
                    }
                    else {
                        //
                        // either XHR didn't have getResponseHeader (probably cause it is an IE
                        // XDomainRequest object which doesn't) or not populated by LRS so create
                        // the hash ourselves
                        //
                        // the LRS is responsible for quoting the Etag value so we need to mimic
                        // that behavior here as well
                        //
                        requestResult.state.etag = "\"" + TinCan.Utils.getSHA1String(requestResult.xhr.responseText) + "\"";
                    }
                    if (typeof requestResult.xhr.contentType !== "undefined") {
                        // most likely an XDomainRequest which has .contentType
                        // for the ones that it supports
                        requestResult.state.contentType = requestResult.xhr.contentType;
                    }
                    else if (typeof requestResult.xhr.getResponseHeader !== "undefined" && requestResult.xhr.getResponseHeader("Content-Type") !== null && requestResult.xhr.getResponseHeader("Content-Type") !== "") {
                        requestResult.state.contentType = requestResult.xhr.getResponseHeader("Content-Type");
                    }
                    if (TinCan.Utils.isApplicationJSON(requestResult.state.contentType)) {
                        try {
                            requestResult.state.contents = JSON.parse(requestResult.state.contents);
                        } catch (ex) {
                            this.log("retrieveState - failed to deserialize JSON: " + ex);
                        }
                    }
                }
            }

            return requestResult;
        },

        /**
        Retrieve the list of IDs for a state, when used from a browser sends to the endpoint using the RESTful interface.

        @method retrieveStateIds
        @param {Object} cfg Configuration options
            @param {TinCan.Activity} cfg.activity Activity in document identifier
            @param {TinCan.Agent} cfg.agent Agent in document identifier
            @param {String} [cfg.registration] Registration
            @param {Function} [cfg.callback] Callback to execute on completion
            @param {String} [cfg.since] Match activity profiles saved since given timestamp
            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request
        @return {Object} requestResult Request result
        */
        retrieveStateIds: function (cfg) {
            this.log("retrieveStateIds");
            var requestParams = {},
                requestCfg,
                requestHeaders,
                requestResult,
                callbackWrapper;

            cfg = cfg || {};
            requestHeaders = cfg.requestHeaders || {};

            requestParams.activityId = cfg.activity.id;
            if (this.version === "0.9") {
                requestParams.actor = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            else {
                requestParams.agent = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            if ((typeof cfg.registration !== "undefined") && (cfg.registration !== null)) {
                if (this.version === "0.9") {
                    requestParams.registrationId = cfg.registration;
                }
                else {
                    requestParams.registration = cfg.registration;
                }
            }

            requestCfg = {
                url: "activities/state",
                method: "GET",
                params: requestParams,
                headers: requestHeaders,
                ignore404: true
            };
            if (typeof cfg.callback !== "undefined") {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err !== null) {
                        cfg.callback(err, result);
                        return;
                    }

                    if (xhr.status === 404) {
                        result = [];
                    }
                    else {
                        try {
                            result = JSON.parse(xhr.responseText);
                        }
                        catch (ex) {
                            err = "Response JSON parse error: " + ex;
                        }
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }
            if (typeof cfg.since !== "undefined") {
                requestCfg.params.since = cfg.since;
            }

            requestResult = this.sendRequest(requestCfg);
            if (! callbackWrapper) {
                requestResult.profileIds = null;
                if (requestResult.err !== null) {
                    return requestResult;
                }

                if (requestResult.xhr.status === 404) {
                    requestResult.profileIds = [];
                }
                else {
                    try {
                        requestResult.profileIds = JSON.parse(requestResult.xhr.responseText);
                    }
                    catch (ex) {
                        requestResult.err = "retrieveStateIds - JSON parse error: " + ex;
                    }
                }
            }
            return requestResult;
        },

        /**
        Save a state value, when used from a browser sends to the endpoint using the RESTful interface.

        @method saveState
        @param {String} key Key of state to save
        @param val Value to be stored
        @param {Object} cfg Configuration options
            @param {TinCan.Activity} cfg.activity Activity in document identifier
            @param {TinCan.Agent} cfg.agent Agent in document identifier
            @param {String} [cfg.registration] Registration
            @param {String} [cfg.lastSHA1] SHA1 of the previously seen existing state
            @param {String} [cfg.contentType] Content-Type to specify in headers (defaults to 'application/octet-stream')
            @param {String} [cfg.method] Method to use. Default: PUT
            @param {Function} [cfg.callback] Callback to execute on completion
            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request
        */
        saveState: function (key, val, cfg) {
            this.log("saveState");
            var requestParams,
                requestCfg,
                requestHeaders;

            requestHeaders = cfg.requestHeaders || {};

            if (typeof cfg.contentType === "undefined") {
                cfg.contentType = "application/octet-stream";
            }
            requestHeaders["Content-Type"] = cfg.contentType;

            if (typeof val === "object" && TinCan.Utils.isApplicationJSON(cfg.contentType)) {
                val = JSON.stringify(val);
            }

            if (typeof cfg.method === "undefined" || cfg.method !== "POST") {
                cfg.method = "PUT";
            }

            requestParams = {
                stateId: key,
                activityId: cfg.activity.id
            };
            if (this.version === "0.9") {
                requestParams.actor = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            else {
                requestParams.agent = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            if ((typeof cfg.registration !== "undefined") && (cfg.registration !== null)) {
                if (this.version === "0.9") {
                    requestParams.registrationId = cfg.registration;
                }
                else {
                    requestParams.registration = cfg.registration;
                }
            }

            requestCfg = {
                url: "activities/state",
                method: cfg.method,
                params: requestParams,
                data: val,
                headers: requestHeaders
            };

            if (typeof cfg.callback !== "undefined") {
                requestCfg.callback = cfg.callback;
            }
            if (typeof cfg.lastSHA1 !== "undefined" && cfg.lastSHA1 !== null) {
                requestCfg.headers["If-Match"] = cfg.lastSHA1;
            }

            return this.sendRequest(requestCfg);
        },

        /**
        Drop a state value or all of the state, when used from a browser sends to the endpoint using the RESTful interface.

        @method dropState
        @param {String|null} key Key of state to delete, or null for all
        @param {Object} cfg Configuration options
            @param {TinCan.Activity} cfg.activity Activity in document identifier
            @param {TinCan.Agent} cfg.agent Agent in document identifier
            @param {String} [cfg.registration] Registration
            @param {Function} [cfg.callback] Callback to execute on completion
            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request
        */
        dropState: function (key, cfg) {
            this.log("dropState");
            var requestParams,
                requestCfg,
                requestHeaders;

            requestHeaders = cfg.requestHeaders || {};

            requestParams = {
                activityId: cfg.activity.id
            };
            if (this.version === "0.9") {
                requestParams.actor = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            else {
                requestParams.agent = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            if (key !== null) {
                requestParams.stateId = key;
            }
            if ((typeof cfg.registration !== "undefined") && (cfg.registration !== null)) {
                if (this.version === "0.9") {
                    requestParams.registrationId = cfg.registration;
                }
                else {
                    requestParams.registration = cfg.registration;
                }
            }

            requestCfg = {
                url: "activities/state",
                method: "DELETE",
                params: requestParams,
                headers: requestHeaders
            };

            if (typeof cfg.callback !== "undefined") {
                requestCfg.callback = cfg.callback;
            }

            return this.sendRequest(requestCfg);
        },

        /**
        Retrieve an activity, when used from a browser sends to the endpoint using the RESTful interface.

        @method retrieveActivity
        @param {String} activityId id of the Activity to retrieve
        @param {Object} cfg Configuration options
            @param {Function} [cfg.callback] Callback to execute on completion
            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request
        @return {Object} Value retrieved
        */
        retrieveActivity: function (activityId, cfg) {
            this.log("retrieveActivity");
            var requestCfg = {},
                requestResult,
                callbackWrapper,
                requestHeaders;

            requestHeaders = cfg.requestHeaders || {};

            requestCfg = {
                url: "activities",
                method: "GET",
                params: {
                    activityId: activityId
                },
                ignore404: true,
                headers: requestHeaders
            };

            if (typeof cfg.callback !== "undefined") {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err === null) {
                        //
                        // a 404 really shouldn't happen because the LRS can dynamically
                        // build the response based on what has been passed to it, but
                        // don't have the client fail in the condition that it does, because
                        // we can do the same thing
                        //
                        if (xhr.status === 404) {
                            result = new TinCan.Activity(
                                {
                                    id: activityId
                                }
                            );
                        }
                        else {
                            result = TinCan.Activity.fromJSON(xhr.responseText);
                        }
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }

            requestResult = this.sendRequest(requestCfg);
            if (! callbackWrapper) {
                requestResult.activity = null;
                if (requestResult.err === null) {
                    if (requestResult.xhr.status === 404) {
                        requestResult.activity = new TinCan.Activity(
                            {
                                id: activityId
                            }
                        );
                    }
                    else {
                        requestResult.activity = TinCan.Activity.fromJSON(requestResult.xhr.responseText);
                    }
                }
            }

            return requestResult;
        },

        /**
        Retrieve an activity profile value, when used from a browser sends to the endpoint using the RESTful interface.

        @method retrieveActivityProfile
        @param {String} key Key of activity profile to retrieve
        @param {Object} cfg Configuration options
            @param {TinCan.Activity} cfg.activity Activity in document identifier
            @param {Function} [cfg.callback] Callback to execute on completion
            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request
        @return {Object} Value retrieved
        */
        retrieveActivityProfile: function (key, cfg) {
            this.log("retrieveActivityProfile");
            var requestCfg = {},
                requestResult,
                callbackWrapper,
                requestHeaders,
                self = this;

            requestHeaders = cfg.requestHeaders || {};

            requestCfg = {
                url: "activities/profile",
                method: "GET",
                params: {
                    profileId: key,
                    activityId: cfg.activity.id
                },
                ignore404: true,
                headers: requestHeaders
            };

            if (typeof cfg.callback !== "undefined") {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err === null) {
                        if (xhr.status === 404) {
                            result = null;
                        }
                        else {
                            result = new TinCan.ActivityProfile(
                                {
                                    id: key,
                                    activity: cfg.activity,
                                    contents: xhr.responseText
                                }
                            );
                            if (typeof xhr.getResponseHeader !== "undefined" && xhr.getResponseHeader("ETag") !== null && xhr.getResponseHeader("ETag") !== "") {
                                result.etag = xhr.getResponseHeader("ETag");
                            }
                            else {
                                //
                                // either XHR didn't have getResponseHeader (probably cause it is an IE
                                // XDomainRequest object which doesn't) or not populated by LRS so create
                                // the hash ourselves
                                //
                                // the LRS is responsible for quoting the Etag value so we need to mimic
                                // that behavior here as well
                                //
                                result.etag = "\"" + TinCan.Utils.getSHA1String(xhr.responseText) + "\"";
                            }
                            if (typeof xhr.contentType !== "undefined") {
                                // most likely an XDomainRequest which has .contentType
                                // for the ones that it supports
                                result.contentType = xhr.contentType;
                            }
                            else if (typeof xhr.getResponseHeader !== "undefined" && xhr.getResponseHeader("Content-Type") !== null && xhr.getResponseHeader("Content-Type") !== "") {
                                result.contentType = xhr.getResponseHeader("Content-Type");
                            }
                            if (TinCan.Utils.isApplicationJSON(result.contentType)) {
                                try {
                                    result.contents = JSON.parse(result.contents);
                                } catch (ex) {
                                    self.log("retrieveActivityProfile - failed to deserialize JSON: " + ex);
                                }
                            }
                        }
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }

            requestResult = this.sendRequest(requestCfg);
            if (! callbackWrapper) {
                requestResult.profile = null;
                if (requestResult.err === null && requestResult.xhr.status !== 404) {
                    requestResult.profile = new TinCan.ActivityProfile(
                        {
                            id: key,
                            activity: cfg.activity,
                            contents: requestResult.xhr.responseText
                        }
                    );
                    if (typeof requestResult.xhr.getResponseHeader !== "undefined" && requestResult.xhr.getResponseHeader("ETag") !== null && requestResult.xhr.getResponseHeader("ETag") !== "") {
                        requestResult.profile.etag = requestResult.xhr.getResponseHeader("ETag");
                    }
                    else {
                        //
                        // either XHR didn't have getResponseHeader (probably cause it is an IE
                        // XDomainRequest object which doesn't) or not populated by LRS so create
                        // the hash ourselves
                        //
                        // the LRS is responsible for quoting the Etag value so we need to mimic
                        // that behavior here as well
                        //
                        requestResult.profile.etag = "\"" + TinCan.Utils.getSHA1String(requestResult.xhr.responseText) + "\"";
                    }
                    if (typeof requestResult.xhr.contentType !== "undefined") {
                        // most likely an XDomainRequest which has .contentType
                        // for the ones that it supports
                        requestResult.profile.contentType = requestResult.xhr.contentType;
                    }
                    else if (typeof requestResult.xhr.getResponseHeader !== "undefined" && requestResult.xhr.getResponseHeader("Content-Type") !== null && requestResult.xhr.getResponseHeader("Content-Type") !== "") {
                        requestResult.profile.contentType = requestResult.xhr.getResponseHeader("Content-Type");
                    }
                    if (TinCan.Utils.isApplicationJSON(requestResult.profile.contentType)) {
                        try {
                            requestResult.profile.contents = JSON.parse(requestResult.profile.contents);
                        } catch (ex) {
                            this.log("retrieveActivityProfile - failed to deserialize JSON: " + ex);
                        }
                    }
                }
            }

            return requestResult;
        },

        /**
        Retrieve the list of IDs for an activity profile, when used from a browser sends to the endpoint using the RESTful interface.

        @method retrieveActivityProfileIds
        @param {Object} cfg Configuration options
            @param {TinCan.Activity} cfg.activity Activity in document identifier
            @param {Function} [cfg.callback] Callback to execute on completion
            @param {String} [cfg.since] Match activity profiles saved since given timestamp
            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request
        @return {Array} List of ids for this Activity profile
        */
        retrieveActivityProfileIds: function (cfg) {
            this.log("retrieveActivityProfileIds");
            var requestCfg,
                requestHeaders,
                requestResult,
                callbackWrapper;

            cfg = cfg || {};
            requestHeaders = cfg.requestHeaders || {};

            requestCfg = {
                url: "activities/profile",
                method: "GET",
                params: {
                    activityId: cfg.activity.id
                },
                headers: requestHeaders,
                ignore404: true
            };
            if (typeof cfg.callback !== "undefined") {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err !== null) {
                        cfg.callback(err, result);
                        return;
                    }

                    if (xhr.status === 404) {
                        result = [];
                    }
                    else {
                        try {
                            result = JSON.parse(xhr.responseText);
                        }
                        catch (ex) {
                            err = "Response JSON parse error: " + ex;
                        }
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }
            if (typeof cfg.since !== "undefined") {
                requestCfg.params.since = cfg.since;
            }

            requestResult = this.sendRequest(requestCfg);
            if (! callbackWrapper) {
                requestResult.profileIds = null;
                if (requestResult.err !== null) {
                    return requestResult;
                }

                if (requestResult.xhr.status === 404) {
                    requestResult.profileIds = [];
                }
                else {
                    try {
                        requestResult.profileIds = JSON.parse(requestResult.xhr.responseText);
                    }
                    catch (ex) {
                        requestResult.err = "retrieveActivityProfileIds - JSON parse error: " + ex;
                    }
                }
            }
            return requestResult;
        },

        /**
        Save an activity profile value, when used from a browser sends to the endpoint using the RESTful interface.

        @method saveActivityProfile
        @param {String} key Key of activity profile to retrieve
        @param val Value to be stored
        @param {Object} cfg Configuration options
            @param {TinCan.Activity} cfg.activity Activity in document identifier
            @param {String} [cfg.lastSHA1] SHA1 of the previously seen existing profile
            @param {String} [cfg.contentType] Content-Type to specify in headers (defaults to 'application/octet-stream')
            @param {String} [cfg.method] Method to use. Default: PUT
            @param {Function} [cfg.callback] Callback to execute on completion
            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request
        */
        saveActivityProfile: function (key, val, cfg) {
            this.log("saveActivityProfile");
            var requestCfg,
                requestHeaders;

            requestHeaders = cfg.requestHeaders || {};

            if (typeof cfg.contentType === "undefined") {
                cfg.contentType = "application/octet-stream";
            }
            requestHeaders["Content-Type"] = cfg.contentType;

            if (typeof cfg.method === "undefined" || cfg.method !== "POST") {
                cfg.method = "PUT";
            }

            if (typeof val === "object" && TinCan.Utils.isApplicationJSON(cfg.contentType)) {
                val = JSON.stringify(val);
            }

            requestCfg = {
                url: "activities/profile",
                method: cfg.method,
                params: {
                    profileId: key,
                    activityId: cfg.activity.id
                },
                data: val,
                headers: requestHeaders
            };

            if (typeof cfg.callback !== "undefined") {
                requestCfg.callback = cfg.callback;
            }
            if (typeof cfg.lastSHA1 !== "undefined" && cfg.lastSHA1 !== null) {
                requestCfg.headers["If-Match"] = cfg.lastSHA1;
            }
            else {
                requestCfg.headers["If-None-Match"] = "*";
            }

            return this.sendRequest(requestCfg);
        },

        /**
        Drop an activity profile value, when used from a browser sends to the endpoint using the RESTful interface. Full activity profile
        delete is not supported by the spec.

        @method dropActivityProfile
        @param {String|null} key Key of activity profile to delete
        @param {Object} cfg Configuration options
            @param {TinCan.Activity} cfg.activity Activity in document identifier
            @param {Function} [cfg.callback] Callback to execute on completion
            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request
        */
        dropActivityProfile: function (key, cfg) {
            this.log("dropActivityProfile");
            var requestParams,
                requestCfg,
                requestHeaders;

            requestHeaders = cfg.requestHeaders || {};

            requestParams = {
                profileId: key,
                activityId: cfg.activity.id
            };

            requestCfg = {
                url: "activities/profile",
                method: "DELETE",
                params: requestParams,
                headers: requestHeaders
            };

            if (typeof cfg.callback !== "undefined") {
                requestCfg.callback = cfg.callback;
            }

            return this.sendRequest(requestCfg);
        },

        /**
        Retrieve an agent profile value, when used from a browser sends to the endpoint using the RESTful interface.

        @method retrieveAgentProfile
        @param {String} key Key of agent profile to retrieve
        @param {Object} cfg Configuration options
            @param {TinCan.Agent} cfg.agent Agent in document identifier
            @param {Function} [cfg.callback] Callback to execute on completion
            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request
        @return {Object} Value retrieved
        */
        retrieveAgentProfile: function (key, cfg) {
            this.log("retrieveAgentProfile");
            var requestCfg = {},
                requestResult,
                callbackWrapper,
                requestHeaders,
                self = this;

            requestHeaders = cfg.requestHeaders || {};

            requestCfg = {
                method: "GET",
                params: {
                    profileId: key
                },
                ignore404: true,
                headers: requestHeaders
            };

            if (this.version === "0.9") {
                requestCfg.url = "actors/profile";
                requestCfg.params.actor = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            else {
                requestCfg.url = "agents/profile";
                requestCfg.params.agent = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            if (typeof cfg.callback !== "undefined") {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err === null) {
                        if (xhr.status === 404) {
                            result = null;
                        }
                        else {
                            result = new TinCan.AgentProfile(
                                {
                                    id: key,
                                    agent: cfg.agent,
                                    contents: xhr.responseText
                                }
                            );
                            if (typeof xhr.getResponseHeader !== "undefined" && xhr.getResponseHeader("ETag") !== null && xhr.getResponseHeader("ETag") !== "") {
                                result.etag = xhr.getResponseHeader("ETag");
                            }
                            else {
                                //
                                // either XHR didn't have getResponseHeader (probably cause it is an IE
                                // XDomainRequest object which doesn't) or not populated by LRS so create
                                // the hash ourselves
                                //
                                // the LRS is responsible for quoting the Etag value so we need to mimic
                                // that behavior here as well
                                //
                                result.etag = "\"" + TinCan.Utils.getSHA1String(xhr.responseText) + "\"";
                            }
                            if (typeof xhr.contentType !== "undefined") {
                                // most likely an XDomainRequest which has .contentType
                                // for the ones that it supports
                                result.contentType = xhr.contentType;
                            }
                            else if (typeof xhr.getResponseHeader !== "undefined" && xhr.getResponseHeader("Content-Type") !== null && xhr.getResponseHeader("Content-Type") !== "") {
                                result.contentType = xhr.getResponseHeader("Content-Type");
                            }
                            if (TinCan.Utils.isApplicationJSON(result.contentType)) {
                                try {
                                    result.contents = JSON.parse(result.contents);
                                } catch (ex) {
                                    self.log("retrieveAgentProfile - failed to deserialize JSON: " + ex);
                                }
                            }
                        }
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }

            requestResult = this.sendRequest(requestCfg);
            if (! callbackWrapper) {
                requestResult.profile = null;
                if (requestResult.err === null && requestResult.xhr.status !== 404) {
                    requestResult.profile = new TinCan.AgentProfile(
                        {
                            id: key,
                            agent: cfg.agent,
                            contents: requestResult.xhr.responseText
                        }
                    );
                    if (typeof requestResult.xhr.getResponseHeader !== "undefined" && requestResult.xhr.getResponseHeader("ETag") !== null && requestResult.xhr.getResponseHeader("ETag") !== "") {
                        requestResult.profile.etag = requestResult.xhr.getResponseHeader("ETag");
                    }
                    else {
                        //
                        // either XHR didn't have getResponseHeader (probably cause it is an IE
                        // XDomainRequest object which doesn't) or not populated by LRS so create
                        // the hash ourselves
                        //
                        // the LRS is responsible for quoting the Etag value so we need to mimic
                        // that behavior here as well
                        //
                        requestResult.profile.etag = "\"" + TinCan.Utils.getSHA1String(requestResult.xhr.responseText) + "\"";
                    }
                    if (typeof requestResult.xhr.contentType !== "undefined") {
                        // most likely an XDomainRequest which has .contentType
                        // for the ones that it supports
                        requestResult.profile.contentType = requestResult.xhr.contentType;
                    }
                    else if (typeof requestResult.xhr.getResponseHeader !== "undefined" && requestResult.xhr.getResponseHeader("Content-Type") !== null && requestResult.xhr.getResponseHeader("Content-Type") !== "") {
                        requestResult.profile.contentType = requestResult.xhr.getResponseHeader("Content-Type");
                    }
                    if (TinCan.Utils.isApplicationJSON(requestResult.profile.contentType)) {
                        try {
                            requestResult.profile.contents = JSON.parse(requestResult.profile.contents);
                        } catch (ex) {
                            this.log("retrieveAgentProfile - failed to deserialize JSON: " + ex);
                        }
                    }
                }
            }

            return requestResult;
        },

        /**
        Retrieve the list of profileIds for an agent profile, when used from a browser sends to the endpoint using the RESTful interface.

        @method retrieveAgentProfileIds
        @param {Object} cfg Configuration options
            @param {TinCan.Agent} cfg.agent Agent in document identifier
            @param {Function} [cfg.callback] Callback to execute on completion
            @param {String} [cfg.since] Match activity profiles saved since given timestamp
            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request
        @return {Array} List of profileIds for this Agent

        */
        retrieveAgentProfileIds: function (cfg) {
            this.log("retrieveAgentProfileIds");
            var requestParams = {},
                requestCfg,
                requestHeaders,
                requestResult,
                callbackWrapper;

            cfg = cfg || {};
            requestHeaders = cfg.requestHeaders || {};

            requestCfg = {
                method: "GET",
                params: requestParams,
                headers: requestHeaders,
                ignore404: true
            };

            if (this.version === "0.9") {
                requestCfg.url = "actors/profile";
                requestParams.actor = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            else {
                requestCfg.url = "agents/profile";
                requestParams.agent = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            if (typeof cfg.callback !== "undefined") {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err !== null) {
                        cfg.callback(err, result);
                        return;
                    }

                    if (xhr.status === 404) {
                        result = [];
                    }
                    else {
                        try {
                            result = JSON.parse(xhr.responseText);
                        }
                        catch (ex) {
                            err = "Response JSON parse error: " + ex;
                        }
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }
            if (typeof cfg.since !== "undefined") {
                requestCfg.params.since = cfg.since;
            }

            requestResult = this.sendRequest(requestCfg);
            if (! callbackWrapper) {
                requestResult.profileIds = null;
                if (requestResult.err !== null) {
                    return requestResult;
                }

                if (requestResult.xhr.status === 404) {
                    requestResult.profileIds = [];
                }
                else {
                    try {
                        requestResult.profileIds = JSON.parse(requestResult.xhr.responseText);
                    }
                    catch (ex) {
                        requestResult.err = "retrieveAgentProfileIds - JSON parse error: " + ex;
                    }
                }
            }
            return requestResult;
        },

        /**
        Save an agent profile value, when used from a browser sends to the endpoint using the RESTful interface.

        @method saveAgentProfile
        @param {String} key Key of agent profile to retrieve
        @param val Value to be stored
        @param {Object} cfg Configuration options
            @param {TinCan.Agent} cfg.agent Agent in document identifier
            @param {String} [cfg.lastSHA1] SHA1 of the previously seen existing profile
            @param {String} [cfg.contentType] Content-Type to specify in headers (defaults to 'application/octet-stream')
            @param {String} [cfg.method] Method to use. Default: PUT
            @param {Function} [cfg.callback] Callback to execute on completion
            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request
        */
        saveAgentProfile: function (key, val, cfg) {
            this.log("saveAgentProfile");
            var requestCfg,
                requestHeaders;

            requestHeaders = cfg.requestHeaders || {};

            if (typeof cfg.contentType === "undefined") {
                cfg.contentType = "application/octet-stream";
            }
            requestHeaders["Content-Type"] = cfg.contentType;

            if (typeof cfg.method === "undefined" || cfg.method !== "POST") {
                cfg.method = "PUT";
            }

            if (typeof val === "object" && TinCan.Utils.isApplicationJSON(cfg.contentType)) {
                val = JSON.stringify(val);
            }

            requestCfg = {
                method: cfg.method,
                params: {
                    profileId: key
                },
                data: val,
                headers: requestHeaders
            };

            if (this.version === "0.9") {
                requestCfg.url = "actors/profile";
                requestCfg.params.actor = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            else {
                requestCfg.url = "agents/profile";
                requestCfg.params.agent = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            if (typeof cfg.callback !== "undefined") {
                requestCfg.callback = cfg.callback;
            }
            if (typeof cfg.lastSHA1 !== "undefined" && cfg.lastSHA1 !== null) {
                requestCfg.headers["If-Match"] = cfg.lastSHA1;
            }
            else {
                requestCfg.headers["If-None-Match"] = "*";
            }

            return this.sendRequest(requestCfg);
        },

        /**
        Drop an agent profile value, when used from a browser sends to the endpoint using the RESTful interface. Full agent profile
        delete is not supported by the spec.

        @method dropAgentProfile
        @param {String|null} key Key of agent profile to delete
        @param {Object} cfg Configuration options
            @param {TinCan.Agent} cfg.agent Agent in document identifier
            @param {Function} [cfg.callback] Callback to execute on completion
            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request
        */
        dropAgentProfile: function (key, cfg) {
            this.log("dropAgentProfile");
            var requestParams,
                requestCfg,
                requestHeaders;

            requestHeaders = cfg.requestHeaders || {};

            requestParams = {
                profileId: key
            };
            requestCfg = {
                method: "DELETE",
                params: requestParams,
                headers: requestHeaders
            };

            if (this.version === "0.9") {
                requestCfg.url = "actors/profile";
                requestParams.actor = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            else {
                requestCfg.url = "agents/profile";
                requestParams.agent = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            if (typeof cfg.callback !== "undefined") {
                requestCfg.callback = cfg.callback;
            }

            return this.sendRequest(requestCfg);
        }
    };

    /**
    Allows client code to determine whether their environment supports synchronous xhr handling
    @static this is a static property, set by the environment
    */
    LRS.syncEnabled = null;
}());

/*
    Copyright 2012 Rustici Software

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
TinCan client library

@module TinCan
@submodule TinCan.AgentAccount
**/
(function () {
    "use strict";

    /**
    @class TinCan.AgentAccount
    @constructor
    */
    var AgentAccount = TinCan.AgentAccount = function (cfg) {
        this.log("constructor");

        /**
        @property homePage
        @type String
        */
        this.homePage = null;

        /**
        @property name
        @type String
        */
        this.name = null;

        this.init(cfg);
    };
    AgentAccount.prototype = {
        /**
        @property LOG_SRC
        */
        LOG_SRC: "AgentAccount",

        /**
        @method log
        */
        log: TinCan.prototype.log,

        /**
        @method init
        @param {Object} [options] Configuration used to initialize
        */
        init: function (cfg) {
            this.log("init");
            var i,
                directProps = [
                    "name",
                    "homePage"
                ];

            cfg = cfg || {};

            // handle .9 name changes
            if (typeof cfg.accountServiceHomePage !== "undefined") {
                cfg.homePage = cfg.accountServiceHomePage;
            }
            if (typeof cfg.accountName !== "undefined") {
                cfg.name = cfg.accountName;
            }

            for (i = 0; i < directProps.length; i += 1) {
                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {
                    this[directProps[i]] = cfg[directProps[i]];
                }
            }
        },

        toString: function () {
            this.log("toString");
            var result = "";

            if (this.name !== null || this.homePage !== null) {
                result += this.name !== null ? this.name : "-";
                result += ":";
                result += this.homePage !== null ? this.homePage : "-";
            }
            else {
                result = "AgentAccount: unidentified";
            }

            return result;
        },

        /**
        @method asVersion
        @param {String} [version] Version to return (defaults to newest supported)
        */
        asVersion: function (version) {
            this.log("asVersion: " + version);
            var result = {};

            version = version || TinCan.versions()[0];

            if (version === "0.9") {
                result.accountName = this.name;
                result.accountServiceHomePage = this.homePage;
            } else {
                result.name = this.name;
                result.homePage = this.homePage;
            }

            return result;
        }
    };

    /**
    @method fromJSON
    @return {Object} AgentAccount
    @static
    */
    AgentAccount.fromJSON = function (acctJSON) {
        AgentAccount.prototype.log("fromJSON");
        var _acct = JSON.parse(acctJSON);

        return new AgentAccount(_acct);
    };
}());

/*
    Copyright 2012 Rustici Software

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
TinCan client library

@module TinCan
@submodule TinCan.Agent
**/
(function () {
    "use strict";

    /**
    @class TinCan.Agent
    @constructor
    */
    var Agent = TinCan.Agent = function (cfg) {
        this.log("constructor");

        /**
        @property name
        @type String
        */
        this.name = null;

        /**
        @property mbox
        @type String
        */
        this.mbox = null;

        /**
        @property mbox_sha1sum
        @type String
        */
        this.mbox_sha1sum = null;

        /**
        @property openid
        @type String
        */
        this.openid = null;

        /**
        @property account
        @type TinCan.AgentAccount
        */
        this.account = null;

        /**
        @property degraded
        @type Boolean
        @default false
        */
        this.degraded = false;

        this.init(cfg);
    };
    Agent.prototype = {
        /**
        @property objectType
        @type String
        @default Agent
        */
        objectType: "Agent",

        /**
        @property LOG_SRC
        */
        LOG_SRC: "Agent",

        /**
        @method log
        */
        log: TinCan.prototype.log,

        /**
        @method init
        @param {Object} [options] Configuration used to initialize
        */
        init: function (cfg) {
            this.log("init");
            var i,
                directProps = [
                    "name",
                    "mbox",
                    "mbox_sha1sum",
                    "openid"
                ],
                val
            ;

            cfg = cfg || {};

            // handle .9 split names and array properties into single interface
            if (typeof cfg.lastName !== "undefined" || typeof cfg.firstName !== "undefined") {
                cfg.name = "";
                if (typeof cfg.firstName !== "undefined" && cfg.firstName.length > 0) {
                    cfg.name = cfg.firstName[0];
                    if (cfg.firstName.length > 1) {
                        this.degraded = true;
                    }
                }

                if (cfg.name !== "") {
                    cfg.name += " ";
                }

                if (typeof cfg.lastName !== "undefined" && cfg.lastName.length > 0) {
                    cfg.name += cfg.lastName[0];
                    if (cfg.lastName.length > 1) {
                        this.degraded = true;
                    }
                }
            } else if (typeof cfg.familyName !== "undefined" || typeof cfg.givenName !== "undefined") {
                cfg.name = "";
                if (typeof cfg.givenName !== "undefined" && cfg.givenName.length > 0) {
                    cfg.name = cfg.givenName[0];
                    if (cfg.givenName.length > 1) {
                        this.degraded = true;
                    }
                }

                if (cfg.name !== "") {
                    cfg.name += " ";
                }

                if (typeof cfg.familyName !== "undefined" && cfg.familyName.length > 0) {
                    cfg.name += cfg.familyName[0];
                    if (cfg.familyName.length > 1) {
                        this.degraded = true;
                    }
                }
            }

            if (typeof cfg.name === "object" && cfg.name !== null) {
                if (cfg.name.length > 1) {
                    this.degraded = true;
                }
                cfg.name = cfg.name[0];
            }
            if (typeof cfg.mbox === "object" && cfg.mbox !== null) {
                if (cfg.mbox.length > 1) {
                    this.degraded = true;
                }
                cfg.mbox = cfg.mbox[0];
            }
            if (typeof cfg.mbox_sha1sum === "object" && cfg.mbox_sha1sum !== null) {
                if (cfg.mbox_sha1sum.length > 1) {
                    this.degraded = true;
                }
                cfg.mbox_sha1sum = cfg.mbox_sha1sum[0];
            }
            if (typeof cfg.openid === "object" && cfg.openid !== null) {
                if (cfg.openid.length > 1) {
                    this.degraded = true;
                }
                cfg.openid = cfg.openid[0];
            }
            if (typeof cfg.account === "object" && cfg.account !== null && typeof cfg.account.homePage === "undefined" && typeof cfg.account.name === "undefined") {
                if (cfg.account.length === 0) {
                    delete cfg.account;
                }
                else {
                    if (cfg.account.length > 1) {
                        this.degraded = true;
                    }
                    cfg.account = cfg.account[0];
                }
            }

            if (cfg.hasOwnProperty("account")) {
                if (cfg.account instanceof TinCan.AgentAccount) {
                    this.account = cfg.account;
                }
                else {
                    this.account = new TinCan.AgentAccount (cfg.account);
                }
            }

            for (i = 0; i < directProps.length; i += 1) {
                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {
                    val = cfg[directProps[i]];
                    if (directProps[i] === "mbox" && val.indexOf("mailto:") === -1) {
                        val = "mailto:" + val;
                    }
                    this[directProps[i]] = val;
                }
            }
        },

        toString: function () {
            this.log("toString");

            if (this.name !== null) {
                return this.name;
            }
            if (this.mbox !== null) {
                return this.mbox.replace("mailto:", "");
            }
            if (this.mbox_sha1sum !== null) {
                return this.mbox_sha1sum;
            }
            if (this.openid !== null) {
                return this.openid;
            }
            if (this.account !== null) {
                return this.account.toString();
            }

            return this.objectType + ": unidentified";
        },

        /**
        While a TinCan.Agent instance can store more than one inverse functional identifier
        this method will always only output one to be compliant with the statement sending
        specification. Order of preference is: mbox, mbox_sha1sum, openid, account

        @method asVersion
        @param {String} [version] Version to return (defaults to newest supported)
        */
        asVersion: function (version) {
            this.log("asVersion: " + version);
            var result = {
                objectType: this.objectType
            };

            version = version || TinCan.versions()[0];

            if (version === "0.9") {
                if (this.mbox !== null) {
                    result.mbox = [ this.mbox ];
                }
                else if (this.mbox_sha1sum !== null) {
                    result.mbox_sha1sum = [ this.mbox_sha1sum ];
                }
                else if (this.openid !== null) {
                    result.openid = [ this.openid ];
                }
                else if (this.account !== null) {
                    result.account = [ this.account.asVersion(version) ];
                }

                if (this.name !== null) {
                    result.name = [ this.name ];
                }
            } else {
                if (this.mbox !== null) {
                    result.mbox = this.mbox;
                }
                else if (this.mbox_sha1sum !== null) {
                    result.mbox_sha1sum = this.mbox_sha1sum;
                }
                else if (this.openid !== null) {
                    result.openid = this.openid;
                }
                else if (this.account !== null) {
                    result.account = this.account.asVersion(version);
                }

                if (this.name !== null) {
                    result.name = this.name;
                }
            }

            return result;
        }
    };

    /**
    @method fromJSON
    @return {Object} Agent
    @static
    */
    Agent.fromJSON = function (agentJSON) {
        Agent.prototype.log("fromJSON");
        var _agent = JSON.parse(agentJSON);

        return new Agent(_agent);
    };
}());

/*
    Copyright 2012 Rustici Software

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
TinCan client library

@module TinCan
@submodule TinCan.Group
**/
(function () {
    "use strict";

    /**
    @class TinCan.Group
    @constructor
    */
    var Group = TinCan.Group = function (cfg) {
        this.log("constructor");

        /**
        @property name
        @type String
        */
        this.name = null;

        /**
        @property mbox
        @type String
        */
        this.mbox = null;

        /**
        @property mbox_sha1sum
        @type String
        */
        this.mbox_sha1sum = null;

        /**
        @property openid
        @type String
        */
        this.openid = null;

        /**
        @property account
        @type TinCan.AgentAccount
        */
        this.account = null;

        /**
        @property member
        @type Array
        */
        this.member = [];

        this.init(cfg);
    };
    Group.prototype = {
        /**
        @property objectType
        @type String
        @default "Group"
        @static
        */
        objectType: "Group",

        /**
        @property LOG_SRC
        */
        LOG_SRC: "Group",

        /**
        @method log
        */
        log: TinCan.prototype.log,

        /**
        @method init
        @param {Object} [options] Configuration used to initialize
        */
        init: function (cfg) {
            this.log("init");
            var i;

            cfg = cfg || {};

            TinCan.Agent.prototype.init.call(this, cfg);

            if (typeof cfg.member !== "undefined") {
                for (i = 0; i < cfg.member.length; i += 1) {
                    if (cfg.member[i] instanceof TinCan.Agent) {
                        this.member.push(cfg.member[i]);
                    }
                    else {
                        this.member.push(new TinCan.Agent (cfg.member[i]));
                    }
                }
            }
        },

        toString: function (lang) {
            this.log("toString");

            var result = TinCan.Agent.prototype.toString.call(this, lang);
            if (result !== this.objectType + ": unidentified") {
                result = this.objectType + ": " + result;
            }

            return result;
        },

        /**
        @method asVersion
        @param {String} [version] Version to return (defaults to newest supported)
        */
        asVersion: function (version) {
            this.log("asVersion: " + version);
            var result,
                i
            ;

            version = version || TinCan.versions()[0];

            result = TinCan.Agent.prototype.asVersion.call(this, version);

            if (this.member.length > 0) {
                result.member = [];
                for (i = 0; i < this.member.length; i += 1) {
                    result.member.push(this.member[i].asVersion(version));
                }
            }

            return result;
        }
    };

    /**
    @method fromJSON
    @return {Object} Group
    @static
    */
    Group.fromJSON = function (groupJSON) {
        Group.prototype.log("fromJSON");
        var _group = JSON.parse(groupJSON);

        return new Group(_group);
    };
}());

/*
    Copyright 2012 Rustici Software

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
TinCan client library

@module TinCan
@submodule TinCan.Verb
*/
(function () {
    "use strict";

    //
    // this represents the full set of verb values that were
    // allowed by the .9 spec version, if an object is created with one of
    // the short forms it will be upconverted to the matching long form,
    // for local storage and use and if an object is needed in .9 version
    // consequently down converted
    //
    // hopefully this list will never grow (or change) and only the exact
    // ADL compatible URLs should be matched
    //
    var _downConvertMap = {
        "http://adlnet.gov/expapi/verbs/experienced": "experienced",
        "http://adlnet.gov/expapi/verbs/attended":    "attended",
        "http://adlnet.gov/expapi/verbs/attempted":   "attempted",
        "http://adlnet.gov/expapi/verbs/completed":   "completed",
        "http://adlnet.gov/expapi/verbs/passed":      "passed",
        "http://adlnet.gov/expapi/verbs/failed":      "failed",
        "http://adlnet.gov/expapi/verbs/answered":    "answered",
        "http://adlnet.gov/expapi/verbs/interacted":  "interacted",
        "http://adlnet.gov/expapi/verbs/imported":    "imported",
        "http://adlnet.gov/expapi/verbs/created":     "created",
        "http://adlnet.gov/expapi/verbs/shared":      "shared",
        "http://adlnet.gov/expapi/verbs/voided":      "voided"
    },

    /**
    @class TinCan.Verb
    @constructor
    */
    Verb = TinCan.Verb = function (cfg) {
        this.log("constructor");

        /**
        @property id
        @type String
        */
        this.id = null;

        /**
        @property display
        @type Object
        */
        this.display = null;

        this.init(cfg);
    };
    Verb.prototype = {
        /**
        @property LOG_SRC
        */
        LOG_SRC: "Verb",

        /**
        @method log
        */
        log: TinCan.prototype.log,

        /**
        @method init
        @param {Object} [options] Configuration used to initialize
        */
        init: function (cfg) {
            this.log("init");
            var i,
                directProps = [
                    "id",
                    "display"
                ],
                prop
            ;

            if (typeof cfg === "string") {
                this.id = cfg;
                this.display = {
                    und: this.id
                };

                //If simple string like "attempted" was passed in (0.9 verbs), 
                //upconvert the ID to the 0.95 ADL version
                for (prop in _downConvertMap) {
                    if (_downConvertMap.hasOwnProperty(prop) && _downConvertMap[prop] === cfg) {
                        this.id = prop;
                        break;
                    }
                }
            }
            else {
                cfg = cfg || {};

                for (i = 0; i < directProps.length; i += 1) {
                    if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {
                        this[directProps[i]] = cfg[directProps[i]];
                    }
                }

                if (this.display === null && typeof _downConvertMap[this.id] !== "undefined") {
                    this.display = {
                        "und": _downConvertMap[this.id]
                    };
                }
            }
        },

        /**
        @method toString
        @return {String} String representation of the verb
        */
        toString: function (lang) {
            this.log("toString");

            if (this.display !== null) {
                return this.getLangDictionaryValue("display", lang);
            }

            return this.id;
        },

        /**
        @method asVersion
        @param {String} [version] Version to return (defaults to newest supported)
        */
        asVersion: function (version) {
            this.log("asVersion");
            var result;

            version = version || TinCan.versions()[0];

            if (version === "0.9") {
                result = _downConvertMap[this.id];
            }
            else {
                result = {
                    id: this.id
                };
                if (this.display !== null) {
                    result.display = this.display;
                }
            }

            return result;
        },

        /**
        See {{#crossLink "TinCan.Utils/getLangDictionaryValue"}}{{/crossLink}}

        @method getLangDictionaryValue
        */
        getLangDictionaryValue: TinCan.Utils.getLangDictionaryValue
    };

    /**
    @method fromJSON
    @param {String} verbJSON String of JSON representing the verb
    @return {Object} Verb
    @static
    */
    Verb.fromJSON = function (verbJSON) {
        Verb.prototype.log("fromJSON");
        var _verb = JSON.parse(verbJSON);

        return new Verb(_verb);
    };
}());

/*
    Copyright 2012 Rustici Software

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
TinCan client library

@module TinCan
@submodule TinCan.Result
**/
(function () {
    "use strict";

    /**
    @class TinCan.Result
    @constructor
    */
    var Result = TinCan.Result = function (cfg) {
        this.log("constructor");

        /**
        @property score
        @type TinCan.Score|null
        */
        this.score = null;

        /**
        @property success
        @type Boolean|null
        */
        this.success = null;

        /**
        @property completion
        @type Boolean|null
        */
        this.completion = null;

        /**
        @property duration
        @type String|null
        */
        this.duration = null;

        /**
        @property response
        @type String|null
        */
        this.response = null;

        /**
        @property extensions
        @type Object|null
        */
        this.extensions = null;

        this.init(cfg);
    };
    Result.prototype = {
        /**
        @property LOG_SRC
        */
        LOG_SRC: "Result",

        /**
        @method log
        */
        log: TinCan.prototype.log,

        /**
        @method init
        @param {Object} [options] Configuration used to initialize
        */
        init: function (cfg) {
            this.log("init");

            var i,
                directProps = [
                    "completion",
                    "duration",
                    "extensions",
                    "response",
                    "success"
                ]
            ;

            cfg = cfg || {};

            if (cfg.hasOwnProperty("score") && cfg.score !== null) {
                if (cfg.score instanceof TinCan.Score) {
                    this.score = cfg.score;
                }
                else {
                    this.score = new TinCan.Score (cfg.score);
                }
            }

            for (i = 0; i < directProps.length; i += 1) {
                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {
                    this[directProps[i]] = cfg[directProps[i]];
                }
            }

            // 0.9 used a string, store it internally as a bool
            if (this.completion === "Completed") {
                this.completion = true;
            }
        },

        /**
        @method asVersion
        @param {String} [version] Version to return (defaults to newest supported)
        */
        asVersion: function (version) {
            this.log("asVersion");
            var result = {},
                optionalDirectProps = [
                    "success",
                    "duration",
                    "response",
                    "extensions"
                ],
                optionalObjProps = [
                    "score"
                ],
                i;

            version = version || TinCan.versions()[0];

            for (i = 0; i < optionalDirectProps.length; i += 1) {
                if (this[optionalDirectProps[i]] !== null) {
                    result[optionalDirectProps[i]] = this[optionalDirectProps[i]];
                }
            }
            for (i = 0; i < optionalObjProps.length; i += 1) {
                if (this[optionalObjProps[i]] !== null) {
                    result[optionalObjProps[i]] = this[optionalObjProps[i]].asVersion(version);
                }
            }
            if (this.completion !== null) {
                if (version === "0.9") {
                    if (this.completion) {
                        result.completion = "Completed";
                    }
                }
                else {
                    result.completion = this.completion;
                }
            }

            return result;
        }
    };

    /**
    @method fromJSON
    @return {Object} Result
    @static
    */
    Result.fromJSON = function (resultJSON) {
        Result.prototype.log("fromJSON");
        var _result = JSON.parse(resultJSON);

        return new Result(_result);
    };
}());

/*
    Copyright 2012 Rustici Software

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
TinCan client library

@module TinCan
@submodule TinCan.Score
**/
(function () {
    "use strict";

    /**
    @class TinCan.Score
    @constructor
    */
    var Score = TinCan.Score = function (cfg) {
        this.log("constructor");

        /**
        @property scaled
        @type String
        */
        this.scaled = null;

        /**
        @property raw
        @type String
        */
        this.raw = null;

        /**
        @property min
        @type String
        */
        this.min = null;

        /**
        @property max
        @type String
        */
        this.max = null;

        this.init(cfg);
    };
    Score.prototype = {
        /**
        @property LOG_SRC
        */
        LOG_SRC: "Score",

        /**
        @method log
        */
        log: TinCan.prototype.log,

        /**
        @method init
        @param {Object} [options] Configuration used to initialize
        */
        init: function (cfg) {
            this.log("init");

            var i,
                directProps = [
                    "scaled",
                    "raw",
                    "min",
                    "max"
                ]
            ;

            cfg = cfg || {};

            for (i = 0; i < directProps.length; i += 1) {
                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {
                    this[directProps[i]] = cfg[directProps[i]];
                }
            }
        },

        /**
        @method asVersion
        @param {String} [version] Version to return (defaults to newest supported)
        */
        asVersion: function (version) {
            this.log("asVersion");
            var result = {},
                optionalDirectProps = [
                    "scaled",
                    "raw",
                    "min",
                    "max"
                ],
                i;

            version = version || TinCan.versions()[0];

            for (i = 0; i < optionalDirectProps.length; i += 1) {
                if (this[optionalDirectProps[i]] !== null) {
                    result[optionalDirectProps[i]] = this[optionalDirectProps[i]];
                }
            }

            return result;
        }
    };

    /**
    @method fromJSON
    @return {Object} Score
    @static
    */
    Score.fromJSON = function (scoreJSON) {
        Score.prototype.log("fromJSON");
        var _score = JSON.parse(scoreJSON);

        return new Score(_score);
    };
}());

/*
    Copyright 2012 Rustici Software

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
TinCan client library

@module TinCan
@submodule TinCan.InteractionComponent
**/
(function () {
    "use strict";

    /**
    @class TinCan.InteractionComponent
    @constructor
    */
    var InteractionComponent = TinCan.InteractionComponent = function (cfg) {
        this.log("constructor");

        /**
        @property id
        @type String
        */
        this.id = null;

        /**
        @property description
        @type Object
        */
        this.description = null;

        this.init(cfg);
    };
    InteractionComponent.prototype = {
        /**
        @property LOG_SRC
        */
        LOG_SRC: "InteractionComponent",

        /**
        @method log
        */
        log: TinCan.prototype.log,

        /**
        @method init
        @param {Object} [options] Configuration used to initialize
        */
        init: function (cfg) {
            this.log("init");
            var i,
                directProps = [
                    "id",
                    "description"
                ]
            ;

            cfg = cfg || {};

            for (i = 0; i < directProps.length; i += 1) {
                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {
                    this[directProps[i]] = cfg[directProps[i]];
                }
            }
        },

        /**
        @method asVersion
        @param {String} [version] Version to return (defaults to newest supported)
        */
        asVersion: function (version) {
            this.log("asVersion");
            var result = {
                    id: this.id
                },
                optionalDirectProps = [
                    "description"
                ],
                i,
                prop;

            version = version || TinCan.versions()[0];

            for (i = 0; i < optionalDirectProps.length; i += 1) {
                prop = optionalDirectProps[i];
                if (this[prop] !== null) {
                    result[prop] = this[prop];
                }
            }

            return result;
        },

        /**
        See {{#crossLink "TinCan.Utils/getLangDictionaryValue"}}{{/crossLink}}

        @method getLangDictionaryValue
        */
        getLangDictionaryValue: TinCan.Utils.getLangDictionaryValue
    };

    /**
    @method fromJSON
    @return {Object} InteractionComponent
    @static
    */
    InteractionComponent.fromJSON = function (icJSON) {
        InteractionComponent.prototype.log("fromJSON");
        var _ic = JSON.parse(icJSON);

        return new InteractionComponent(_ic);
    };
}());

/*
    Copyright 2012 Rustici Software

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
TinCan client library

@module TinCan
@submodule TinCan.ActivityDefinition
**/
(function () {
    "use strict";

    //
    // this represents the full set of activity definition types that were
    // allowed by the .9 spec version, if an object is created with one of
    // the short forms it will be upconverted to the matching long form,
    // for local storage and use and if an object is needed in .9 version
    // consequently down converted
    //
    // hopefully this list will never grow (or change) and only the exact
    // ADL compatible URLs should be matched
    //
    var _downConvertMap = {
        "http://adlnet.gov/expapi/activities/course": "course",
        "http://adlnet.gov/expapi/activities/module": "module",
        "http://adlnet.gov/expapi/activities/meeting": "meeting",
        "http://adlnet.gov/expapi/activities/media": "media",
        "http://adlnet.gov/expapi/activities/performance": "performance",
        "http://adlnet.gov/expapi/activities/simulation": "simulation",
        "http://adlnet.gov/expapi/activities/assessment": "assessment",
        "http://adlnet.gov/expapi/activities/interaction": "interaction",
        "http://adlnet.gov/expapi/activities/cmi.interaction": "cmi.interaction",
        "http://adlnet.gov/expapi/activities/question": "question",
        "http://adlnet.gov/expapi/activities/objective": "objective",
        "http://adlnet.gov/expapi/activities/link": "link"
    },

    /**
    @class TinCan.ActivityDefinition
    @constructor
    */
    ActivityDefinition = TinCan.ActivityDefinition = function (cfg) {
        this.log("constructor");

        /**
        @property name
        @type Object
        */
        this.name = null;

        /**
        @property description
        @type Object
        */
        this.description = null;

        /**
        @property type
        @type String
        */
        this.type = null;

        /**
        @property moreInfo
        @type String
        */
        this.moreInfo = null;

        /**
        @property extensions
        @type Object
        */
        this.extensions = null;

        /**
        @property interactionType
        @type String
        */
        this.interactionType = null;

        /**
        @property correctResponsesPattern
        @type Array
        */
        this.correctResponsesPattern = null;

        /**
        @property choices
        @type Array
        */
        this.choices = null;

        /**
        @property scale
        @type Array
        */
        this.scale = null;

        /**
        @property source
        @type Array
        */
        this.source = null;

        /**
        @property target
        @type Array
        */
        this.target = null;

        /**
        @property steps
        @type Array
        */
        this.steps = null;

        this.init(cfg);
    };
    ActivityDefinition.prototype = {
        /**
        @property LOG_SRC
        */
        LOG_SRC: "ActivityDefinition",

        /**
        @method log
        */
        log: TinCan.prototype.log,

        /**
        @method init
        @param {Object} [options] Configuration used to initialize
        */
        init: function (cfg) {
            this.log("init");

            var i,
                j,
                prop,
                directProps = [
                    "name",
                    "description",
                    "moreInfo",
                    "extensions",
                    "correctResponsesPattern"
                ],
                interactionComponentProps = []
            ;

            cfg = cfg || {};

            if (cfg.hasOwnProperty("type") && cfg.type !== null) {
                // TODO: verify type is URI?
                for (prop in _downConvertMap) {
                    if (_downConvertMap.hasOwnProperty(prop) && _downConvertMap[prop] === cfg.type) {
                        cfg.type = _downConvertMap[prop];
                    }
                }
                this.type = cfg.type;
            }

            if (cfg.hasOwnProperty("interactionType") && cfg.interactionType !== null) {
                // TODO: verify interaction type in acceptable set?
                this.interactionType = cfg.interactionType;
                if (cfg.interactionType === "choice" || cfg.interactionType === "sequencing") {
                    interactionComponentProps.push("choices");
                }
                else if (cfg.interactionType === "likert") {
                    interactionComponentProps.push("scale");
                }
                else if (cfg.interactionType === "matching") {
                    interactionComponentProps.push("source");
                    interactionComponentProps.push("target");
                }
                else if (cfg.interactionType === "performance") {
                    interactionComponentProps.push("steps");
                }

                if (interactionComponentProps.length > 0) {
                    for (i = 0; i < interactionComponentProps.length; i += 1) {
                        prop = interactionComponentProps[i];
                        if (cfg.hasOwnProperty(prop) && cfg[prop] !== null) {
                            this[prop] = [];
                            for (j = 0; j < cfg[prop].length; j += 1) {
                                if (cfg[prop][j] instanceof TinCan.InteractionComponent) {
                                    this[prop].push(cfg[prop][j]);
                                } else {
                                    this[prop].push(
                                        new TinCan.InteractionComponent (
                                            cfg[prop][j]
                                        )
                                    );
                                }
                            }
                        }
                    }
                }
            }

            for (i = 0; i < directProps.length; i += 1) {
                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {
                    this[directProps[i]] = cfg[directProps[i]];
                }
            }
        },

        /**
        @method toString
        @return {String} String representation of the definition
        */
        toString: function (lang) {
            this.log("toString");

            if (this.name !== null) {
                return this.getLangDictionaryValue("name", lang);
            }

            if (this.description !== null) {
                return this.getLangDictionaryValue("description", lang);
            }

            return "";
        },

        /**
        @method asVersion
        @param {String} [version] Version to return (defaults to newest supported)
        */
        asVersion: function (version) {
            this.log("asVersion");
            var result = {},
                directProps = [
                    "name",
                    "description",
                    "interactionType",
                    "correctResponsesPattern",
                    "extensions"
                ],
                interactionComponentProps = [
                    "choices",
                    "scale",
                    "source",
                    "target",
                    "steps"
                ],
                i,
                j,
                prop
            ;

            version = version || TinCan.versions()[0];

            if (this.type !== null) {
                if (version === "0.9") {
                    result.type = _downConvertMap[this.type];
                }
                else {
                    result.type = this.type;
                }
            }

            for (i = 0; i < directProps.length; i += 1) {
                prop = directProps[i];
                if (this[prop] !== null) {
                    result[prop] = this[prop];
                }
            }

            for (i = 0; i < interactionComponentProps.length; i += 1) {
                prop = interactionComponentProps[i];
                if (this[prop] !== null) {
                    result[prop] = [];
                    for (j = 0; j < this[prop].length; j += 1) {
                        result[prop].push(
                            this[prop][j].asVersion(version)
                        );
                    }
                }
            }

            if (version.indexOf("0.9") !== 0) {
                if (this.moreInfo !== null) {
                    result.moreInfo = this.moreInfo;
                }
            }

            return result;
        },

        /**
        See {{#crossLink "TinCan.Utils/getLangDictionaryValue"}}{{/crossLink}}

        @method getLangDictionaryValue
        */
        getLangDictionaryValue: TinCan.Utils.getLangDictionaryValue
    };

    /**
    @method fromJSON
    @return {Object} ActivityDefinition
    @static
    */
    ActivityDefinition.fromJSON = function (definitionJSON) {
        ActivityDefinition.prototype.log("fromJSON");
        var _definition = JSON.parse(definitionJSON);

        return new ActivityDefinition(_definition);
    };
}());

/*
    Copyright 2012 Rustici Software

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
TinCan client library

@module TinCan
@submodule TinCan.Activity
**/
(function () {
    "use strict";

    /**
    @class TinCan.Activity
    @constructor
    */
    var Activity = TinCan.Activity = function (cfg) {
        this.log("constructor");

        /**
        @property objectType
        @type String
        @default Activity
        */
        this.objectType = "Activity";

        /**
        @property id
        @type String
        */
        this.id = null;

        /**
        @property definition
        @type TinCan.ActivityDefinition
        */
        this.definition = null;

        this.init(cfg);
    };
    Activity.prototype = {
        /**
        @property LOG_SRC
        */
        LOG_SRC: "Activity",

        /**
        @method log
        */
        log: TinCan.prototype.log,

        /**
        @method init
        @param {Object} [options] Configuration used to initialize
        */
        init: function (cfg) {
            this.log("init");

            var i,
                directProps = [
                    "id"
                ]
            ;

            cfg = cfg || {};

            if (cfg.hasOwnProperty("definition")) {
                if (cfg.definition instanceof TinCan.ActivityDefinition) {
                    this.definition = cfg.definition;
                } else {
                    this.definition = new TinCan.ActivityDefinition (cfg.definition);
                }
            }

            for (i = 0; i < directProps.length; i += 1) {
                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {
                    this[directProps[i]] = cfg[directProps[i]];
                }
            }
        },

        /**
        @method toString
        @return {String} String representation of the activity
        */
        toString: function (lang) {
            this.log("toString");
            var defString = "";

            if (this.definition !== null) {
                defString = this.definition.toString(lang);
                if (defString !== "") {
                    return defString;
                }
            }

            if (this.id !== null) {
                return this.id;
            }

            return "Activity: unidentified";
        },

        /**
        @method asVersion
        @param {String} [version] Version to return (defaults to newest supported)
        */
        asVersion: function (version) {
            this.log("asVersion");
            var result = {
                id: this.id,
                objectType: this.objectType
            };

            version = version || TinCan.versions()[0];

            if (this.definition !== null) {
                result.definition = this.definition.asVersion(version);
            }

            return result;
        }
    };

    /**
    @method fromJSON
    @return {Object} Activity
    @static
    */
    Activity.fromJSON = function (activityJSON) {
        Activity.prototype.log("fromJSON");
        var _activity = JSON.parse(activityJSON);

        return new Activity(_activity);
    };
}());

/*
    Copyright 2013 Rustici Software

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
TinCan client library

@module TinCan
@submodule TinCan.ContextActivities
**/
(function () {
    "use strict";

    /**
    @class TinCan.ContextActivities
    @constructor
    */
    var ContextActivities = TinCan.ContextActivities = function (cfg) {
        this.log("constructor");

        /**
        @property category
        @type Array
        */
        this.category = null;

        /**
        @property parent
        @type Array
        */
        this.parent = null;

        /**
        @property grouping
        @type Array
        */
        this.grouping = null;

        /**
        @property other
        @type Array
        */
        this.other = null;

        this.init(cfg);
    };
    ContextActivities.prototype = {
        /**
        @property LOG_SRC
        */
        LOG_SRC: "ContextActivities",

        /**
        @method log
        */
        log: TinCan.prototype.log,

        /**
        @method init
        @param {Object} [options] Configuration used to initialize
        */
        init: function (cfg) {
            this.log("init");

            var i,
                j,
                objProps = [
                    "category",
                    "parent",
                    "grouping",
                    "other"
                ],
                prop,
                val
            ;

            cfg = cfg || {};

            for (i = 0; i < objProps.length; i += 1) {
                prop = objProps[i];
                if (cfg.hasOwnProperty(prop) && cfg[prop] !== null) {
                    if (Object.prototype.toString.call(cfg[prop]) === "[object Array]") {
                        for (j = 0; j < cfg[prop].length; j += 1) {
                            this.add(prop, cfg[prop][j]);
                        }
                    }
                    else {
                        val = cfg[prop];

                        this.add(prop, val);
                    }
                }
            }
        },

        /**
        @method add
        @param String key Property to add value to one of "category", "parent", "grouping", "other"
        @return Number index where the value was added
        */
        add: function (key, val) {
            if (key !== "category" && key !== "parent" && key !== "grouping" && key !== "other") {
                return;
            }

            if (this[key] === null) {
                this[key] = [];
            }

            if (! (val instanceof TinCan.Activity)) {
                val = typeof val === "string" ? { id: val } : val;
                val = new TinCan.Activity (val);
            }

            this[key].push(val);

            return this[key].length - 1;
        },

        /**
        @method asVersion
        @param {String} [version] Version to return (defaults to newest supported)
        */
        asVersion: function (version) {
            this.log("asVersion");
            var result = {},
                optionalObjProps = [
                    "parent",
                    "grouping",
                    "other"
                ],
                i,
                j;

            version = version || TinCan.versions()[0];

            for (i = 0; i < optionalObjProps.length; i += 1) {
                if (this[optionalObjProps[i]] !== null && this[optionalObjProps[i]].length > 0) {
                    if (version === "0.9" || version === "0.95") {
                        if (this[optionalObjProps[i]].length > 1) {
                            // TODO: exception?
                            this.log("[warning] version does not support multiple values in: " + optionalObjProps[i]);
                        }

                        result[optionalObjProps[i]] = this[optionalObjProps[i]][0].asVersion(version);
                    }
                    else {
                        result[optionalObjProps[i]] = [];
                        for (j = 0; j < this[optionalObjProps[i]].length; j += 1) {
                            result[optionalObjProps[i]].push(
                                this[optionalObjProps[i]][j].asVersion(version)
                            );
                        }
                    }
                }
            }
            if (this.category !== null && this.category.length > 0) {
                if (version === "0.9" || version === "0.95") {
                    this.log("[error] version does not support the 'category' property: " + version);
                    throw new Error(version + " does not support the 'category' property");
                }
                else {
                    result.category = [];
                    for (i = 0; i < this.category.length; i += 1) {
                        result.category.push(this.category[i].asVersion(version));
                    }
                }
            }

            return result;
        }
    };

    /**
    @method fromJSON
    @return {Object} ContextActivities
    @static
    */
    ContextActivities.fromJSON = function (contextActivitiesJSON) {
        ContextActivities.prototype.log("fromJSON");
        var _contextActivities = JSON.parse(contextActivitiesJSON);

        return new ContextActivities(_contextActivities);
    };
}());

/*
    Copyright 2012 Rustici Software

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
TinCan client library

@module TinCan
@submodule TinCan.Context
**/
(function () {
    "use strict";

    /**
    @class TinCan.Context
    @constructor
    */
    var Context = TinCan.Context = function (cfg) {
        this.log("constructor");

        /**
        @property registration
        @type String|null
        */
        this.registration = null;

        /**
        @property instructor
        @type TinCan.Agent|TinCan.Group|null
        */
        this.instructor = null;

        /**
        @property team
        @type TinCan.Agent|TinCan.Group|null
        */
        this.team = null;

        /**
        @property contextActivities
        @type ContextActivities|null
        */
        this.contextActivities = null;

        /**
        @property revision
        @type String|null
        */
        this.revision = null;

        /**
        @property platform
        @type Object|null
        */
        this.platform = null;

        /**
        @property language
        @type String|null
        */
        this.language = null;

        /**
        @property statement
        @type StatementRef|null
        */
        this.statement = null;

        /**
        @property extensions
        @type String
        */
        this.extensions = null;

        this.init(cfg);
    };
    Context.prototype = {
        /**
        @property LOG_SRC
        */
        LOG_SRC: "Context",

        /**
        @method log
        */
        log: TinCan.prototype.log,

        /**
        @method init
        @param {Object} [options] Configuration used to initialize
        */
        init: function (cfg) {
            this.log("init");

            var i,
                directProps = [
                    "registration",
                    "revision",
                    "platform",
                    "language",
                    "extensions"
                ],
                agentGroupProps = [
                    "instructor",
                    "team"
                ],
                prop,
                val
            ;

            cfg = cfg || {};

            for (i = 0; i < directProps.length; i += 1) {
                prop = directProps[i];
                if (cfg.hasOwnProperty(prop) && cfg[prop] !== null) {
                    this[prop] = cfg[prop];
                }
            }
            for (i = 0; i < agentGroupProps.length; i += 1) {
                prop = agentGroupProps[i];
                if (cfg.hasOwnProperty(prop) && cfg[prop] !== null) {
                    val = cfg[prop];

                    if (typeof val.objectType === "undefined" || val.objectType === "Person") {
                        val.objectType = "Agent";
                    }

                    if (val.objectType === "Agent" && ! (val instanceof TinCan.Agent)) {
                        val = new TinCan.Agent (val);
                    } else if (val.objectType === "Group" && ! (val instanceof TinCan.Group)) {
                        val = new TinCan.Group (val);
                    }

                    this[prop] = val;
                }
            }

            if (cfg.hasOwnProperty("contextActivities") && cfg.contextActivities !== null) {
                if (cfg.contextActivities instanceof TinCan.ContextActivities) {
                    this.contextActivities = cfg.contextActivities;
                }
                else {
                    this.contextActivities = new TinCan.ContextActivities(cfg.contextActivities);
                }
            }

            if (cfg.hasOwnProperty("statement") && cfg.statement !== null) {
                if (cfg.statement instanceof TinCan.StatementRef) {
                    this.statement = cfg.statement;
                }
                else if (cfg.statement instanceof TinCan.SubStatement) {
                    this.statement = cfg.statement;
                }
                else if (cfg.statement.objectType === "StatementRef") {
                    this.statement = new TinCan.StatementRef(cfg.statement);
                }
                else if (cfg.statement.objectType === "SubStatement") {
                    this.statement = new TinCan.SubStatement(cfg.statement);
                }
                else {
                    this.log("Unable to parse statement.context.statement property.");
                }
            }
        },

        /**
        @method asVersion
        @param {String} [version] Version to return (defaults to newest supported)
        */
        asVersion: function (version) {
            this.log("asVersion");
            var result = {},
                optionalDirectProps = [
                    "registration",
                    "revision",
                    "platform",
                    "language",
                    "extensions"
                ],
                optionalObjProps = [
                    "instructor",
                    "team",
                    "contextActivities",
                    "statement"
                ],
                i;

            version = version || TinCan.versions()[0];

            if (this.statement instanceof TinCan.SubStatement && version !== "0.9" && version !== "0.95") {
                this.log("[error] version does not support SubStatements in the 'statement' property: " + version);
                throw new Error(version + " does not support SubStatements in the 'statement' property");
            }

            for (i = 0; i < optionalDirectProps.length; i += 1) {
                if (this[optionalDirectProps[i]] !== null) {
                    result[optionalDirectProps[i]] = this[optionalDirectProps[i]];
                }
            }
            for (i = 0; i < optionalObjProps.length; i += 1) {
                if (this[optionalObjProps[i]] !== null) {
                    result[optionalObjProps[i]] = this[optionalObjProps[i]].asVersion(version);
                }
            }

            return result;
        }
    };

    /**
    @method fromJSON
    @return {Object} Context
    @static
    */
    Context.fromJSON = function (contextJSON) {
        Context.prototype.log("fromJSON");
        var _context = JSON.parse(contextJSON);

        return new Context(_context);
    };
}());

/*
    Copyright 2012 Rustici Software

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
TinCan client library

@module TinCan
@submodule TinCan.StatementRef
**/
(function () {
    "use strict";

    /**
    @class TinCan.StatementRef
    @constructor
    @param {Object} [cfg] Configuration used to initialize.
        @param {Object} [cfg.id] ID of statement to reference
    **/
    var StatementRef = TinCan.StatementRef = function (cfg) {
        this.log("constructor");

        /**
        @property id
        @type String
        */
        this.id = null;

        this.init(cfg);
    };

    StatementRef.prototype = {
        /**
        @property objectType
        @type String
        @default Agent
        */
        objectType: "StatementRef",

        /**
        @property LOG_SRC
        */
        LOG_SRC: "StatementRef",

        /**
        @method log
        */
        log: TinCan.prototype.log,

        /**
        @method init
        @param {Object} [options] Configuration used to initialize (see constructor)
        */
        init: function (cfg) {
            this.log("init");
            var i,
                directProps = [
                    "id"
                ];

            cfg = cfg || {};

            for (i = 0; i < directProps.length; i += 1) {
                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {
                    this[directProps[i]] = cfg[directProps[i]];
                }
            }
        },

        /**
        @method toString
        @return {String} String representation of the statement
        */
        toString: function () {
            this.log("toString");
            return this.id;
        },

        /**
        @method asVersion
        @param {String} [version] Version to return (defaults to newest supported)
        */
        asVersion: function (version) {
            this.log("asVersion");
            var result = {
                objectType: this.objectType,
                id: this.id
            };

            if (version === "0.9") {
                result.objectType = "Statement";
            }

            return result;
        }
    };

    /**
    @method fromJSON
    @return {Object} StatementRef
    @static
    */
    StatementRef.fromJSON = function (stRefJSON) {
        StatementRef.prototype.log("fromJSON");
        var _stRef = JSON.parse(stRefJSON);

        return new StatementRef(_stRef);
    };
}());

/*
    Copyright 2012 Rustici Software

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
TinCan client library

@module TinCan
@submodule TinCan.SubStatement
**/
(function () {
    "use strict";

    /**
    @class TinCan.SubStatement
    @constructor
    @param {Object} [cfg] Configuration used to initialize.
        @param {TinCan.Agent} [cfg.actor] Actor of statement
        @param {TinCan.Verb} [cfg.verb] Verb of statement
        @param {TinCan.Activity|TinCan.Agent} [cfg.object] Alias for 'target'
        @param {TinCan.Activity|TinCan.Agent} [cfg.target] Object of statement
        @param {TinCan.Result} [cfg.result] Statement Result
        @param {TinCan.Context} [cfg.context] Statement Context
    **/
    var SubStatement = TinCan.SubStatement = function (cfg) {
        this.log("constructor");

        /**
        @property actor
        @type Object
        */
        this.actor = null;

        /**
        @property verb
        @type Object
        */
        this.verb = null;

        /**
        @property target
        @type Object
        */
        this.target = null;

        /**
        @property result
        @type Object
        */
        this.result = null;

        /**
        @property context
        @type Object
        */
        this.context = null;

        /**
        @property timestamp
        @type Date
        */
        this.timestamp = null;

        this.init(cfg);
    };

    SubStatement.prototype = {
        /**
        @property objectType
        @type String
        @default Agent
        */
        objectType: "SubStatement",

        /**
        @property LOG_SRC
        */
        LOG_SRC: "SubStatement",

        /**
        @method log
        */
        log: TinCan.prototype.log,

        /**
        @method init
        @param {Object} [options] Configuration used to initialize (see constructor)
        */
        init: function (cfg) {
            this.log("init");
            var i,
                directProps = [
                    "timestamp"
                ];

            cfg = cfg || {};

            if (cfg.hasOwnProperty("object")) {
                cfg.target = cfg.object;
            }

            if (cfg.hasOwnProperty("actor")) {
                if (typeof cfg.actor.objectType === "undefined" || cfg.actor.objectType === "Person") {
                    cfg.actor.objectType = "Agent";
                }

                if (cfg.actor.objectType === "Agent") {
                    if (cfg.actor instanceof TinCan.Agent) {
                        this.actor = cfg.actor;
                    } else {
                        this.actor = new TinCan.Agent (cfg.actor);
                    }
                } else if (cfg.actor.objectType === "Group") {
                    if (cfg.actor instanceof TinCan.Group) {
                        this.actor = cfg.actor;
                    } else {
                        this.actor = new TinCan.Group (cfg.actor);
                    }
                }
            }
            if (cfg.hasOwnProperty("verb")) {
                if (cfg.verb instanceof TinCan.Verb) {
                    this.verb = cfg.verb;
                } else {
                    this.verb = new TinCan.Verb (cfg.verb);
                }
            }
            if (cfg.hasOwnProperty("target")) {
                if (cfg.target instanceof TinCan.Activity ||
                    cfg.target instanceof TinCan.Agent ||
                    cfg.target instanceof TinCan.Group ||
                    cfg.target instanceof TinCan.SubStatement ||
                    cfg.target instanceof TinCan.StatementRef
                ) {
                    this.target = cfg.target;
                } else {
                    if (typeof cfg.target.objectType === "undefined") {
                        cfg.target.objectType = "Activity";
                    }

                    if (cfg.target.objectType === "Activity") {
                        this.target = new TinCan.Activity (cfg.target);
                    } else if (cfg.target.objectType === "Agent") {
                        this.target = new TinCan.Agent (cfg.target);
                    } else if (cfg.target.objectType === "Group") {
                        this.target = new TinCan.Group (cfg.target);
                    } else if (cfg.target.objectType === "SubStatement") {
                        this.target = new TinCan.SubStatement (cfg.target);
                    } else if (cfg.target.objectType === "StatementRef") {
                        this.target = new TinCan.StatementRef (cfg.target);
                    } else {
                        this.log("Unrecognized target type: " + cfg.target.objectType);
                    }
                }
            }
            if (cfg.hasOwnProperty("result")) {
                if (cfg.result instanceof TinCan.Result) {
                    this.result = cfg.result;
                } else {
                    this.result = new TinCan.Result (cfg.result);
                }
            }
            if (cfg.hasOwnProperty("context")) {
                if (cfg.context instanceof TinCan.Context) {
                    this.context = cfg.context;
                } else {
                    this.context = new TinCan.Context (cfg.context);
                }
            }

            for (i = 0; i < directProps.length; i += 1) {
                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {
                    this[directProps[i]] = cfg[directProps[i]];
                }
            }
        },

        /**
        @method toString
        @return {String} String representation of the statement
        */
        toString: function (lang) {
            this.log("toString");
            return (this.actor !== null ? this.actor.toString(lang) : "") +
                    " " +
                    (this.verb !== null ? this.verb.toString(lang) : "") +
                    " " +
                    (this.target !== null ? this.target.toString(lang) : "");
        },

        /**
        @method asVersion
        @param {String} [version] Version to return (defaults to newest supported)
        */
        asVersion: function (version) {
            this.log("asVersion");
            var result,
                optionalDirectProps = [
                    "timestamp"
                ],
                optionalObjProps = [
                    "actor",
                    "verb",
                    "result",
                    "context"
                ],
                i;

            result = {
                objectType: this.objectType
            };
            version = version || TinCan.versions()[0];

            for (i = 0; i < optionalDirectProps.length; i += 1) {
                if (this[optionalDirectProps[i]] !== null) {
                    result[optionalDirectProps[i]] = this[optionalDirectProps[i]];
                }
            }
            for (i = 0; i < optionalObjProps.length; i += 1) {
                if (this[optionalObjProps[i]] !== null) {
                    result[optionalObjProps[i]] = this[optionalObjProps[i]].asVersion(version);
                }
            }
            if (this.target !== null) {
                result.object = this.target.asVersion(version);
            }

            if (version === "0.9") {
                result.objectType = "Statement";
            }

            return result;
        }
    };

    /**
    @method fromJSON
    @return {Object} SubStatement
    @static
    */
    SubStatement.fromJSON = function (subStJSON) {
        SubStatement.prototype.log("fromJSON");
        var _subSt = JSON.parse(subStJSON);

        return new SubStatement(_subSt);
    };
}());

/*
    Copyright 2012-3 Rustici Software

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
TinCan client library

@module TinCan
@submodule TinCan.Statement
**/
(function () {
    "use strict";

    /**
    @class TinCan.Statement
    @constructor
    @param {Object} [cfg] Values to set in properties
        @param {String} [cfg.id] Statement ID (UUID)
        @param {TinCan.Agent} [cfg.actor] Actor of statement
        @param {TinCan.Verb} [cfg.verb] Verb of statement
        @param {TinCan.Activity|TinCan.Agent|TinCan.Group|TinCan.StatementRef|TinCan.SubStatement} [cfg.object] Alias for 'target'
        @param {TinCan.Activity|TinCan.Agent|TinCan.Group|TinCan.StatementRef|TinCan.SubStatement} [cfg.target] Object of statement
        @param {TinCan.Result} [cfg.result] Statement Result
        @param {TinCan.Context} [cfg.context] Statement Context
        @param {TinCan.Agent} [cfg.authority] Statement Authority
        @param {TinCan.Attachment} [cfg.attachments] Statement Attachments
        @param {String} [cfg.timestamp] ISO8601 Date/time value
        @param {String} [cfg.stored] ISO8601 Date/time value
        @param {String} [cfg.version] Version of the statement (post 0.95)
    @param {Object} [initCfg] Configuration of initialization process
        @param {Integer} [initCfg.storeOriginal] Whether to store a JSON stringified version
            of the original options object, pass number of spaces used for indent
        @param {Boolean} [initCfg.doStamp] Whether to automatically set the 'id' and 'timestamp'
            properties (default: true)
    **/
    var Statement = TinCan.Statement = function (cfg, initCfg) {
        this.log("constructor");

        // check for true value for API backwards compat
        if (typeof initCfg === "number") {
            initCfg = {
                storeOriginal: initCfg
            };
        } else {
            initCfg = initCfg || {};
        }
        if (typeof initCfg.storeOriginal === "undefined") {
            initCfg.storeOriginal = null;
        }
        if (typeof initCfg.doStamp === "undefined") {
            initCfg.doStamp = true;
        }

        /**
        @property id
        @type String
        */
        this.id = null;

        /**
        @property actor
        @type TinCan.Agent|TinCan.Group|null
        */
        this.actor = null;

        /**
        @property verb
        @type TinCan.Verb|null
        */
        this.verb = null;

        /**
        @property target
        @type TinCan.Activity|TinCan.Agent|TinCan.Group|TinCan.StatementRef|TinCan.SubStatement|null
        */
        this.target = null;

        /**
        @property result
        @type Object
        */
        this.result = null;

        /**
        @property context
        @type Object
        */
        this.context = null;

        /**
        @property timestamp
        @type String
        */
        this.timestamp = null;

        /**
        @property stored
        @type String
        */
        this.stored = null;

        /**
        @property authority
        @type TinCan.Agent|null
        */
        this.authority = null;

        /**
        @property attachments
        @type Array of TinCan.Attachment
        */
        this.attachments = null;

        /**
        @property version
        @type String
        */
        this.version = null;

        /**
        @property degraded
        @type Boolean
        @default false
        */
        this.degraded = false;

        /**
        @property voided
        @type Boolean
        @default null
        @deprecated
        */
        this.voided = null;

        /**
        @property inProgress
        @type Boolean
        @deprecated
        */
        this.inProgress = null;

        /**
        @property originalJSON
        @type String
        */
        this.originalJSON = null;

        this.init(cfg, initCfg);
    };

    Statement.prototype = {
        /**
        @property LOG_SRC
        */
        LOG_SRC: "Statement",

        /**
        @method log
        */
        log: TinCan.prototype.log,

        /**
        @method init
        @param {Object} [properties] Configuration used to set properties (see constructor)
        @param {Object} [cfg] Configuration used to initialize (see constructor)
        */
        init: function (cfg, initCfg) {
            this.log("init");
            var i,
                directProps = [
                    "id",
                    "stored",
                    "timestamp",
                    "version",
                    "inProgress",
                    "voided"
                ];

            cfg = cfg || {};

            if (initCfg.storeOriginal) {
                this.originalJSON = JSON.stringify(cfg, null, initCfg.storeOriginal);
            }

            if (cfg.hasOwnProperty("object")) {
                cfg.target = cfg.object;
            }

            if (cfg.hasOwnProperty("actor")) {
                if (typeof cfg.actor.objectType === "undefined" || cfg.actor.objectType === "Person") {
                    cfg.actor.objectType = "Agent";
                }

                if (cfg.actor.objectType === "Agent") {
                    if (cfg.actor instanceof TinCan.Agent) {
                        this.actor = cfg.actor;
                    } else {
                        this.actor = new TinCan.Agent (cfg.actor);
                    }
                } else if (cfg.actor.objectType === "Group") {
                    if (cfg.actor instanceof TinCan.Group) {
                        this.actor = cfg.actor;
                    } else {
                        this.actor = new TinCan.Group (cfg.actor);
                    }
                }
            }
            if (cfg.hasOwnProperty("authority")) {
                if (typeof cfg.authority.objectType === "undefined" || cfg.authority.objectType === "Person") {
                    cfg.authority.objectType = "Agent";
                }

                if (cfg.authority.objectType === "Agent") {
                    if (cfg.authority instanceof TinCan.Agent) {
                        this.authority = cfg.authority;
                    } else {
                        this.authority = new TinCan.Agent (cfg.authority);
                    }
                } else if (cfg.authority.objectType === "Group") {
                    if (cfg.actor instanceof TinCan.Group) {
                        this.authority = cfg.authority;
                    } else {
                        this.authority = new TinCan.Group (cfg.authority);
                    }
                }
            }
            if (cfg.hasOwnProperty("verb")) {
                if (cfg.verb instanceof TinCan.Verb) {
                    this.verb = cfg.verb;
                } else {
                    this.verb = new TinCan.Verb (cfg.verb);
                }
            }
            if (cfg.hasOwnProperty("target")) {
                if (cfg.target instanceof TinCan.Activity ||
                    cfg.target instanceof TinCan.Agent ||
                    cfg.target instanceof TinCan.Group ||
                    cfg.target instanceof TinCan.SubStatement ||
                    cfg.target instanceof TinCan.StatementRef
                ) {
                    this.target = cfg.target;
                } else {
                    if (typeof cfg.target.objectType === "undefined") {
                        cfg.target.objectType = "Activity";
                    }

                    if (cfg.target.objectType === "Activity") {
                        this.target = new TinCan.Activity (cfg.target);
                    } else if (cfg.target.objectType === "Agent") {
                        this.target = new TinCan.Agent (cfg.target);
                    } else if (cfg.target.objectType === "Group") {
                        this.target = new TinCan.Group (cfg.target);
                    } else if (cfg.target.objectType === "SubStatement") {
                        this.target = new TinCan.SubStatement (cfg.target);
                    } else if (cfg.target.objectType === "StatementRef") {
                        this.target = new TinCan.StatementRef (cfg.target);
                    } else {
                        this.log("Unrecognized target type: " + cfg.target.objectType);
                    }
                }
            }
            if (cfg.hasOwnProperty("result")) {
                if (cfg.result instanceof TinCan.Result) {
                    this.result = cfg.result;
                } else {
                    this.result = new TinCan.Result (cfg.result);
                }
            }
            if (cfg.hasOwnProperty("context")) {
                if (cfg.context instanceof TinCan.Context) {
                    this.context = cfg.context;
                } else {
                    this.context = new TinCan.Context (cfg.context);
                }
            }
            if (cfg.hasOwnProperty("attachments") && cfg.attachments !== null) {
                this.attachments = [];
                for (i = 0; i < cfg.attachments.length; i += 1) {
                    if (! (cfg.attachments[i] instanceof TinCan.Attachment)) {
                        this.attachments.push(new TinCan.Attachment (cfg.attachments[i]));
                    }
                    else {
                        this.attachments.push(cfg.attachments[i]);
                    }
                }
            }

            for (i = 0; i < directProps.length; i += 1) {
                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {
                    this[directProps[i]] = cfg[directProps[i]];
                }
            }

            if (initCfg.doStamp) {
                this.stamp();
            }
        },

        /**
        @method toString
        @return {String} String representation of the statement
        */
        toString: function (lang) {
            this.log("toString");
            return (this.actor !== null ? this.actor.toString(lang) : "") +
                    " " +
                    (this.verb !== null ? this.verb.toString(lang) : "") +
                    " " +
                    (this.target !== null ? this.target.toString(lang) : "");
        },

        /**
        @method asVersion
        @param {String} [version] Version to return (defaults to newest supported)
        */
        asVersion: function (version) {
            this.log("asVersion");
            var result = {},
                optionalDirectProps = [
                    "id",
                    "timestamp"
                ],
                optionalObjProps = [
                    "actor",
                    "verb",
                    "result",
                    "context",
                    "authority"
                ],
                i;

            version = version || TinCan.versions()[0];

            for (i = 0; i < optionalDirectProps.length; i += 1) {
                if (this[optionalDirectProps[i]] !== null) {
                    result[optionalDirectProps[i]] = this[optionalDirectProps[i]];
                }
            }
            for (i = 0; i < optionalObjProps.length; i += 1) {
                if (this[optionalObjProps[i]] !== null) {
                    result[optionalObjProps[i]] = this[optionalObjProps[i]].asVersion(version);
                }
            }
            if (this.target !== null) {
                result.object = this.target.asVersion(version);
            }

            if (version === "0.9" || version === "0.95") {
                if (this.voided !== null) {
                    result.voided = this.voided;
                }
            }
            if (version === "0.9" && this.inProgress !== null) {
                result.inProgress = this.inProgress;
            }
            if (this.attachments !== null) {
                if (! (version === "0.9" || version === "0.95")) {
                    result.attachments = [];
                    for (i = 0; i < this.attachments.length; i += 1) {
                        if (this.attachments[i] instanceof TinCan.Attachment) {
                            result.attachments.push(this.attachments[i].asVersion(version));
                        }
                        else {
                            result.attachments.push(new TinCan.Attachment(this.attachments[i]).asVersion(version));
                        }
                    }
                }
            }

            return result;
        },

        /**
        Sets 'id' and 'timestamp' properties if not already set

        @method stamp
        */
        stamp: function () {
            this.log("stamp");
            if (this.id === null) {
                this.id = TinCan.Utils.getUUID();
            }
            if (this.timestamp === null) {
                this.timestamp = TinCan.Utils.getISODateString(new Date());
            }
        },

        /**
        Checks if the Statement has at least one attachment with content

        @method hasAttachmentsWithContent
        */
        hasAttachmentWithContent: function () {
            this.log("hasAttachmentWithContent");
            var i;

            if (this.attachments === null) {
                return false;
            }

            for (i = 0; i < this.attachments.length; i += 1) {
                if (this.attachments[i].content !== null) {
                    return true;
                }
            }

            return false;
        }
    };

    /**
    @method fromJSON
    @return {Object} Statement
    @static
    */
    Statement.fromJSON = function (stJSON) {
        Statement.prototype.log("fromJSON");
        var _st = JSON.parse(stJSON);

        return new Statement(_st);
    };
}());

/*
    Copyright 2012 Rustici Software

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
TinCan client library

@module TinCan
@submodule TinCan.StatementsResult
**/
(function () {
    "use strict";

    /**
    @class TinCan.StatementsResult
    @constructor
    @param {Object} options Configuration used to initialize.
        @param {Array} options.statements Actor of statement
        @param {String} options.more URL to fetch more data
    **/
    var StatementsResult = TinCan.StatementsResult = function (cfg) {
        this.log("constructor");

        /**
        @property statements
        @type Array
        */
        this.statements = null;

        /**
        @property more
        @type String
        */
        this.more = null;

        this.init(cfg);
    };

    StatementsResult.prototype = {
        /**
        @property LOG_SRC
        */
        LOG_SRC: "StatementsResult",

        /**
        @method log
        */
        log: TinCan.prototype.log,

        /**
        @method init
        @param {Object} [options] Configuration used to initialize
        */
        init: function (cfg) {
            this.log("init");

            cfg = cfg || {};

            if (cfg.hasOwnProperty("statements")) {
                this.statements = cfg.statements;
            }
            if (cfg.hasOwnProperty("more")) {
                this.more = cfg.more;
            }
        }
    };

    /**
    @method fromJSON
    @return {Object} Agent
    @static
    */
    StatementsResult.fromJSON = function (resultJSON) {
        StatementsResult.prototype.log("fromJSON");
        var _result,
            stmts = [],
            stmt,
            i
        ;

        try {
            _result = JSON.parse(resultJSON);
        } catch (parseError) {
            StatementsResult.prototype.log("fromJSON - JSON.parse error: " + parseError);
        }

        if (_result) {
            for (i = 0; i < _result.statements.length; i += 1) {
                try {
                    stmt = new TinCan.Statement (_result.statements[i], 4);
                } catch (error) {
                    StatementsResult.prototype.log("fromJSON - statement instantiation failed: " + error + " (" + JSON.stringify(_result.statements[i]) + ")");

                    stmt = new TinCan.Statement (
                        {
                            id: _result.statements[i].id
                        },
                        4
                    );
                }

                stmts.push(stmt);
            }
            _result.statements = stmts;
        }

        return new StatementsResult (_result);
    };
}());

/*
    Copyright 2012 Rustici Software

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
TinCan client library

@module TinCan
@submodule TinCan.State
**/
(function () {
    "use strict";

    /**
    @class TinCan.State
    @constructor
    */
    var State = TinCan.State = function (cfg) {
        this.log("constructor");

        /**
        @property id
        @type String
        */
        this.id = null;

        /**
        @property updated
        @type Boolean
        */
        this.updated = null;

        /**
        @property contents
        @type String
        */
        this.contents = null;

        /**
        @property etag
        @type String
        */
        this.etag = null;

        /**
        @property contentType
        @type String
        */
        this.contentType = null;

        this.init(cfg);
    };
    State.prototype = {
        /**
        @property LOG_SRC
        */
        LOG_SRC: "State",

        /**
        @method log
        */
        log: TinCan.prototype.log,

        /**
        @method init
        @param {Object} [options] Configuration used to initialize
        */
        init: function (cfg) {
            this.log("init");
            var i,
                directProps = [
                    "id",
                    "contents",
                    "etag",
                    "contentType"
                ];

            cfg = cfg || {};

            for (i = 0; i < directProps.length; i += 1) {
                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {
                    this[directProps[i]] = cfg[directProps[i]];
                }
            }

            this.updated = false;
        }
    };

    /**
    @method fromJSON
    @return {Object} State
    @static
    */
    State.fromJSON = function (stateJSON) {
        State.prototype.log("fromJSON");
        var _state = JSON.parse(stateJSON);

        return new State(_state);
    };
}());

/*
    Copyright 2012 Rustici Software

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
TinCan client library

@module TinCan
@submodule TinCan.ActivityProfile
**/
(function () {
    "use strict";

    /**
    @class TinCan.ActivityProfile
    @constructor
    */
    var ActivityProfile = TinCan.ActivityProfile = function (cfg) {
        this.log("constructor");

        /**
        @property id
        @type String
        */
        this.id = null;

        /**
        @property activity
        @type TinCan.Activity
        */
        this.activity = null;

        /**
        @property updated
        @type String
        */
        this.updated = null;

        /**
        @property contents
        @type String
        */
        this.contents = null;

        /**
        SHA1 of contents as provided by the server during last fetch,
        this should be passed through to saveActivityProfile

        @property etag
        @type String
        */
        this.etag = null;

        /**
        @property contentType
        @type String
        */
        this.contentType = null;

        this.init(cfg);
    };
    ActivityProfile.prototype = {
        /**
        @property LOG_SRC
        */
        LOG_SRC: "ActivityProfile",

        /**
        @method log
        */
        log: TinCan.prototype.log,

        /**
        @method init
        @param {Object} [options] Configuration used to initialize
        */
        init: function (cfg) {
            this.log("init");
            var i,
                directProps = [
                    "id",
                    "contents",
                    "etag",
                    "contentType"
                ];

            cfg = cfg || {};

            if (cfg.hasOwnProperty("activity")) {
                if (cfg.activity instanceof TinCan.Activity) {
                    this.activity = cfg.activity;
                }
                else {
                    this.activity = new TinCan.Activity (cfg.activity);
                }
            }

            for (i = 0; i < directProps.length; i += 1) {
                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {
                    this[directProps[i]] = cfg[directProps[i]];
                }
            }

            this.updated = false;
        }
    };

    /**
    @method fromJSON
    @return {Object} ActivityProfile
    @static
    */
    ActivityProfile.fromJSON = function (stateJSON) {
        ActivityProfile.prototype.log("fromJSON");
        var _state = JSON.parse(stateJSON);

        return new ActivityProfile(_state);
    };
}());

/*
    Copyright 2013 Rustici Software

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
TinCan client library

@module TinCan
@submodule TinCan.AgentProfile
**/
(function () {
    "use strict";

    /**
    @class TinCan.AgentProfile
    @constructor
    */
    var AgentProfile = TinCan.AgentProfile = function (cfg) {
        this.log("constructor");

        /**
        @property id
        @type String
        */
        this.id = null;

        /**
        @property agent
        @type TinCan.Agent
        */
        this.agent = null;

        /**
        @property updated
        @type String
        */
        this.updated = null;

        /**
        @property contents
        @type String
        */
        this.contents = null;

        /**
        SHA1 of contents as provided by the server during last fetch,
        this should be passed through to saveAgentProfile

        @property etag
        @type String
        */
        this.etag = null;

        /**
        @property contentType
        @type String
        */
        this.contentType = null;

        this.init(cfg);
    };
    AgentProfile.prototype = {
        /**
        @property LOG_SRC
        */
        LOG_SRC: "AgentProfile",

        /**
        @method log
        */
        log: TinCan.prototype.log,

        /**
        @method init
        @param {Object} [options] Configuration used to initialize
        */
        init: function (cfg) {
            this.log("init");
            var i,
                directProps = [
                    "id",
                    "contents",
                    "etag",
                    "contentType"
                ];

            cfg = cfg || {};

            if (cfg.hasOwnProperty("agent")) {
                if (cfg.agent instanceof TinCan.Agent) {
                    this.agent = cfg.agent;
                }
                else {
                    this.agent = new TinCan.Agent (cfg.agent);
                }
            }

            for (i = 0; i < directProps.length; i += 1) {
                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {
                    this[directProps[i]] = cfg[directProps[i]];
                }
            }

            this.updated = false;
        }
    };

    /**
    @method fromJSON
    @return {Object} AgentProfile
    @static
    */
    AgentProfile.fromJSON = function (stateJSON) {
        AgentProfile.prototype.log("fromJSON");
        var _state = JSON.parse(stateJSON);

        return new AgentProfile(_state);
    };
}());

/*
    Copyright 2014 Rustici Software

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
TinCan client library

@module TinCan
@submodule TinCan.About
**/
(function () {
    "use strict";

    /**
    @class TinCan.About
    @constructor
    */
    var About = TinCan.About = function (cfg) {
        this.log("constructor");

        /**
        @property version
        @type {String[]}
        */
        this.version = null;

        this.init(cfg);
    };
    About.prototype = {
        /**
        @property LOG_SRC
        */
        LOG_SRC: "About",

        /**
        @method log
        */
        log: TinCan.prototype.log,

        /**
        @method init
        @param {Object} [options] Configuration used to initialize
        */
        init: function (cfg) {
            this.log("init");
            var i,
                directProps = [
                    "version"
                ];

            cfg = cfg || {};

            for (i = 0; i < directProps.length; i += 1) {
                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {
                    this[directProps[i]] = cfg[directProps[i]];
                }
            }
        }
    };

    /**
    @method fromJSON
    @return {Object} About
    @static
    */
    About.fromJSON = function (aboutJSON) {
        About.prototype.log("fromJSON");
        var _about = JSON.parse(aboutJSON);

        return new About(_about);
    };
}());

/*
    Copyright 2016 Rustici Software

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
TinCan client library

@module TinCan
@submodule TinCan.Attachment
**/
(function () {
    "use strict";

    /**
    @class TinCan.Attachment
    @constructor
    */
    var Attachment = TinCan.Attachment = function (cfg) {
        this.log("constructor");

        /**
        @property usageType
        @type String
        */
        this.usageType = null;

        /**
        @property display
        @type Object
        */
        this.display = null;

        /**
        @property contentType
        @type String
        */
        this.contentType = null;

        /**
        @property length
        @type int
        */
        this.length = null;

        /**
        @property sha2
        @type String
        */
        this.sha2 = null;

        /**
        @property description
        @type Object
        */
        this.description = null;

        /**
        @property fileUrl
        @type String
        */
        this.fileUrl = null;

        /**
        @property content
        @type ArrayBuffer
        */
        this.content = null;

        this.init(cfg);
    };
    Attachment.prototype = {
        /**
        @property LOG_SRC
        */
        LOG_SRC: "Attachment",

        /**
        @method log
        */
        log: TinCan.prototype.log,

        /**
        @method init
        @param {Object} [options] Configuration used to initialize
        */
        init: function (cfg) {
            this.log("init");
            var i,
                directProps = [
                    "contentType",
                    "length",
                    "sha2",
                    "usageType",
                    "display",
                    "description",
                    "fileUrl"
                ]
            ;

            cfg = cfg || {};

            for (i = 0; i < directProps.length; i += 1) {
                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {
                    this[directProps[i]] = cfg[directProps[i]];
                }
            }

            if (cfg.hasOwnProperty("content") && cfg.content !== null) {
                if (typeof cfg.content === "string") {
                    this.setContentFromString(cfg.content);
                }
                else {
                    this.setContent(cfg.content);
                }
            }
        },

        /**
        @method asVersion
        @param {String} [version] Version to return (defaults to newest supported)
        */
        asVersion: function (version) {
            this.log("asVersion");
            var result;

            version = version || TinCan.versions()[0];

            if (version === "0.9" || version === "0.95") {
                result = null;
            }
            else {
                result = {
                    contentType: this.contentType,
                    display: this.display,
                    length: this.length,
                    sha2: this.sha2,
                    usageType: this.usageType
                };

                if (this.fileUrl !== null) {
                    result.fileUrl = this.fileUrl;
                }
                if (this.description !== null) {
                    result.description = this.description;
                }
            }

            return result;
        },

        /**
        See {{#crossLink "TinCan.Utils/getLangDictionaryValue"}}{{/crossLink}}

        @method getLangDictionaryValue
        */
        getLangDictionaryValue: TinCan.Utils.getLangDictionaryValue,

        /**
        @method setContent
        @param {ArrayBuffer} content Sets content from ArrayBuffer
        */
        setContent: function (content) {
            this.content = content;
            this.length = content.byteLength;
            this.sha2 = TinCan.Utils.getSHA256String(content);
        },

        /**
        @method setContentFromString
        @param {String} content Sets the content property of the attachment from a string
        */
        setContentFromString: function (content) {
            var _content = content;

            _content = TinCan.Utils.stringToArrayBuffer(content);

            this.setContent(_content);
        },

        /**
        @method getContentAsString
        @return {String} Value of content property as a string
        */
        getContentAsString: function () {
            return TinCan.Utils.stringFromArrayBuffer(this.content);
        }
    };

    /**
    @method fromJSON
    @return {Object} Attachment
    @static
    */
    Attachment.fromJSON = function (attachmentJSON) {
        Attachment.prototype.log("fromJSON");
        var _attachment = JSON.parse(attachmentJSON);

        return new Attachment(_attachment);
    };

    Attachment._defaultEncoding = "utf-8";
}());

/*
    Copyright 2012-2013 Rustici Software

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
TinCan client library

@module TinCan
@submodule TinCan.Environment.Node
**/
(function () {
    /* globals require,Buffer,ArrayBuffer,Uint8Array */
    "use strict";
    var LOG_SRC = "Environment.Node",
        log = TinCan.prototype.log,
        querystring = require("querystring"),
        XMLHttpRequest = require("xhr2"),
        requestComplete,
        __createJSONSegment,
        __createAttachmentSegment;

    requestComplete = function (xhr, cfg) {
        log("requestComplete - xhr.status: " + xhr.status, LOG_SRC);
        log("requestComplete - xhr.responseText: " + xhr.responseText, LOG_SRC);
        var requestCompleteResult,
            httpStatus = xhr.status,
            notFoundOk = (cfg.ignore404 && httpStatus === 404);

        if ((httpStatus >= 200 && httpStatus < 400) || notFoundOk) {
            if (cfg.callback) {
                cfg.callback(null, xhr);
                return;
            }

            requestCompleteResult = {
                err: null,
                xhr: xhr
            };
            return requestCompleteResult;
        }

        requestCompleteResult = {
            err: httpStatus,
            xhr: xhr
        };
        if (httpStatus === 0) {
            log("[warning] There was a problem communicating with the Learning Record Store. Aborted, offline, or invalid CORS endpoint (" + httpStatus + ")", LOG_SRC);
        }
        else {
            log("[warning] There was a problem communicating with the Learning Record Store. (" + httpStatus + " | " + xhr.responseText+ ")", LOG_SRC);
        }
        if (cfg.callback) {
            cfg.callback(httpStatus, xhr);
        }
        return requestCompleteResult;
    };

    //
    // Override LRS' init method to set up our request handling
    // capabilities, basically empty implementation here so that
    // we don't get a no-env loaded message
    //
    TinCan.LRS.prototype._initByEnvironment = function () {};

    //
    // use XMLHttpRequest module instead of standard Node.js http/https
    // modules since we have to support both, and because the callbacks
    // provided via the methods calling _makeRequest expect the xhr to
    // have a certain interface, that interface happens to be the browser
    // version of XHR since that's where it started, so rather than
    // changing them to use a different wrapped request/response object
    // set just use a wrapped version of the node objects which is what
    // XMLHttpRequest module provides
    //
    TinCan.LRS.prototype._makeRequest = function (fullUrl, headers, cfg) {
        log("_makeRequest using http/https", LOG_SRC);
        var xhr,
            url = fullUrl,
            async = typeof cfg.callback !== "undefined",
            prop
        ;
        if (typeof cfg.params !== "undefined" && Object.keys(cfg.params).length > 0) {
            url += "?" + querystring.stringify(cfg.params);
        }

        xhr = new XMLHttpRequest();
        xhr.open(cfg.method, url, async);

        if (cfg.expectMultipart) {
            xhr.responseType = "arraybuffer";
        }

        for (prop in headers) {
            if (headers.hasOwnProperty(prop)) {
                xhr.setRequestHeader(prop, headers[prop]);
            }
        }

        if (typeof cfg.data !== "undefined") {
            cfg.data += "";
        }

        if (async) {
            xhr.onreadystatechange = function () {
                log("xhr.onreadystatechange - xhr.readyState: " + xhr.readyState, LOG_SRC);
                if (xhr.readyState === 4) {
                    requestComplete(xhr, cfg);
                }
            };
        }

        xhr.send(cfg.data);

        if (async) {
            return xhr;
        }

        return requestComplete(xhr, cfg);
    };

    //
    // Synchronos xhr handling is unsupported in node
    //
    TinCan.LRS.syncEnabled = false;

    TinCan.LRS.prototype._getMultipartRequestData = function (boundary, jsonContent, requestAttachments) {
        var parts = [],
            i;

        parts.push(
            __createJSONSegment(
                boundary,
                jsonContent
            )
        );
        for (i = 0; i < requestAttachments.length; i += 1) {
            if (requestAttachments[i].content !== null) {
                parts.push(
                    __createAttachmentSegment(
                        boundary,
                        requestAttachments[i].content,
                        requestAttachments[i].sha2,
                        requestAttachments[i].contentType
                    )
                );
            }
        }
        if (typeof Buffer.from === "undefined") {
            parts.push( new Buffer("\r\n--" + boundary + "--\r\n") );
        }
        else {
            parts.push( Buffer.from("\r\n--" + boundary + "--\r\n") );
        }

        return Buffer.concat(parts);
    };

    __createJSONSegment = function (boundary, jsonContent) {
        var content = [
                "--" + boundary,
                "Content-Type: application/json",
                "",
                JSON.stringify(jsonContent)
            ].join("\r\n");

        content += "\r\n";

        if (typeof Buffer.from === "undefined") {
            return new Buffer(content);
        }
        return Buffer.from(content);
    };

    __createAttachmentSegment = function (boundary, content, sha2, contentType) {
        var bufferParts = [],
            header = [
                "--" + boundary,
                "Content-Type: " + contentType,
                "Content-Transfer-Encoding: binary",
                "X-Experience-API-Hash: " + sha2
            ].join("\r\n");

        header += "\r\n\r\n";

        if (typeof Buffer.from === "undefined") {
            bufferParts.push( new Buffer(header) );
            bufferParts.push( new Buffer(content) );
        }
        else {
            bufferParts.push(Buffer.from(header));
            bufferParts.push(Buffer.from(content));
        }

        return Buffer.concat(bufferParts);
    };

    TinCan.Utils.stringToArrayBuffer = function (content, encoding) {
        var b,
            ab,
            view,
            i;

        if (! encoding) {
            encoding = TinCan.Utils.defaultEncoding;
        }

        if (typeof Buffer.from === "undefined") {
            // for Node.js prior to v4.x
            b = new Buffer(content, encoding);

            ab = new ArrayBuffer(b.length);
            view = new Uint8Array(ab);
            for (i = 0; i < b.length; i += 1) {
                view[i] = b[i];
            }

            return ab;
        }

        b = Buffer.from(content, encoding);
        ab = b.buffer;

        //
        // this .slice is required because of the internals of how Buffer is
        // implemented, it uses a shared ArrayBuffer underneath for small buffers
        // see http://stackoverflow.com/a/31394257/1464957
        //
        return ab.slice(b.byteOffset, b.byteOffset + b.byteLength);
    };

    TinCan.Utils.stringFromArrayBuffer = function (content, encoding) {
        var b,
            view,
            i;

        if (! encoding) {
            encoding = TinCan.Utils.defaultEncoding;
        }

        if (typeof Buffer.from === "undefined") {
            // for Node.js prior to v4.x
            b = new Buffer(content.byteLength);

            view = new Uint8Array(content);
            for (i = 0; i < b.length; i += 1) {
                b[i] = view[i];
            }
        }
        else {
            b = Buffer.from(content);
        }

        return b.toString(encoding);
    };
}());

}).call(this,require("buffer").Buffer)
},{"buffer":44,"querystring":93,"xhr2":142}],136:[function(require,module,exports){
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

},{}],137:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],138:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

},{"punycode":89,"querystring":93}],139:[function(require,module,exports){
(function (global){
/*! https://mths.be/utf8js v2.0.0 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	function checkScalarValue(codePoint) {
		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
	}
	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			checkScalarValue(codePoint);
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, it’s not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			var byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				checkScalarValue(codePoint);
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		'version': '2.0.0',
		'encode': utf8encode,
		'decode': utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define(function() {
			return utf8;
		});
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],140:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],141:[function(require,module,exports){
/*!
 * validate.js 0.9.0
 *
 * (c) 2013-2015 Nicklas Ansman, 2013 Wrapp
 * Validate.js may be freely distributed under the MIT license.
 * For all details and documentation:
 * http://validatejs.org/
 */

(function(exports, module, define) {
  "use strict";

  // The main function that calls the validators specified by the constraints.
  // The options are the following:
  //   - format (string) - An option that controls how the returned value is formatted
  //     * flat - Returns a flat array of just the error messages
  //     * grouped - Returns the messages grouped by attribute (default)
  //     * detailed - Returns an array of the raw validation data
  //   - fullMessages (boolean) - If `true` (default) the attribute name is prepended to the error.
  //
  // Please note that the options are also passed to each validator.
  var validate = function(attributes, constraints, options) {
    options = v.extend({}, v.options, options);

    var results = v.runValidations(attributes, constraints, options)
      , attr
      , validator;

    for (attr in results) {
      for (validator in results[attr]) {
        if (v.isPromise(results[attr][validator])) {
          throw new Error("Use validate.async if you want support for promises");
        }
      }
    }
    return validate.processValidationResults(results, options);
  };

  var v = validate;

  // Copies over attributes from one or more sources to a single destination.
  // Very much similar to underscore's extend.
  // The first argument is the target object and the remaining arguments will be
  // used as sources.
  v.extend = function(obj) {
    [].slice.call(arguments, 1).forEach(function(source) {
      for (var attr in source) {
        obj[attr] = source[attr];
      }
    });
    return obj;
  };

  v.extend(validate, {
    // This is the version of the library as a semver.
    // The toString function will allow it to be coerced into a string
    version: {
      major: 0,
      minor: 9,
      patch: 0,
      metadata: null,
      toString: function() {
        var version = v.format("%{major}.%{minor}.%{patch}", v.version);
        if (!v.isEmpty(v.version.metadata)) {
          version += "+" + v.version.metadata;
        }
        return version;
      }
    },

    // Below is the dependencies that are used in validate.js

    // The constructor of the Promise implementation.
    // If you are using Q.js, RSVP or any other A+ compatible implementation
    // override this attribute to be the constructor of that promise.
    // Since jQuery promises aren't A+ compatible they won't work.
    Promise: typeof Promise !== "undefined" ? Promise : /* istanbul ignore next */ null,

    EMPTY_STRING_REGEXP: /^\s*$/,

    // Runs the validators specified by the constraints object.
    // Will return an array of the format:
    //     [{attribute: "<attribute name>", error: "<validation result>"}, ...]
    runValidations: function(attributes, constraints, options) {
      var results = []
        , attr
        , validatorName
        , value
        , validators
        , validator
        , validatorOptions
        , error;

      if (v.isDomElement(attributes) || v.isJqueryElement(attributes)) {
        attributes = v.collectFormValues(attributes);
      }

      // Loops through each constraints, finds the correct validator and run it.
      for (attr in constraints) {
        value = v.getDeepObjectValue(attributes, attr);
        // This allows the constraints for an attribute to be a function.
        // The function will be called with the value, attribute name, the complete dict of
        // attributes as well as the options and constraints passed in.
        // This is useful when you want to have different
        // validations depending on the attribute value.
        validators = v.result(constraints[attr], value, attributes, attr, options, constraints);

        for (validatorName in validators) {
          validator = v.validators[validatorName];

          if (!validator) {
            error = v.format("Unknown validator %{name}", {name: validatorName});
            throw new Error(error);
          }

          validatorOptions = validators[validatorName];
          // This allows the options to be a function. The function will be
          // called with the value, attribute name, the complete dict of
          // attributes as well as the options and constraints passed in.
          // This is useful when you want to have different
          // validations depending on the attribute value.
          validatorOptions = v.result(validatorOptions, value, attributes, attr, options, constraints);
          if (!validatorOptions) {
            continue;
          }
          results.push({
            attribute: attr,
            value: value,
            validator: validatorName,
            globalOptions: options,
            attributes: attributes,
            options: validatorOptions,
            error: validator.call(validator,
                value,
                validatorOptions,
                attr,
                attributes,
                options)
          });
        }
      }

      return results;
    },

    // Takes the output from runValidations and converts it to the correct
    // output format.
    processValidationResults: function(errors, options) {
      var attr;

      errors = v.pruneEmptyErrors(errors, options);
      errors = v.expandMultipleErrors(errors, options);
      errors = v.convertErrorMessages(errors, options);

      switch (options.format || "grouped") {
        case "detailed":
          // Do nothing more to the errors
          break;

        case "flat":
          errors = v.flattenErrorsToArray(errors);
          break;

        case "grouped":
          errors = v.groupErrorsByAttribute(errors);
          for (attr in errors) {
            errors[attr] = v.flattenErrorsToArray(errors[attr]);
          }
          break;

        default:
          throw new Error(v.format("Unknown format %{format}", options));
      }

      return v.isEmpty(errors) ? undefined : errors;
    },

    // Runs the validations with support for promises.
    // This function will return a promise that is settled when all the
    // validation promises have been completed.
    // It can be called even if no validations returned a promise.
    async: function(attributes, constraints, options) {
      options = v.extend({}, v.async.options, options);

      var WrapErrors = options.wrapErrors || function(errors) {
        return errors;
      };

      // Removes unknown attributes
      if (options.cleanAttributes !== false) {
        attributes = v.cleanAttributes(attributes, constraints);
      }

      var results = v.runValidations(attributes, constraints, options);

      return new v.Promise(function(resolve, reject) {
        v.waitForResults(results).then(function() {
          var errors = v.processValidationResults(results, options);
          if (errors) {
            reject(new WrapErrors(errors, options, attributes, constraints));
          } else {
            resolve(attributes);
          }
        }, function(err) {
          reject(err);
        });
      });
    },

    single: function(value, constraints, options) {
      options = v.extend({}, v.single.options, options, {
        format: "flat",
        fullMessages: false
      });
      return v({single: value}, {single: constraints}, options);
    },

    // Returns a promise that is resolved when all promises in the results array
    // are settled. The promise returned from this function is always resolved,
    // never rejected.
    // This function modifies the input argument, it replaces the promises
    // with the value returned from the promise.
    waitForResults: function(results) {
      // Create a sequence of all the results starting with a resolved promise.
      return results.reduce(function(memo, result) {
        // If this result isn't a promise skip it in the sequence.
        if (!v.isPromise(result.error)) {
          return memo;
        }

        return memo.then(function() {
          return result.error.then(
            function(error) {
              result.error = error || null;
            },
            function(error) {
              if (error instanceof Error) {
                throw error;
              }
              v.error("Rejecting promises with the result is deprecated. Please use the resolve callback instead.");
              result.error = error;
            }
          );
        });
      }, new v.Promise(function(r) { r(); })); // A resolved promise
    },

    // If the given argument is a call: function the and: function return the value
    // otherwise just return the value. Additional arguments will be passed as
    // arguments to the function.
    // Example:
    // ```
    // result('foo') // 'foo'
    // result(Math.max, 1, 2) // 2
    // ```
    result: function(value) {
      var args = [].slice.call(arguments, 1);
      if (typeof value === 'function') {
        value = value.apply(null, args);
      }
      return value;
    },

    // Checks if the value is a number. This function does not consider NaN a
    // number like many other `isNumber` functions do.
    isNumber: function(value) {
      return typeof value === 'number' && !isNaN(value);
    },

    // Returns false if the object is not a function
    isFunction: function(value) {
      return typeof value === 'function';
    },

    // A simple check to verify that the value is an integer. Uses `isNumber`
    // and a simple modulo check.
    isInteger: function(value) {
      return v.isNumber(value) && value % 1 === 0;
    },

    // Uses the `Object` function to check if the given argument is an object.
    isObject: function(obj) {
      return obj === Object(obj);
    },

    // Simply checks if the object is an instance of a date
    isDate: function(obj) {
      return obj instanceof Date;
    },

    // Returns false if the object is `null` of `undefined`
    isDefined: function(obj) {
      return obj !== null && obj !== undefined;
    },

    // Checks if the given argument is a promise. Anything with a `then`
    // function is considered a promise.
    isPromise: function(p) {
      return !!p && v.isFunction(p.then);
    },

    isJqueryElement: function(o) {
      return o && v.isString(o.jquery);
    },

    isDomElement: function(o) {
      if (!o) {
        return false;
      }

      if (!v.isFunction(o.querySelectorAll) || !v.isFunction(o.querySelector)) {
        return false;
      }

      if (v.isObject(document) && o === document) {
        return true;
      }

      // http://stackoverflow.com/a/384380/699304
      /* istanbul ignore else */
      if (typeof HTMLElement === "object") {
        return o instanceof HTMLElement;
      } else {
        return o &&
          typeof o === "object" &&
          o !== null &&
          o.nodeType === 1 &&
          typeof o.nodeName === "string";
      }
    },

    isEmpty: function(value) {
      var attr;

      // Null and undefined are empty
      if (!v.isDefined(value)) {
        return true;
      }

      // functions are non empty
      if (v.isFunction(value)) {
        return false;
      }

      // Whitespace only strings are empty
      if (v.isString(value)) {
        return v.EMPTY_STRING_REGEXP.test(value);
      }

      // For arrays we use the length property
      if (v.isArray(value)) {
        return value.length === 0;
      }

      // Dates have no attributes but aren't empty
      if (v.isDate(value)) {
        return false;
      }

      // If we find at least one property we consider it non empty
      if (v.isObject(value)) {
        for (attr in value) {
          return false;
        }
        return true;
      }

      return false;
    },

    // Formats the specified strings with the given values like so:
    // ```
    // format("Foo: %{foo}", {foo: "bar"}) // "Foo bar"
    // ```
    // If you want to write %{...} without having it replaced simply
    // prefix it with % like this `Foo: %%{foo}` and it will be returned
    // as `"Foo: %{foo}"`
    format: v.extend(function(str, vals) {
      if (!v.isString(str)) {
        return str;
      }
      return str.replace(v.format.FORMAT_REGEXP, function(m0, m1, m2) {
        if (m1 === '%') {
          return "%{" + m2 + "}";
        } else {
          return String(vals[m2]);
        }
      });
    }, {
      // Finds %{key} style patterns in the given string
      FORMAT_REGEXP: /(%?)%\{([^\}]+)\}/g
    }),

    // "Prettifies" the given string.
    // Prettifying means replacing [.\_-] with spaces as well as splitting
    // camel case words.
    prettify: function(str) {
      if (v.isNumber(str)) {
        // If there are more than 2 decimals round it to two
        if ((str * 100) % 1 === 0) {
          return "" + str;
        } else {
          return parseFloat(Math.round(str * 100) / 100).toFixed(2);
        }
      }

      if (v.isArray(str)) {
        return str.map(function(s) { return v.prettify(s); }).join(", ");
      }

      if (v.isObject(str)) {
        return str.toString();
      }

      // Ensure the string is actually a string
      str = "" + str;

      return str
        // Splits keys separated by periods
        .replace(/([^\s])\.([^\s])/g, '$1 $2')
        // Removes backslashes
        .replace(/\\+/g, '')
        // Replaces - and - with space
        .replace(/[_-]/g, ' ')
        // Splits camel cased words
        .replace(/([a-z])([A-Z])/g, function(m0, m1, m2) {
          return "" + m1 + " " + m2.toLowerCase();
        })
        .toLowerCase();
    },

    stringifyValue: function(value) {
      return v.prettify(value);
    },

    isString: function(value) {
      return typeof value === 'string';
    },

    isArray: function(value) {
      return {}.toString.call(value) === '[object Array]';
    },

    contains: function(obj, value) {
      if (!v.isDefined(obj)) {
        return false;
      }
      if (v.isArray(obj)) {
        return obj.indexOf(value) !== -1;
      }
      return value in obj;
    },

    forEachKeyInKeypath: function(object, keypath, callback) {
      if (!v.isString(keypath)) {
        return undefined;
      }

      var key = ""
        , i
        , escape = false;

      for (i = 0; i < keypath.length; ++i) {
        switch (keypath[i]) {
          case '.':
            if (escape) {
              escape = false;
              key += '.';
            } else {
              object = callback(object, key, false);
              key = "";
            }
            break;

          case '\\':
            if (escape) {
              escape = false;
              key += '\\';
            } else {
              escape = true;
            }
            break;

          default:
            escape = false;
            key += keypath[i];
            break;
        }
      }

      return callback(object, key, true);
    },

    getDeepObjectValue: function(obj, keypath) {
      if (!v.isObject(obj)) {
        return undefined;
      }

      return v.forEachKeyInKeypath(obj, keypath, function(obj, key) {
        if (v.isObject(obj)) {
          return obj[key];
        }
      });
    },

    // This returns an object with all the values of the form.
    // It uses the input name as key and the value as value
    // So for example this:
    // <input type="text" name="email" value="foo@bar.com" />
    // would return:
    // {email: "foo@bar.com"}
    collectFormValues: function(form, options) {
      var values = {}
        , i
        , input
        , inputs
        , value;

      if (v.isJqueryElement(form)) {
        form = form[0];
      }

      if (!form) {
        return values;
      }

      options = options || {};

      inputs = form.querySelectorAll("input[name], textarea[name]");
      for (i = 0; i < inputs.length; ++i) {
        input = inputs.item(i);

        if (v.isDefined(input.getAttribute("data-ignored"))) {
          continue;
        }

        value = v.sanitizeFormValue(input.value, options);
        if (input.type === "number") {
          value = value ? +value : null;
        } else if (input.type === "checkbox") {
          if (input.attributes.value) {
            if (!input.checked) {
              value = values[input.name] || null;
            }
          } else {
            value = input.checked;
          }
        } else if (input.type === "radio") {
          if (!input.checked) {
            value = values[input.name] || null;
          }
        }
        values[input.name] = value;
      }

      inputs = form.querySelectorAll("select[name]");
      for (i = 0; i < inputs.length; ++i) {
        input = inputs.item(i);
        value = v.sanitizeFormValue(input.options[input.selectedIndex].value, options);
        values[input.name] = value;
      }

      return values;
    },

    sanitizeFormValue: function(value, options) {
      if (options.trim && v.isString(value)) {
        value = value.trim();
      }

      if (options.nullify !== false && value === "") {
        return null;
      }
      return value;
    },

    capitalize: function(str) {
      if (!v.isString(str)) {
        return str;
      }
      return str[0].toUpperCase() + str.slice(1);
    },

    // Remove all errors who's error attribute is empty (null or undefined)
    pruneEmptyErrors: function(errors) {
      return errors.filter(function(error) {
        return !v.isEmpty(error.error);
      });
    },

    // In
    // [{error: ["err1", "err2"], ...}]
    // Out
    // [{error: "err1", ...}, {error: "err2", ...}]
    //
    // All attributes in an error with multiple messages are duplicated
    // when expanding the errors.
    expandMultipleErrors: function(errors) {
      var ret = [];
      errors.forEach(function(error) {
        // Removes errors without a message
        if (v.isArray(error.error)) {
          error.error.forEach(function(msg) {
            ret.push(v.extend({}, error, {error: msg}));
          });
        } else {
          ret.push(error);
        }
      });
      return ret;
    },

    // Converts the error mesages by prepending the attribute name unless the
    // message is prefixed by ^
    convertErrorMessages: function(errors, options) {
      options = options || {};

      var ret = [];
      errors.forEach(function(errorInfo) {
        var error = v.result(errorInfo.error,
            errorInfo.value,
            errorInfo.attribute,
            errorInfo.options,
            errorInfo.attributes,
            errorInfo.globalOptions);

        if (!v.isString(error)) {
          ret.push(errorInfo);
          return;
        }

        if (error[0] === '^') {
          error = error.slice(1);
        } else if (options.fullMessages !== false) {
          error = v.capitalize(v.prettify(errorInfo.attribute)) + " " + error;
        }
        error = error.replace(/\\\^/g, "^");
        error = v.format(error, {value: v.stringifyValue(errorInfo.value)});
        ret.push(v.extend({}, errorInfo, {error: error}));
      });
      return ret;
    },

    // In:
    // [{attribute: "<attributeName>", ...}]
    // Out:
    // {"<attributeName>": [{attribute: "<attributeName>", ...}]}
    groupErrorsByAttribute: function(errors) {
      var ret = {};
      errors.forEach(function(error) {
        var list = ret[error.attribute];
        if (list) {
          list.push(error);
        } else {
          ret[error.attribute] = [error];
        }
      });
      return ret;
    },

    // In:
    // [{error: "<message 1>", ...}, {error: "<message 2>", ...}]
    // Out:
    // ["<message 1>", "<message 2>"]
    flattenErrorsToArray: function(errors) {
      return errors.map(function(error) { return error.error; });
    },

    cleanAttributes: function(attributes, whitelist) {
      function whitelistCreator(obj, key, last) {
        if (v.isObject(obj[key])) {
          return obj[key];
        }
        return (obj[key] = last ? true : {});
      }

      function buildObjectWhitelist(whitelist) {
        var ow = {}
          , lastObject
          , attr;
        for (attr in whitelist) {
          if (!whitelist[attr]) {
            continue;
          }
          v.forEachKeyInKeypath(ow, attr, whitelistCreator);
        }
        return ow;
      }

      function cleanRecursive(attributes, whitelist) {
        if (!v.isObject(attributes)) {
          return attributes;
        }

        var ret = v.extend({}, attributes)
          , w
          , attribute;

        for (attribute in attributes) {
          w = whitelist[attribute];

          if (v.isObject(w)) {
            ret[attribute] = cleanRecursive(ret[attribute], w);
          } else if (!w) {
            delete ret[attribute];
          }
        }
        return ret;
      }

      if (!v.isObject(whitelist) || !v.isObject(attributes)) {
        return {};
      }

      whitelist = buildObjectWhitelist(whitelist);
      return cleanRecursive(attributes, whitelist);
    },

    exposeModule: function(validate, root, exports, module, define) {
      if (exports) {
        if (module && module.exports) {
          exports = module.exports = validate;
        }
        exports.validate = validate;
      } else {
        root.validate = validate;
        if (validate.isFunction(define) && define.amd) {
          define([], function () { return validate; });
        }
      }
    },

    warn: function(msg) {
      if (typeof console !== "undefined" && console.warn) {
        console.warn("[validate.js] " + msg);
      }
    },

    error: function(msg) {
      if (typeof console !== "undefined" && console.error) {
        console.error("[validate.js] " + msg);
      }
    }
  });

  validate.validators = {
    // Presence validates that the value isn't empty
    presence: function(value, options) {
      options = v.extend({}, this.options, options);
      if (v.isEmpty(value)) {
        return options.message || this.message || "can't be blank";
      }
    },
    length: function(value, options, attribute) {
      // Empty values are allowed
      if (v.isEmpty(value)) {
        return;
      }

      options = v.extend({}, this.options, options);

      var is = options.is
        , maximum = options.maximum
        , minimum = options.minimum
        , tokenizer = options.tokenizer || function(val) { return val; }
        , err
        , errors = [];

      value = tokenizer(value);
      var length = value.length;
      if(!v.isNumber(length)) {
        v.error(v.format("Attribute %{attr} has a non numeric value for `length`", {attr: attribute}));
        return options.message || this.notValid || "has an incorrect length";
      }

      // Is checks
      if (v.isNumber(is) && length !== is) {
        err = options.wrongLength ||
          this.wrongLength ||
          "is the wrong length (should be %{count} characters)";
        errors.push(v.format(err, {count: is}));
      }

      if (v.isNumber(minimum) && length < minimum) {
        err = options.tooShort ||
          this.tooShort ||
          "is too short (minimum is %{count} characters)";
        errors.push(v.format(err, {count: minimum}));
      }

      if (v.isNumber(maximum) && length > maximum) {
        err = options.tooLong ||
          this.tooLong ||
          "is too long (maximum is %{count} characters)";
        errors.push(v.format(err, {count: maximum}));
      }

      if (errors.length > 0) {
        return options.message || errors;
      }
    },
    numericality: function(value, options) {
      // Empty values are fine
      if (v.isEmpty(value)) {
        return;
      }

      options = v.extend({}, this.options, options);

      var errors = []
        , name
        , count
        , checks = {
            greaterThan:          function(v, c) { return v > c; },
            greaterThanOrEqualTo: function(v, c) { return v >= c; },
            equalTo:              function(v, c) { return v === c; },
            lessThan:             function(v, c) { return v < c; },
            lessThanOrEqualTo:    function(v, c) { return v <= c; }
          };

      // Coerce the value to a number unless we're being strict.
      if (options.noStrings !== true && v.isString(value)) {
        value = +value;
      }

      // If it's not a number we shouldn't continue since it will compare it.
      if (!v.isNumber(value)) {
        return options.message || options.notValid || this.notValid || "is not a number";
      }

      // Same logic as above, sort of. Don't bother with comparisons if this
      // doesn't pass.
      if (options.onlyInteger && !v.isInteger(value)) {
        return options.message || options.notInteger || this.notInteger  || "must be an integer";
      }

      for (name in checks) {
        count = options[name];
        if (v.isNumber(count) && !checks[name](value, count)) {
          // This picks the default message if specified
          // For example the greaterThan check uses the message from
          // this.notGreaterThan so we capitalize the name and prepend "not"
          var key = "not" + v.capitalize(name);
          var msg = options[key] || this[key] || "must be %{type} %{count}";

          errors.push(v.format(msg, {
            count: count,
            type: v.prettify(name)
          }));
        }
      }

      if (options.odd && value % 2 !== 1) {
        errors.push(options.notOdd || this.notOdd || "must be odd");
      }
      if (options.even && value % 2 !== 0) {
        errors.push(options.notEven || this.notEven || "must be even");
      }

      if (errors.length) {
        return options.message || errors;
      }
    },
    datetime: v.extend(function(value, options) {
      if (!v.isFunction(this.parse) || !v.isFunction(this.format)) {
        throw new Error("Both the parse and format functions needs to be set to use the datetime/date validator");
      }

      // Empty values are fine
      if (v.isEmpty(value)) {
        return;
      }

      options = v.extend({}, this.options, options);

      var err
        , errors = []
        , earliest = options.earliest ? this.parse(options.earliest, options) : NaN
        , latest = options.latest ? this.parse(options.latest, options) : NaN;

      value = this.parse(value, options);

      // 86400000 is the number of seconds in a day, this is used to remove
      // the time from the date
      if (isNaN(value) || options.dateOnly && value % 86400000 !== 0) {
        return options.message || this.notValid || "must be a valid date";
      }

      if (!isNaN(earliest) && value < earliest) {
        err = this.tooEarly || "must be no earlier than %{date}";
        err = v.format(err, {date: this.format(earliest, options)});
        errors.push(err);
      }

      if (!isNaN(latest) && value > latest) {
        err = this.tooLate || "must be no later than %{date}";
        err = v.format(err, {date: this.format(latest, options)});
        errors.push(err);
      }

      if (errors.length) {
        return options.message || errors;
      }
    }, {
      parse: null,
      format: null
    }),
    date: function(value, options) {
      options = v.extend({}, options, {dateOnly: true});
      return v.validators.datetime.call(v.validators.datetime, value, options);
    },
    format: function(value, options) {
      if (v.isString(options) || (options instanceof RegExp)) {
        options = {pattern: options};
      }

      options = v.extend({}, this.options, options);

      var message = options.message || this.message || "is invalid"
        , pattern = options.pattern
        , match;

      // Empty values are allowed
      if (v.isEmpty(value)) {
        return;
      }
      if (!v.isString(value)) {
        return message;
      }

      if (v.isString(pattern)) {
        pattern = new RegExp(options.pattern, options.flags);
      }
      match = pattern.exec(value);
      if (!match || match[0].length != value.length) {
        return message;
      }
    },
    inclusion: function(value, options) {
      // Empty values are fine
      if (v.isEmpty(value)) {
        return;
      }
      if (v.isArray(options)) {
        options = {within: options};
      }
      options = v.extend({}, this.options, options);
      if (v.contains(options.within, value)) {
        return;
      }
      var message = options.message ||
        this.message ||
        "^%{value} is not included in the list";
      return v.format(message, {value: value});
    },
    exclusion: function(value, options) {
      // Empty values are fine
      if (v.isEmpty(value)) {
        return;
      }
      if (v.isArray(options)) {
        options = {within: options};
      }
      options = v.extend({}, this.options, options);
      if (!v.contains(options.within, value)) {
        return;
      }
      var message = options.message || this.message || "^%{value} is restricted";
      return v.format(message, {value: value});
    },
    email: v.extend(function(value, options) {
      options = v.extend({}, this.options, options);
      var message = options.message || this.message || "is not a valid email";
      // Empty values are fine
      if (v.isEmpty(value)) {
        return;
      }
      if (!v.isString(value)) {
        return message;
      }
      if (!this.PATTERN.exec(value)) {
        return message;
      }
    }, {
      PATTERN: /^[a-z0-9\u007F-\uffff!#$%&'*+\/=?^_`{|}~-]+(?:\.[a-z0-9\u007F-\uffff!#$%&'*+\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z]{2,}$/i
    }),
    equality: function(value, options, attribute, attributes) {
      if (v.isEmpty(value)) {
        return;
      }

      if (v.isString(options)) {
        options = {attribute: options};
      }
      options = v.extend({}, this.options, options);
      var message = options.message ||
        this.message ||
        "is not equal to %{attribute}";

      if (v.isEmpty(options.attribute) || !v.isString(options.attribute)) {
        throw new Error("The attribute must be a non empty string");
      }

      var otherValue = v.getDeepObjectValue(attributes, options.attribute)
        , comparator = options.comparator || function(v1, v2) {
          return v1 === v2;
        };

      if (!comparator(value, otherValue, options, attribute, attributes)) {
        return v.format(message, {attribute: v.prettify(options.attribute)});
      }
    },

    // A URL validator that is used to validate URLs with the ability to
    // restrict schemes and some domains.
    url: function(value, options) {
      if (v.isEmpty(value)) {
        return;
      }

      options = v.extend({}, this.options, options);

      var message = options.message || this.message || "is not a valid url"
        , schemes = options.schemes || this.schemes || ['http', 'https']
        , allowLocal = options.allowLocal || this.allowLocal || false;

      if (!v.isString(value)) {
        return message;
      }

      // https://gist.github.com/dperini/729294
      var regex =
        "^" +
          // schemes
          "(?:(?:" + schemes.join("|") + "):\\/\\/)" +
          // credentials
          "(?:\\S+(?::\\S*)?@)?";

      regex += "(?:";

      var hostname =
          "(?:(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)" +
          "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)*" +
          "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))";

      // This ia a special case for the localhost hostname
      if (allowLocal) {
        hostname = "(?:localhost|" + hostname + ")";
      } else {
          // private & local addresses
          regex +=
              "(?!10(?:\\.\\d{1,3}){3})" +
              "(?!127(?:\\.\\d{1,3}){3})" +
              "(?!169\\.254(?:\\.\\d{1,3}){2})" +
              "(?!192\\.168(?:\\.\\d{1,3}){2})" +
              "(?!172" +
                "\\.(?:1[6-9]|2\\d|3[0-1])" +
                "(?:\\.\\d{1,3})" +
              "{2})";
      }

      // reserved addresses
      regex +=
          "(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])" +
          "(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}" +
          "(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))" +
        "|" +
          hostname +
          // port number
          "(?::\\d{2,5})?" +
          // path
          "(?:\\/[^\\s]*)?" +
        "$";

      var PATTERN = new RegExp(regex, 'i');
      if (!PATTERN.exec(value)) {
        return message;
      }
    }
  };

  validate.exposeModule(validate, this, exports, module, define);
}).call(this,
        typeof exports !== 'undefined' ? /* istanbul ignore next */ exports : null,
        typeof module !== 'undefined' ? /* istanbul ignore next */ module : null,
        typeof define !== 'undefined' ? /* istanbul ignore next */ define : null);

},{}],142:[function(require,module,exports){
(function (process,Buffer){
// Generated by CoffeeScript 1.6.3
(function() {
  var InvalidStateError, NetworkError, SecurityError, XMLHttpRequest, XMLHttpRequestEventTarget, XMLHttpRequestProgressEvent, XMLHttpRequestUpload, http, https, os, url, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  XMLHttpRequestEventTarget = (function() {
    function XMLHttpRequestEventTarget() {
      this.onloadstart = null;
      this.onprogress = null;
      this.onabort = null;
      this.onerror = null;
      this.onload = null;
      this.ontimeout = null;
      this.onloadend = null;
      this._listeners = {};
    }

    XMLHttpRequestEventTarget.prototype.onloadstart = null;

    XMLHttpRequestEventTarget.prototype.onprogress = null;

    XMLHttpRequestEventTarget.prototype.onabort = null;

    XMLHttpRequestEventTarget.prototype.onerror = null;

    XMLHttpRequestEventTarget.prototype.onload = null;

    XMLHttpRequestEventTarget.prototype.ontimeout = null;

    XMLHttpRequestEventTarget.prototype.onloadend = null;

    XMLHttpRequestEventTarget.prototype.addEventListener = function(eventType, listener) {
      var _base;
      eventType = eventType.toLowerCase();
      (_base = this._listeners)[eventType] || (_base[eventType] = []);
      this._listeners[eventType].push(listener);
      return void 0;
    };

    XMLHttpRequestEventTarget.prototype.removeEventListener = function(eventType, listener) {
      var index;
      eventType = eventType.toLowerCase();
      if (this._listeners[eventType]) {
        index = this._listeners[eventType].indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      }
      return void 0;
    };

    XMLHttpRequestEventTarget.prototype.dispatchEvent = function(event) {
      var eventType, listener, listeners, _i, _len;
      eventType = event.type;
      if (listeners = this._listeners[eventType]) {
        for (_i = 0, _len = listeners.length; _i < _len; _i++) {
          listener = listeners[_i];
          listener(event);
        }
      }
      if (listener = this["on" + eventType]) {
        listener(event);
      }
      return void 0;
    };

    return XMLHttpRequestEventTarget;

  })();

  http = require('http');

  https = require('https');

  os = require('os');

  url = require('url');

  XMLHttpRequest = (function(_super) {
    __extends(XMLHttpRequest, _super);

    function XMLHttpRequest(options) {
      XMLHttpRequest.__super__.constructor.call(this);
      this.onreadystatechange = null;
      this._anonymous = options && options.anon;
      this.readyState = XMLHttpRequest.UNSENT;
      this.response = null;
      this.responseText = '';
      this.responseType = '';
      this.status = 0;
      this.statusText = '';
      this.timeout = 0;
      this.upload = new XMLHttpRequestUpload(this);
      this._method = null;
      this._url = null;
      this._sync = false;
      this._headers = null;
      this._loweredHeaders = null;
      this._mimeOverride = null;
      this._request = null;
      this._response = null;
      this._responseParts = null;
      this._responseHeaders = null;
      this._aborting = null;
      this._error = null;
      this._loadedBytes = 0;
      this._totalBytes = 0;
      this._lengthComputable = false;
    }

    XMLHttpRequest.prototype.onreadystatechange = null;

    XMLHttpRequest.prototype.readyState = null;

    XMLHttpRequest.prototype.response = null;

    XMLHttpRequest.prototype.responseText = null;

    XMLHttpRequest.prototype.responseType = null;

    XMLHttpRequest.prototype.status = null;

    XMLHttpRequest.prototype.timeout = null;

    XMLHttpRequest.prototype.upload = null;

    XMLHttpRequest.prototype.open = function(method, url, async, user, password) {
      var xhrUrl;
      method = method.toUpperCase();
      if (method in this._restrictedMethods) {
        throw new SecurityError("HTTP method " + method + " is not allowed in XHR");
      }
      xhrUrl = this._parseUrl(url);
      if (async === void 0) {
        async = true;
      }
      switch (this.readyState) {
        case XMLHttpRequest.UNSENT:
        case XMLHttpRequest.OPENED:
        case XMLHttpRequest.DONE:
          null;
          break;
        case XMLHttpRequest.HEADERS_RECEIVED:
        case XMLHttpRequest.LOADING:
          null;
      }
      this._method = method;
      this._url = xhrUrl;
      this._sync = !async;
      this._headers = {};
      this._loweredHeaders = {};
      this._mimeOverride = null;
      this._setReadyState(XMLHttpRequest.OPENED);
      this._request = null;
      this._response = null;
      this.status = 0;
      this.statusText = '';
      this._responseParts = [];
      this._responseHeaders = null;
      this._loadedBytes = 0;
      this._totalBytes = 0;
      this._lengthComputable = false;
      return void 0;
    };

    XMLHttpRequest.prototype.setRequestHeader = function(name, value) {
      var loweredName;
      if (this.readyState !== XMLHttpRequest.OPENED) {
        throw new InvalidStateError("XHR readyState must be OPENED");
      }
      loweredName = name.toLowerCase();
      if (this._restrictedHeaders[loweredName] || /^sec\-/.test(loweredName) || /^proxy-/.test(loweredName)) {
        console.warn("Refused to set unsafe header \"" + name + "\"");
        return void 0;
      }
      value = value.toString();
      if (loweredName in this._loweredHeaders) {
        name = this._loweredHeaders[loweredName];
        this._headers[name] = this._headers[name] + ', ' + value;
      } else {
        this._loweredHeaders[loweredName] = name;
        this._headers[name] = value;
      }
      return void 0;
    };

    XMLHttpRequest.prototype.send = function(data) {
      if (this.readyState !== XMLHttpRequest.OPENED) {
        throw new InvalidStateError("XHR readyState must be OPENED");
      }
      if (this._request) {
        throw new InvalidStateError("send() already called");
      }
      switch (this._url.protocol) {
        case 'file:':
          this._sendFile(data);
          break;
        case 'http:':
        case 'https:':
          this._sendHttp(data);
          break;
        default:
          throw new NetworkError("Unsupported protocol " + this._url.protocol);
      }
      return void 0;
    };

    XMLHttpRequest.prototype.abort = function() {
      if (!this._request) {
        return;
      }
      this._request.abort();
      this._setError();
      this._dispatchProgress('abort');
      this._dispatchProgress('loadend');
      return void 0;
    };

    XMLHttpRequest.prototype.getResponseHeader = function(name) {
      var loweredName;
      if (!this._responseHeaders) {
        return null;
      }
      loweredName = name.toLowerCase();
      if (loweredName in this._responseHeaders) {
        return this._responseHeaders[loweredName];
      } else {
        return null;
      }
    };

    XMLHttpRequest.prototype.getAllResponseHeaders = function() {
      var lines, name, value;
      if (!this._responseHeaders) {
        return '';
      }
      lines = (function() {
        var _ref, _results;
        _ref = this._responseHeaders;
        _results = [];
        for (name in _ref) {
          value = _ref[name];
          _results.push("" + name + ": " + value);
        }
        return _results;
      }).call(this);
      return lines.join("\r\n");
    };

    XMLHttpRequest.prototype.overrideMimeType = function(newMimeType) {
      if (this.readyState === XMLHttpRequest.LOADING || this.readyState === XMLHttpRequest.DONE) {
        throw new InvalidStateError("overrideMimeType() not allowed in LOADING or DONE");
      }
      this._mimeOverride = newMimeType.toLowerCase();
      return void 0;
    };

    XMLHttpRequest.prototype.nodejsSet = function(options) {
      if ('httpAgent' in options) {
        this.nodejsHttpAgent = options.httpAgent;
      }
      if ('httpsAgent' in options) {
        this.nodejsHttpsAgent = options.httpsAgent;
      }
      return void 0;
    };

    XMLHttpRequest.nodejsSet = function(options) {
      XMLHttpRequest.prototype.nodejsSet(options);
      return void 0;
    };

    XMLHttpRequest.prototype.UNSENT = 0;

    XMLHttpRequest.UNSENT = 0;

    XMLHttpRequest.prototype.OPENED = 1;

    XMLHttpRequest.OPENED = 1;

    XMLHttpRequest.prototype.HEADERS_RECEIVED = 2;

    XMLHttpRequest.HEADERS_RECEIVED = 2;

    XMLHttpRequest.prototype.LOADING = 3;

    XMLHttpRequest.LOADING = 3;

    XMLHttpRequest.prototype.DONE = 4;

    XMLHttpRequest.DONE = 4;

    XMLHttpRequest.prototype.nodejsHttpAgent = http.globalAgent;

    XMLHttpRequest.prototype.nodejsHttpsAgent = https.globalAgent;

    XMLHttpRequest.prototype._restrictedMethods = {
      CONNECT: true,
      TRACE: true,
      TRACK: true
    };

    XMLHttpRequest.prototype._restrictedHeaders = {
      'accept-charset': true,
      'accept-encoding': true,
      'access-control-request-headers': true,
      'access-control-request-method': true,
      connection: true,
      'content-length': true,
      cookie: true,
      cookie2: true,
      date: true,
      dnt: true,
      expect: true,
      host: true,
      'keep-alive': true,
      origin: true,
      referer: true,
      te: true,
      trailer: true,
      'transfer-encoding': true,
      upgrade: true,
      'user-agent': true,
      via: true
    };

    XMLHttpRequest.prototype._privateHeaders = {
      'set-cookie': true,
      'set-cookie2': true
    };

    XMLHttpRequest.prototype._userAgent = ("Mozilla/5.0 (" + (os.type()) + " " + (os.arch()) + ") ") + ("node.js/" + process.versions.node + " v8/" + process.versions.v8);

    XMLHttpRequest.prototype._setReadyState = function(newReadyState) {
      var event;
      this.readyState = newReadyState;
      event = new XMLHttpRequestProgressEvent('readystatechange', this);
      this.dispatchEvent(event);
      return void 0;
    };

    XMLHttpRequest.prototype._sendFile = function() {
      if (this._url.method !== 'GET') {
        throw new NetworkError('The file protocol only supports GET');
      }
      throw new Error("Protocol file: not implemented");
    };

    XMLHttpRequest.prototype._sendHttp = function(data) {
      if (this._sync) {
        throw new Error("Synchronous XHR processing not implemented");
      }
      if ((data != null) && (this._method === 'GET' || this._method === 'HEAD')) {
        console.warn("Discarding entity body for " + this._method + " requests");
        data = null;
      } else {
        data || (data = '');
      }
      this.upload._setData(data);
      this._finalizeHeaders();
      this._sendHxxpRequest();
      return void 0;
    };

    XMLHttpRequest.prototype._sendHxxpRequest = function() {
      var agent, hxxp, request,
        _this = this;
      if (this._url.protocol === 'http:') {
        hxxp = http;
        agent = this.nodejsHttpAgent;
      } else {
        hxxp = https;
        agent = this.nodejsHttpsAgent;
      }
      request = hxxp.request({
        hostname: this._url.hostname,
        port: this._url.port,
        path: this._url.path,
        auth: this._url.auth,
        method: this._method,
        headers: this._headers,
        agent: agent
      });
      this._request = request;
      if (this.timeout) {
        request.setTimeout(this.timeout, function() {
          return _this._onHttpTimeout(request);
        });
      }
      request.on('response', function(response) {
        return _this._onHttpResponse(request, response);
      });
      request.on('error', function(error) {
        return _this._onHttpRequestError(request, error);
      });
      this.upload._startUpload(request);
      if (this._request === request) {
        this._dispatchProgress('loadstart');
      }
      return void 0;
    };

    XMLHttpRequest.prototype._finalizeHeaders = function() {
      this._headers['Connection'] = 'keep-alive';
      this._headers['Host'] = this._url.host;
      if (this._anonymous) {
        this._headers['Referer'] = 'about:blank';
      }
      this._headers['User-Agent'] = this._userAgent;
      this.upload._finalizeHeaders(this._headers, this._loweredHeaders);
      return void 0;
    };

    XMLHttpRequest.prototype._onHttpResponse = function(request, response) {
      var lengthString,
        _this = this;
      if (this._request !== request) {
        return;
      }
      switch (response.statusCode) {
        case 301:
        case 302:
        case 303:
        case 307:
        case 308:
          this._url = this._parseUrl(response.headers['location']);
          this._method = 'GET';
          if ('content-type' in this._loweredHeaders) {
            delete this._headers[this._loweredHeaders['content-type']];
            delete this._loweredHeaders['content-type'];
          }
          if ('Content-Type' in this._headers) {
            delete this._headers['Content-Type'];
          }
          delete this._headers['Content-Length'];
          this.upload._reset();
          this._finalizeHeaders();
          this._sendHxxpRequest();
          return;
      }
      this._response = response;
      this._response.on('data', function(data) {
        return _this._onHttpResponseData(response, data);
      });
      this._response.on('end', function() {
        return _this._onHttpResponseEnd(response);
      });
      this._response.on('close', function() {
        return _this._onHttpResponseClose(response);
      });
      this.status = this._response.statusCode;
      this.statusText = http.STATUS_CODES[this.status];
      this._parseResponseHeaders(response);
      if (lengthString = this._responseHeaders['content-length']) {
        this._totalBytes = parseInt(lengthString);
        this._lengthComputable = true;
      } else {
        this._lengthComputable = false;
      }
      return this._setReadyState(XMLHttpRequest.HEADERS_RECEIVED);
    };

    XMLHttpRequest.prototype._onHttpResponseData = function(response, data) {
      if (this._response !== response) {
        return;
      }
      this._responseParts.push(data);
      this._loadedBytes += data.length;
      if (this.readyState !== XMLHttpRequest.LOADING) {
        this._setReadyState(XMLHttpRequest.LOADING);
      }
      return this._dispatchProgress('progress');
    };

    XMLHttpRequest.prototype._onHttpResponseEnd = function(response) {
      if (this._response !== response) {
        return;
      }
      this._parseResponse();
      this._request = null;
      this._response = null;
      this._setReadyState(XMLHttpRequest.DONE);
      this._dispatchProgress('load');
      return this._dispatchProgress('loadend');
    };

    XMLHttpRequest.prototype._onHttpResponseClose = function(response) {
      var request;
      if (this._response !== response) {
        return;
      }
      request = this._request;
      this._setError();
      request.abort();
      this._setReadyState(XMLHttpRequest.DONE);
      this._dispatchProgress('error');
      return this._dispatchProgress('loadend');
    };

    XMLHttpRequest.prototype._onHttpTimeout = function(request) {
      if (this._request !== request) {
        return;
      }
      this._setError();
      request.abort();
      this._setReadyState(XMLHttpRequest.DONE);
      this._dispatchProgress('timeout');
      return this._dispatchProgress('loadend');
    };

    XMLHttpRequest.prototype._onHttpRequestError = function(request, error) {
      if (this._request !== request) {
        return;
      }
      this._setError();
      request.abort();
      this._setReadyState(XMLHttpRequest.DONE);
      this._dispatchProgress('error');
      return this._dispatchProgress('loadend');
    };

    XMLHttpRequest.prototype._dispatchProgress = function(eventType) {
      var event;
      event = new XMLHttpRequestProgressEvent(eventType, this);
      event.lengthComputable = this._lengthComputable;
      event.loaded = this._loadedBytes;
      event.total = this._totalBytes;
      this.dispatchEvent(event);
      return void 0;
    };

    XMLHttpRequest.prototype._setError = function() {
      this._request = null;
      this._response = null;
      this._responseHeaders = null;
      this._responseParts = null;
      return void 0;
    };

    XMLHttpRequest.prototype._parseUrl = function(urlString) {
      var index, password, user, xhrUrl;
      xhrUrl = url.parse(urlString, false, true);
      xhrUrl.hash = null;
      if (xhrUrl.auth && ((typeof user !== "undefined" && user !== null) || (typeof password !== "undefined" && password !== null))) {
        index = xhrUrl.auth.indexOf(':');
        if (index === -1) {
          if (!user) {
            user = xhrUrl.auth;
          }
        } else {
          if (!user) {
            user = xhrUrl.substring(0, index);
          }
          if (!password) {
            password = xhrUrl.substring(index + 1);
          }
        }
      }
      if (user || password) {
        xhrUrl.auth = "" + user + ":" + password;
      }
      return xhrUrl;
    };

    XMLHttpRequest.prototype._parseResponseHeaders = function(response) {
      var loweredName, name, value, _ref;
      this._responseHeaders = {};
      _ref = response.headers;
      for (name in _ref) {
        value = _ref[name];
        loweredName = name.toLowerCase();
        if (this._privateHeaders[loweredName]) {
          continue;
        }
        if (this._mimeOverride !== null && loweredName === 'content-type') {
          value = this._mimeOverride;
        }
        this._responseHeaders[loweredName] = value;
      }
      if (this._mimeOverride !== null && !('content-type' in this._responseHeaders)) {
        this._responseHeaders['content-type'] = this._mimeOverride;
      }
      return void 0;
    };

    XMLHttpRequest.prototype._parseResponse = function() {
      var arrayBuffer, buffer, i, jsonError, view, _i, _ref;
      if (Buffer.concat) {
        buffer = Buffer.concat(this._responseParts);
      } else {
        buffer = this._concatBuffers(this._responseParts);
      }
      this._responseParts = null;
      switch (this.responseType) {
        case 'text':
          this._parseTextResponse(buffer);
          break;
        case 'json':
          this.responseText = null;
          try {
            this.response = JSON.parse(buffer.toString('utf-8'));
          } catch (_error) {
            jsonError = _error;
            this.response = null;
          }
          break;
        case 'buffer':
          this.responseText = null;
          this.response = buffer;
          break;
        case 'arraybuffer':
          this.responseText = null;
          arrayBuffer = new ArrayBuffer(buffer.length);
          view = new Uint8Array(arrayBuffer);
          for (i = _i = 0, _ref = buffer.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            view[i] = buffer[i];
          }
          this.response = arrayBuffer;
          break;
        default:
          this._parseTextResponse(buffer);
      }
      return void 0;
    };

    XMLHttpRequest.prototype._parseTextResponse = function(buffer) {
      var e;
      try {
        this.responseText = buffer.toString(this._parseResponseEncoding());
      } catch (_error) {
        e = _error;
        this.responseText = buffer.toString('binary');
      }
      this.response = this.responseText;
      return void 0;
    };

    XMLHttpRequest.prototype._parseResponseEncoding = function() {
      var contentType, encoding, match;
      encoding = null;
      if (contentType = this._responseHeaders['content-type']) {
        if (match = /\;\s*charset\=(.*)$/.exec(contentType)) {
          return match[1];
        }
      }
      return 'utf-8';
    };

    XMLHttpRequest.prototype._concatBuffers = function(buffers) {
      var buffer, length, target, _i, _j, _len, _len1;
      if (buffers.length === 0) {
        return new Buffer(0);
      }
      if (buffers.length === 1) {
        return buffers[0];
      }
      length = 0;
      for (_i = 0, _len = buffers.length; _i < _len; _i++) {
        buffer = buffers[_i];
        length += buffer.length;
      }
      target = new Buffer(length);
      length = 0;
      for (_j = 0, _len1 = buffers.length; _j < _len1; _j++) {
        buffer = buffers[_j];
        buffer.copy(target, length);
        length += buffer.length;
      }
      return target;
    };

    return XMLHttpRequest;

  })(XMLHttpRequestEventTarget);

  module.exports = XMLHttpRequest;

  XMLHttpRequest.XMLHttpRequest = XMLHttpRequest;

  SecurityError = (function(_super) {
    __extends(SecurityError, _super);

    function SecurityError() {
      SecurityError.__super__.constructor.apply(this, arguments);
    }

    return SecurityError;

  })(Error);

  XMLHttpRequest.SecurityError = SecurityError;

  InvalidStateError = (function(_super) {
    __extends(InvalidStateError, _super);

    function InvalidStateError() {
      InvalidStateError.__super__.constructor.apply(this, arguments);
    }

    return InvalidStateError;

  })(Error);

  InvalidStateError = (function(_super) {
    __extends(InvalidStateError, _super);

    function InvalidStateError() {
      _ref = InvalidStateError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return InvalidStateError;

  })(Error);

  XMLHttpRequest.InvalidStateError = InvalidStateError;

  NetworkError = (function(_super) {
    __extends(NetworkError, _super);

    function NetworkError() {
      NetworkError.__super__.constructor.apply(this, arguments);
    }

    return NetworkError;

  })(Error);

  XMLHttpRequest.NetworkError = NetworkError;

  XMLHttpRequestProgressEvent = (function() {
    function XMLHttpRequestProgressEvent(type, target) {
      this.type = type;
      this.target = target;
      this.currentTarget = this.target;
      this.lengthComputable = false;
      this.loaded = 0;
      this.total = 0;
    }

    XMLHttpRequestProgressEvent.prototype.bubbles = false;

    XMLHttpRequestProgressEvent.prototype.cancelable = false;

    XMLHttpRequestProgressEvent.prototype.target = null;

    XMLHttpRequestProgressEvent.prototype.loaded = null;

    XMLHttpRequestProgressEvent.prototype.lengthComputable = null;

    XMLHttpRequestProgressEvent.prototype.total = null;

    return XMLHttpRequestProgressEvent;

  })();

  XMLHttpRequest.XMLHttpRequestProgressEvent = XMLHttpRequestProgressEvent;

  XMLHttpRequestUpload = (function(_super) {
    __extends(XMLHttpRequestUpload, _super);

    function XMLHttpRequestUpload(request) {
      XMLHttpRequestUpload.__super__.constructor.call(this);
      this._request = request;
      this._reset();
    }

    XMLHttpRequestUpload.prototype._reset = function() {
      this._contentType = null;
      this._body = null;
      return void 0;
    };

    XMLHttpRequestUpload.prototype._setData = function(data) {
      var body, i, offset, view, _i, _j, _ref1, _ref2;
      if (typeof data === 'undefined' || data === null) {
        return;
      }
      if (typeof data === 'string') {
        if (data.length !== 0) {
          this._contentType = 'text/plain;charset=UTF-8';
        }
        this._body = new Buffer(data, 'utf8');
      } else if (Buffer.isBuffer(data)) {
        this._body = data;
      } else if (data instanceof ArrayBuffer) {
        body = new Buffer(data.byteLength);
        view = new Uint8Array(data);
        for (i = _i = 0, _ref1 = data.byteLength; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
          body[i] = view[i];
        }
        this._body = body;
      } else if (data.buffer && data.buffer instanceof ArrayBuffer) {
        body = new Buffer(data.byteLength);
        offset = data.byteOffset;
        view = new Uint8Array(data.buffer);
        for (i = _j = 0, _ref2 = data.byteLength; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
          body[i] = view[i + offset];
        }
        this._body = body;
      } else {
        throw new Error("Unsupported send() data " + data);
      }
      return void 0;
    };

    XMLHttpRequestUpload.prototype._finalizeHeaders = function(headers, loweredHeaders) {
      if (this._contentType) {
        if (!('content-type' in loweredHeaders)) {
          headers['Content-Type'] = this._contentType;
        }
      }
      if (this._body) {
        headers['Content-Length'] = this._body.length.toString();
      }
      return void 0;
    };

    XMLHttpRequestUpload.prototype._startUpload = function(request) {
      if (this._body) {
        request.write(this._body);
      }
      request.end();
      return void 0;
    };

    return XMLHttpRequestUpload;

  })(XMLHttpRequestEventTarget);

  XMLHttpRequest.XMLHttpRequestUpload = XMLHttpRequestUpload;

}).call(this);

}).call(this,require('_process'),require("buffer").Buffer)
},{"_process":87,"buffer":44,"http":127,"https":73,"os":82,"url":138}],143:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],144:[function(require,module,exports){
'use strict';

var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
  , length = 64
  , map = {}
  , seed = 0
  , i = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +'.'+ encode(seed++);
}

//
// Map each character to its index.
//
for (; i < length; i++) map[alphabet[i]] = i;

//
// Expose the `yeast`, `encode` and `decode` functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;

},{}]},{},[1])(1)
});
